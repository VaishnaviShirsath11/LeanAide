[["The element of G ",{"type":"{N : Type u_1} → {G : Type u_2} → [inst : Group N] → [inst_1 : Group G] → {φ : G →* MulAut N} → N ⋊[φ] G → G","name":"SemidirectProduct.right","isProp":false,"docString":"The element of G ","distance":0.391142380109363918538889492992893792688846588134765625}],[" For any measure space with measurable space and measure, and two functions from to the extended nonnegative real numbers with being almost everywhere less than or equal to almost everywhere measurable g, the integral of f with respect to μ and ε times the measure of {x | f(x) + ε < g(x)} is less than or equal to the integral of g with respect to μ.",{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f g : α → ENNReal},\n  μ.ae.EventuallyLE f g →\n    AEMeasurable g μ → ∀ (ε : ENNReal), ∫⁻ (a : α), f a ∂μ + ε * ↑↑μ {x | f x + ε ≤ g x} ≤ ∫⁻ (a : α), g a ∂μ","name":"MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral","isProp":true,"docString":" For any measure space with measurable space and measure, and two functions from to the extended nonnegative real numbers with being almost everywhere less than or equal to almost everywhere measurable g, the integral of f with respect to μ and ε times the measure of {x | f(x) + ε < g(x)} is less than or equal to the integral of g with respect to μ.","distance":0.4870009906496672869025132968090474605560302734375}],["This theorem states that for any given measurable space 'G', measure 'μ', group 'G', measurable multiplication on 'G', and a left-invariant measure 'μ', the Lebesgue integral of a function 'f' from 'G' to the nonnegative extended real numbers (ENNReal), where 'f' is translated by left-multiplication with an element 'g' of 'G', is equal to the Lebesgue integral of 'f' itself. In other words, multiplying an element 'x' in 'G' by 'g' (from the left) and then applying 'f', doesn't change the overall Lebesgue integral when measured with respect to 'μ'.",{"type":"∀ {G : Type u_1} [inst : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_1 : Group G] [inst_2 : MeasurableMul G]\n  [inst_3 : μ.IsMulLeftInvariant] (f : G → ENNReal) (g : G), ∫⁻ (x : G), f (g * x) ∂μ = ∫⁻ (x : G), f x ∂μ","name":"MeasureTheory.lintegral_mul_left_eq_self","isProp":true,"docString":"This theorem states that for any given measurable space 'G', measure 'μ', group 'G', measurable multiplication on 'G', and a left-invariant measure 'μ', the Lebesgue integral of a function 'f' from 'G' to the nonnegative extended real numbers (ENNReal), where 'f' is translated by left-multiplication with an element 'g' of 'G', is equal to the Lebesgue integral of 'f' itself. In other words, multiplying an element 'x' in 'G' by 'g' (from the left) and then applying 'f', doesn't change the overall Lebesgue integral when measured with respect to 'μ'.","distance":0.4711043117036004534980975222424603998661041259765625}],["The gcongr widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"GCongrSelectionPanel","isProp":false,"docString":"The gcongr widget. ","distance":0.399240338623571222598229724098928272724151611328125}],[" For any subgroup of the special linear group of 2 by 2 matrices with integer entries Γ and integer weight k, two modular forms f and g are equal if and only if they have the same value at every point in the upper half plane.",{"type":"∀ {Γ : Subgroup (Matrix.SpecialLinearGroup (Fin 2) ℤ)} {k : ℤ} {f g : ModularForm Γ k},\n  (∀ (x : UpperHalfPlane), f x = g x) → f = g","name":"ModularForm.ext","isProp":true,"docString":" For any subgroup of the special linear group of 2 by 2 matrices with integer entries Γ and integer weight k, two modular forms f and g are equal if and only if they have the same value at every point in the upper half plane.","distance":0.49584736185662670049367761748726479709148406982421875}],["This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.",{"type":"∀ (n m : ℕ), (SetTheory.PGame.nim ↑n + SetTheory.PGame.nim ↑m).grundyValue = ↑(n ^^^ m)","name":"SetTheory.PGame.grundyValue_nim_add_nim","isProp":true,"docString":"This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.","distance":0.47179647773982591463237667994690127670764923095703125}],["The grading function. ",{"type":"{𝕆 : Type u_5} → {α : Type u_6} → [inst : Preorder 𝕆] → [inst_1 : Preorder α] → [self : GradeOrder 𝕆 α] → α → 𝕆","name":"GradeOrder.grade","isProp":false,"docString":"The grading function. ","distance":0.404761944700843423472491622305824421346187591552734375}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.40836447884570414856852949014864861965179443359375}],["verschiebung is a natural transformation ",{"type":"∀ {p : ℕ} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [inst : CommRing R] [inst_1 : CommRing S]\n  (f : R →+* S) (x : WittVector p R),\n  (WittVector.map f) (WittVector.verschiebung x) = WittVector.verschiebung ((WittVector.map f) x)","name":"WittVector.map_verschiebung","isProp":true,"docString":"verschiebung is a natural transformation ","distance":0.41019535910948612400517276910250075161457061767578125}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.410735813456326093184856063089682720601558685302734375}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.412073952035295454354724142831400968134403228759765625}],["the underlying presieve ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] → {X : C} → CategoryTheory.Sieve X → CategoryTheory.Presieve X","name":"CategoryTheory.Sieve.arrows","isProp":false,"docString":"the underlying presieve ","distance":0.416211211164480621160777218392468057572841644287109375}],["The counit of the coalgebra ",{"type":"{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : AddCommMonoid A] → [inst_2 : Module R A] → [self : CoalgebraStruct R A] → A →ₗ[R] R","name":"CoalgebraStruct.counit","isProp":false,"docString":"The counit of the coalgebra ","distance":0.4173862961493473022756006685085594654083251953125}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.4185004708610176038519057328812777996063232421875}],["The evaluation natural transformation. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      (A : C) →\n        [inst_2 : CategoryTheory.Closed A] →\n          CategoryTheory.Functor.comp (CategoryTheory.ihom A) (CategoryTheory.MonoidalCategory.tensorLeft A) ⟶\n            CategoryTheory.Functor.id C","name":"CategoryTheory.ihom.ev","isProp":false,"docString":"The evaluation natural transformation. ","distance":0.420507471226742202130566283813095651566982269287109375}],["commutation with `g'` ",{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {S₁ S₂ : CategoryTheory.ShortComplex C} {φ : S₁ ⟶ S₂} {h₁ : CategoryTheory.ShortComplex.RightHomologyData S₁}\n  {h₂ : CategoryTheory.ShortComplex.RightHomologyData S₂}\n  (self : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂),\n  CategoryTheory.CategoryStruct.comp self.φQ (CategoryTheory.ShortComplex.RightHomologyData.g' h₂) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.RightHomologyData.g' h₁) φ.τ₃","name":"CategoryTheory.ShortComplex.RightHomologyMapData.commg'","isProp":true,"docString":"commutation with `g'` ","distance":0.4209927572290312891567509723245166242122650146484375}],["The coevaluation natural transformation. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      (A : C) →\n        [inst_2 : CategoryTheory.Closed A] →\n          CategoryTheory.Functor.id C ⟶\n            CategoryTheory.Functor.comp (CategoryTheory.MonoidalCategory.tensorLeft A) (CategoryTheory.ihom A)","name":"CategoryTheory.ihom.coev","isProp":false,"docString":"The coevaluation natural transformation. ","distance":0.4211307923395011254541486778180114924907684326171875}],["lp space ",{"type":"Lean.ParserDescr","name":"lp.«termℓ^∞(_,_)»","isProp":false,"docString":"lp space ","distance":0.422218072436288671678283890287275426089763641357421875}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.422921678584188331928572779361275024712085723876953125}],["The ground set is nonempty ",{"type":"∀ {α : Type u_1} {M : Matroid α} [self : Matroid.Nonempty M], Set.Nonempty M.E","name":"Matroid.Nonempty.ground_nonempty","isProp":true,"docString":"The ground set is nonempty ","distance":0.42348991036487004802069122888497076928615570068359375}],["The counit for the comonad `G`. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (G : CategoryTheory.Comonad C) → G.toFunctor ⟶ CategoryTheory.Functor.id C","name":"CategoryTheory.Comonad.ε","isProp":false,"docString":"The counit for the comonad `G`. ","distance":0.4243555570372359309061494059278629720211029052734375}],["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.4244283274243250136947835926548577845096588134765625}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.4247207753239499172792648096219636499881744384765625}],["One has grade zero ",{"type":"∀ {ι : Type u_1} {R : Type u_2} {S : Type u_3} [inst : SetLike S R] [inst_1 : One R] [inst_2 : Zero ι] {A : ι → S}\n  [self : SetLike.GradedOne A], 1 ∈ A 0","name":"SetLike.GradedOne.one_mem","isProp":true,"docString":"One has grade zero ","distance":0.42618675475972989108441879579913802444934844970703125}]]