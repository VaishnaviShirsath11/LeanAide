[["The statement to be proved inductively ",{"type":"{F : Type u_1} →\n  [inst : Field F] → {E : Type u_2} → [inst_1 : Field E] → [inst_2 : Algebra F E] → ↥(solvableByRad F E) → Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.315249986388612624121918770470074377954006195068359375}],[" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.",{"type":"∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {P : MvPolynomial σ R → Prop} (p : MvPolynomial σ R),\n  (∀ (u : σ →₀ ℕ) (a : R), P ((MvPolynomial.monomial u) a)) → (∀ (p q : MvPolynomial σ R), P p → P q → P (p + q)) → P p","name":"MvPolynomial.induction_on'","isProp":true,"docString":" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.","distance":0.43417419102034415789859167489339597523212432861328125}],["This theorem states that the number 2 is not equal to infinity. In Lean, \"⊤\" is used to represent infinity, usually in the context of extended non-negative real numbers (where real numbers are extended by adding infinity as a value). The proof, which is not shown here, establishes that 2 cannot be the same as infinity, which is intuitively obvious in the realm of real numbers.",{"type":"(2 = ⊤) = False","name":"Mathlib.Data.ENNReal.Basic._auxLemma.32","isProp":true,"docString":"This theorem states that the number 2 is not equal to infinity. In Lean, \"⊤\" is used to represent infinity, usually in the context of extended non-negative real numbers (where real numbers are extended by adding infinity as a value). The proof, which is not shown here, establishes that 2 cannot be the same as infinity, which is intuitively obvious in the realm of real numbers.","distance":0.419240162476998079466028457318316213786602020263671875}],["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J MonCat) → CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.31673016984172541743447482076589949429035186767578125}],[" The theorem asserts that 1 and  Positive Infinity (⊤) in the extended non-negative real numbers (ENNReal) are distinct.",{"type":"1 ≠ ⊤","name":"ENNReal.one_ne_top","isProp":true,"docString":" The theorem asserts that 1 and  Positive Infinity (⊤) in the extended non-negative real numbers (ENNReal) are distinct.","distance":0.439165699603832948572090799643774516880512237548828125}],["This theorem from Measure Theory in Mathlib (a library for the Lean Theorem Prover) states that for any two propositions `a` and `b`, the statement \"there exists an instance where `a` is true such that `b` is also true\" is equivalent to the statement \"`a` is true and `b` is true\". This establishes an equivalence between two different ways of expressing a joint assertion in logic.",{"type":"∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)","name":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.10","isProp":true,"docString":"This theorem from Measure Theory in Mathlib (a library for the Lean Theorem Prover) states that for any two propositions `a` and `b`, the statement \"there exists an instance where `a` is true such that `b` is also true\" is equivalent to the statement \"`a` is true and `b` is true\". This establishes an equivalence between two different ways of expressing a joint assertion in logic.","distance":0.425150193953255650658462627689004875719547271728515625}],["The proof that it is the colimit cocone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.ColimitCocone F) → CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.3269484108073144046358038394828327000141143798828125}],["The proof that is the limit cone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.LimitCone F) → CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.32776335648833221370068713440559804439544677734375}],["Proof of right inverse ",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse ","distance":0.328890786834288573192708327042055316269397735595703125}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        [inst_2 : CategoryTheory.IsConnected J] →\n          {B : C} →\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} →\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} →\n                CategoryTheory.Limits.IsLimit c →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.332920677341006443494819677653140388429164886474609375}],["Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` ",{"type":"∀ {n : ℕ}, Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)","name":"Nat.fib_add_two","isProp":true,"docString":"Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` ","distance":0.338888144964426263339163369892048649489879608154296875}],["Proof of left inverse ",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse ","distance":0.342310232824112270488825515712960623204708099365234375}],["Proof of the continuity of the map. ",{"type":"∀ {F : Type u_1} {A : outParam (Type u_7)} {B : outParam (Type u_8)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ⇑f","name":"ContinuousMonoidHomClass.map_continuous","isProp":true,"docString":"Proof of the continuity of the map. ","distance":0.34594209542292464476531677064485847949981689453125}],["Proof of continuity of the Hom. ",{"type":"∀ {A : Type u_2} {B : Type u_3} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun","name":"ContinuousMonoidHom.continuous_toFun","isProp":true,"docString":"Proof of continuity of the Hom. ","distance":0.3470022839626027977288913461961783468723297119140625}],["Compose two proofs by transitivity, generalized over the relations involved. ",{"type":"{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c","name":"Trans.trans","isProp":false,"docString":"Compose two proofs by transitivity, generalized over the relations involved. ","distance":0.3516691566674248203838715198799036443233489990234375}],["Use the above equivalence to prove we have a limit. ",{"type":"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","isProp":true,"docString":"Use the above equivalence to prove we have a limit. ","distance":0.352875423448842873153097343674744479358196258544921875}],["Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. ",{"type":"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))","name":"GeneralizedContinuedFraction.abs_sub_convergents_le","isProp":true,"docString":"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. ","distance":0.353851962936098052292521742856479249894618988037109375}],["Correspondence theorem ",{"type":"{R : Type u} →\n  {S : Type v} →\n    {F : Type u_1} →\n      [inst : Ring R] →\n        [inst_1 : Ring S] →\n          [inst_2 : RingHomClass F R S] → (f : F) → Function.Surjective ⇑f → Ideal S ≃o { p // Ideal.comap f ⊥ ≤ p }","name":"Ideal.relIsoOfSurjective","isProp":false,"docString":"Correspondence theorem ","distance":0.35571308923165301241198221759987063705921173095703125}],["Shows that definability is closed under finite projections. ",{"type":"∀ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {α : Type u₁}\n  {β : Type u_1} {s : Set (β → M)},\n  Set.Definable A L s → ∀ (f : α → β) [inst_1 : Finite α] [inst_2 : Finite β], Set.Definable A L ((fun g => g ∘ f) '' s)","name":"Set.Definable.image_comp","isProp":true,"docString":"Shows that definability is closed under finite projections. ","distance":0.357647304427015699790359803955652751028537750244140625}],["Shows that $e^{x} * e^{-x} = 1$ ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * PowerSeries.evalNegHom (PowerSeries.exp A) = 1","name":"PowerSeries.exp_mul_exp_neg_eq_one","isProp":true,"docString":"Shows that $e^{x} * e^{-x} = 1$ ","distance":0.358128916973850575100613014001282863318920135498046875}],["Proof of type equality as an arrow ",{"type":"{n : ℕ} →\n  (P : MvPFunctor.{u} (n + 1)) →\n    {a a' : P.A} → a = a' → TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) (MvPFunctor.B (MvPFunctor.drop P) a')","name":"MvPFunctor.castDropB","isProp":false,"docString":"Proof of type equality as an arrow ","distance":0.36173231498590452392960514771402813494205474853515625}],["Shows that $(e^{X})^k = e^{kX}$. ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = (PowerSeries.rescale ↑k) (PowerSeries.exp A)","name":"PowerSeries.exp_pow_eq_rescale_exp","isProp":true,"docString":"Shows that $(e^{X})^k = e^{kX}$. ","distance":0.361848011913070977119133431187947280704975128173828125}],["A version of **Matiyasevic's theorem** ",{"type":"∀ {α : Type} {f g : (α → ℕ) → ℕ}, Dioph.DiophFn f → Dioph.DiophFn g → Dioph.DiophFn fun v => f v ^ g v","name":"Dioph.pow_dioph","isProp":true,"docString":"A version of **Matiyasevic's theorem** ","distance":0.363209083568792279184123117374838329851627349853515625}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] →\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] →\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) →\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.36322654477681037832326182979159057140350341796875}]]