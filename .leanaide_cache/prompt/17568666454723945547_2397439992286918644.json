[["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        [inst_2 : CategoryTheory.IsConnected J] ‚Üí\n          {B : C} ‚Üí\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} ‚Üí\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} ‚Üí\n                CategoryTheory.Limits.IsLimit c ‚Üí\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.41289200366522071927732895346707664430141448974609375}],[" In Lean 4, the proposition that infinity (‚ä§) equals zero is false.",{"type":"(‚ä§ = 0) = False","name":"Mathlib.Data.ENNReal.Basic._auxLemma.15","isProp":true,"docString":" In Lean 4, the proposition that infinity (‚ä§) equals zero is false.","distance":0.5195284346491859661654189039836637675762176513671875}],["This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] {A : Set E} {x : E}, x ‚àà Set.exposedPoints ùïú A ‚Üî IsExposed ùïú A {x}","name":"mem_exposedPoints_iff_exposed_singleton","isProp":true,"docString":"This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.","distance":0.4925487751590325036232798083801753818988800048828125}],["Show the equalizing cone is a limit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPullbacks C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerCone F)","name":"CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerConeIsLimit","isProp":false,"docString":"Show the equalizing cone is a limit ","distance":0.421724345480913254124999411942553706467151641845703125}],[" For any point x in a charted space H of a topological space M, the image of x under the chart at x lies in the target set of the chart.",{"type":"‚àÄ (H : Type u) {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  (x : M), ‚Üë(chartAt H x) x ‚àà (chartAt H x).target","name":"mem_chart_target","isProp":true,"docString":" For any point x in a charted space H of a topological space M, the image of x under the chart at x lies in the target set of the chart.","distance":0.521220535338505985833990052924491465091705322265625}],["This theorem states that the sequence of natural numbers, when converted to extended non-negative real numbers (that's what `‚Üën` means), tends to infinity (`nhds ‚ä§`). More formally, for every neighborhood `U` of infinity in the extended non-negative real numbers, there exists a natural number `N` such that for all natural numbers `n` greater than `N`, `n` is an element of `U`. The function `Filter.Tendsto` is used to express this concept of limit in Lean 4. This theorem is usually used when dealing with sequences or functions that grow without bounds in the context of extended real numbers.",{"type":"Filter.Tendsto (fun n => ‚Üën) Filter.atTop (nhds ‚ä§)","name":"ENNReal.tendsto_nat_nhds_top","isProp":true,"docString":"This theorem states that the sequence of natural numbers, when converted to extended non-negative real numbers (that's what `‚Üën` means), tends to infinity (`nhds ‚ä§`). More formally, for every neighborhood `U` of infinity in the extended non-negative real numbers, there exists a natural number `N` such that for all natural numbers `n` greater than `N`, `n` is an element of `U`. The function `Filter.Tendsto` is used to express this concept of limit in Lean 4. This theorem is usually used when dealing with sequences or functions that grow without bounds in the context of extended real numbers.","distance":0.50477380958326756310583505182876251637935638427734375}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.423864080267774834265281924672308377921581268310546875}],["Expand the square ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] (x y : F),\n  ‚Äñx - y‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - 2 * ‚ü™x, y‚ü´_‚Ñù + ‚Äñy‚Äñ ^ 2","name":"norm_sub_sq_real","isProp":true,"docString":"Expand the square ","distance":0.43241624772537912146930239032371900975704193115234375}],["projection expression ",{"type":"Simps.ParsedProjectionData ‚Üí Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.436993141289919007075326362610212527215480804443359375}],["The program. ",{"type":"{Œì : Type u_1} ‚Üí\n  {Œõ : Type u_2} ‚Üí\n    [inst : Inhabited Œõ] ‚Üí Turing.TM0.Machine Œì Œõ ‚Üí Turing.TM0to1.Œõ' ‚Üí Turing.TM1.Stmt Œì Turing.TM0to1.Œõ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.43803075073301778186163346617831848561763763427734375}],["Action of a Shelf",{"type":"Lean.TrailingParserDescr","name":"Quandles.¬´term_‚óÉ_¬ª","isProp":false,"docString":"Action of a Shelf","distance":0.440815608464476316186164694954641163349151611328125}],["Print an ordinal notation ",{"type":"ONote ‚Üí String","name":"ONote.toString","isProp":false,"docString":"Print an ordinal notation ","distance":0.441516925547492500303548013107501901686191558837890625}],["Supremum of a set ",{"type":"{Œ± : Type u_9} ‚Üí [self : SupSet Œ±] ‚Üí Set Œ± ‚Üí Œ±","name":"SupSet.sSup","isProp":false,"docString":"Supremum of a set ","distance":0.444376241696453233576136199189932085573673248291015625}],["A very basic tactic to show that sets showing up in manifolds coincide or are included\nin one another. ",{"type":"Lean.ParserDescr","name":"Tactic.MfldSetTac.mfldSetTac","isProp":false,"docString":"A very basic tactic to show that sets showing up in manifolds coincide or are included\nin one another. ","distance":0.444475046264159734388243805369711481034755706787109375}],["A choice of wide pushout. ",{"type":"{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      (B : C) ‚Üí\n        (objs : J ‚Üí C) ‚Üí\n          (arrows : (j : J) ‚Üí B ‚ü∂ objs j) ‚Üí [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] ‚Üí C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.444759014924130335888463605442666448652744293212890625}],["Name of the presenter to use. ",{"type":"ProofWidgets.GetExprPresentationParams ‚Üí Lean.Name","name":"ProofWidgets.GetExprPresentationParams.name","isProp":false,"docString":"Name of the presenter to use. ","distance":0.445038047422688654020106469033635221421718597412109375}],["Shows that $(e^{X})^k = e^{kX}$. ",{"type":"‚àÄ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ‚Ñö A] (k : ‚Ñï),\n  PowerSeries.exp A ^ k = (PowerSeries.rescale ‚Üëk) (PowerSeries.exp A)","name":"PowerSeries.exp_pow_eq_rescale_exp","isProp":true,"docString":"Shows that $(e^{X})^k = e^{kX}$. ","distance":0.445223787285587591089353054485400207340717315673828125}],["Show that there is a galois insertion (generate, set_over). ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {X : C} ‚Üí GaloisInsertion CategoryTheory.Sieve.generate CategoryTheory.Sieve.arrows","name":"CategoryTheory.Sieve.giGenerate","isProp":false,"docString":"Show that there is a galois insertion (generate, set_over). ","distance":0.44632872435234449692842417789506725966930389404296875}],["The supremum of the principal segment ",{"type":"{Œ± : Type u_4} ‚Üí {Œ≤ : Type u_5} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚â∫i s ‚Üí Œ≤","name":"PrincipalSeg.top","isProp":false,"docString":"The supremum of the principal segment ","distance":0.4471960032102384463570388106745667755603790283203125}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.44725095392497526969322052536881528794765472412109375}],["Shows that the integer parts of the stream are at least one. ",{"type":"‚àÄ {K : Type u_1} {v : K} {n : ‚Ñï} [inst : LinearOrderedField K] [inst_1 : FloorRing K]\n  {ifp_succ_n : GeneralizedContinuedFraction.IntFractPair K},\n  GeneralizedContinuedFraction.IntFractPair.stream v (n + 1) = some ifp_succ_n ‚Üí 1 ‚â§ ifp_succ_n.b","name":"GeneralizedContinuedFraction.IntFractPair.one_le_succ_nth_stream_b","isProp":true,"docString":"Shows that the integer parts of the stream are at least one. ","distance":0.448944352069481855682653304029372520744800567626953125}],["Notation for 0 ",{"type":"Zero ONote","name":"ONote.instZeroONote","isProp":false,"docString":"Notation for 0 ","distance":0.449346992404921652397575826398679055273532867431640625}],["The set of points. ",{"type":"{K : Type u_1} ‚Üí\n  {V : Type u_2} ‚Üí\n    [inst : Field K] ‚Üí\n      [inst_1 : AddCommGroup V] ‚Üí [inst_2 : Module K V] ‚Üí Projectivization.Subspace K V ‚Üí Set (Projectivization K V)","name":"Projectivization.Subspace.carrier","isProp":false,"docString":"The set of points. ","distance":0.4503824158520288722939994840999133884906768798828125}],["A convenient way to show that a binary cofan is a colimit. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí\n      (s : CategoryTheory.Limits.BinaryCofan X Y) ‚Üí\n        (desc : {T : C} ‚Üí (X ‚ü∂ T) ‚Üí (Y ‚ü∂ T) ‚Üí (s.pt ‚ü∂ T)) ‚Üí\n          (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) (desc f g) = f) ‚Üí\n            (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) (desc f g) = g) ‚Üí\n              (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (m : s.pt ‚ü∂ T),\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) m = f ‚Üí\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) m = g ‚Üí m = desc f g) ‚Üí\n                CategoryTheory.Limits.IsColimit s","name":"CategoryTheory.Limits.BinaryCofan.IsColimit.mk","isProp":false,"docString":"A convenient way to show that a binary cofan is a colimit. ","distance":0.450400939676614708861990266086650080978870391845703125}]]