[["The statement to be proved inductively ",{"type":"{F : Type u_1} →\n  [inst : Field F] → {E : Type u_2} → [inst_1 : Field E] → [inst_2 : Algebra F E] → ↥(solvableByRad F E) → Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.398318399420482360806516908269259147346019744873046875}],[" The theorem asserts that 0 < 1 in the set of real numbers.",{"type":"0 < 1","name":"Real.zero_lt_one","isProp":true,"docString":" The theorem asserts that 0 < 1 in the set of real numbers.","distance":0.497075412488934331722845172407687641680240631103515625}],["This theorem states that the number 2 is not equal to infinity. In Lean, \"⊤\" is used to represent infinity, usually in the context of extended non-negative real numbers (where real numbers are extended by adding infinity as a value). The proof, which is not shown here, establishes that 2 cannot be the same as infinity, which is intuitively obvious in the realm of real numbers.",{"type":"(2 = ⊤) = False","name":"Mathlib.Data.ENNReal.Basic._auxLemma.32","isProp":true,"docString":"This theorem states that the number 2 is not equal to infinity. In Lean, \"⊤\" is used to represent infinity, usually in the context of extended non-negative real numbers (where real numbers are extended by adding infinity as a value). The proof, which is not shown here, establishes that 2 cannot be the same as infinity, which is intuitively obvious in the realm of real numbers.","distance":0.4715747172384692209590184575063176453113555908203125}],["The proof that is the limit cone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.LimitCone F) → CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.411424656860171877870158141377032734453678131103515625}],[" The theorem asserts that the negation of False is True. In mathematical notation, ¬False = True.",{"type":"(¬False) = True","name":"Mathlib.Logic.Equiv.Basic._auxLemma.2","isProp":true,"docString":" The theorem asserts that the negation of False is True. In mathematical notation, ¬False = True.","distance":0.497375780877092277254547525444650091230869293212890625}],["This theorem states that for every positive natural number `n`, the value of `n` when coerced to an integer is strictly greater than zero. In other words, when we take any positive natural number and view it as an integer, the result is always a positive integer.",{"type":"∀ (n : ℕ+), 0 < ↑n","name":"PNat.pos","isProp":true,"docString":"This theorem states that for every positive natural number `n`, the value of `n` when coerced to an integer is strictly greater than zero. In other words, when we take any positive natural number and view it as an integer, the result is always a positive integer.","distance":0.472656796770915210714747445308603346347808837890625}],["The proof that it is the colimit cocone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.ColimitCocone F) → CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.414748110636104339032925736319157294929027557373046875}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        [inst_2 : CategoryTheory.IsConnected J] →\n          {B : C} →\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} →\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} →\n                CategoryTheory.Limits.IsLimit c →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.41486403998213738919531579085742123425006866455078125}],["Correspondence theorem ",{"type":"{R : Type u} →\n  {S : Type v} →\n    {F : Type u_1} →\n      [inst : Ring R] →\n        [inst_1 : Ring S] →\n          [inst_2 : RingHomClass F R S] → (f : F) → Function.Surjective ⇑f → Ideal S ≃o { p // Ideal.comap f ⊥ ≤ p }","name":"Ideal.relIsoOfSurjective","isProp":false,"docString":"Correspondence theorem ","distance":0.42313530037048929788312534583383239805698394775390625}],["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J MonCat) → CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.42504506048611856439123357631615363061428070068359375}],["A proof of tm outputting l' when given l. ",{"type":"(tm : Turing.FinTM2) → List (Turing.FinTM2.Γ tm tm.k₀) → Option (List (Turing.FinTM2.Γ tm tm.k₁)) → Type","name":"Turing.TM2Outputs","isProp":false,"docString":"A proof of tm outputting l' when given l. ","distance":0.42585126153332464316036976015311665832996368408203125}],["Proof of right inverse ",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse ","distance":0.429752446573309854205291458129067905247211456298828125}],["Proof of continuity of the Hom. ",{"type":"∀ {A : Type u_2} {B : Type u_3} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun","name":"ContinuousMonoidHom.continuous_toFun","isProp":true,"docString":"Proof of continuity of the Hom. ","distance":0.431778747057800338371436055240337736904621124267578125}],["**Stewart's Theorem**. ",{"type":"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] (a b c p : P),\n  EuclideanGeometry.angle b p c = Real.pi →\n    dist a b ^ 2 * dist c p + dist a c ^ 2 * dist b p = dist b c * (dist a p ^ 2 + dist b p * dist c p)","name":"EuclideanGeometry.dist_sq_mul_dist_add_dist_sq_mul_dist","isProp":true,"docString":"**Stewart's Theorem**. ","distance":0.43879563834891210927224847182515077292919158935546875}],["Proof of the continuity of the map. ",{"type":"∀ {F : Type u_1} {A : outParam (Type u_7)} {B : outParam (Type u_8)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ⇑f","name":"ContinuousMonoidHomClass.map_continuous","isProp":true,"docString":"Proof of the continuity of the map. ","distance":0.439167691619993416640710393039626069366931915283203125}],["Compose two proofs by transitivity, generalized over the relations involved. ",{"type":"{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c","name":"Trans.trans","isProp":false,"docString":"Compose two proofs by transitivity, generalized over the relations involved. ","distance":0.442977885566012974383198752548196353018283843994140625}],["Shows that $(e^{X})^k = e^{kX}$. ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = (PowerSeries.rescale ↑k) (PowerSeries.exp A)","name":"PowerSeries.exp_pow_eq_rescale_exp","isProp":true,"docString":"Shows that $(e^{X})^k = e^{kX}$. ","distance":0.444126495799971154898599934313097037374973297119140625}],["A version of **Matiyasevic's theorem** ",{"type":"∀ {α : Type} {f g : (α → ℕ) → ℕ}, Dioph.DiophFn f → Dioph.DiophFn g → Dioph.DiophFn fun v => f v ^ g v","name":"Dioph.pow_dioph","isProp":true,"docString":"A version of **Matiyasevic's theorem** ","distance":0.444712562688623080919825270029832608997821807861328125}],["Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑k ^ p * (algebraMap ℚ A) (↑(Nat.factorial p))⁻¹","name":"PowerSeries.exp_pow_sum","isProp":true,"docString":"Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. ","distance":0.44523493821060589059612766504869796335697174072265625}],["The sum of two thunks. ",{"type":"{α : Type u_1} → [inst : Add α] → Thunk α → Thunk α → Thunk α","name":"Thunk.add","isProp":false,"docString":"The sum of two thunks. ","distance":0.44572543249707141654880615533329546451568603515625}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] →\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] →\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) →\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.445952399874434635140829641386517323553562164306640625}],["Proof of left inverse ",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse ","distance":0.445967593495579295304054312509833835065364837646484375}],["(Impl) Prove that the lifted cone is limiting. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T : CategoryTheory.Monad C} →\n      {J : Type u} →\n        [inst_1 : CategoryTheory.Category.{v, u} J] →\n          (D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)) →\n            (c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) →\n              (t : CategoryTheory.Limits.IsLimit c) →\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Monad.ForgetCreatesLimits.liftedCone D c t)","name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedConeIsLimit","isProp":false,"docString":"(Impl) Prove that the lifted cone is limiting. ","distance":0.45155216091560512747804523314698599278926849365234375}],["Engel's theorem. ",{"type":"∀ {R : Type u₁} {L : Type u₂} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsNilpotent R L ↔ ∀ (x : L), IsNilpotent ((LieAlgebra.ad R L) x)","name":"LieAlgebra.isNilpotent_iff_forall","isProp":true,"docString":"Engel's theorem. ","distance":0.452615959091476505182782830161158926784992218017578125}]]