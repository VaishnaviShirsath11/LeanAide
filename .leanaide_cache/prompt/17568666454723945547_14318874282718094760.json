[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.369066922585794821021210054823313839733600616455078125}],[" For all natural numbers n, n < n + 1.",{"type":"∀ (n : ℕ), n < n.succ","name":"Nat.lt.base","isProp":true,"docString":" For all natural numbers n, n < n + 1.","distance":0.495108018138805505703459175492753274738788604736328125}],["This theorem states that, given a neighborhood `s` of the origin in a normed space `E` over a non-trivially normed field `𝕜`, all elements of the polar of `s` are bounded with respect to the ambient bornology. In other words, the dual norms of all functionals in the polar subset of `s` (i.e. those functionals which evaluate to something of norm at most one at all points `z` in `s`) are bounded by a constant. That is to say, there exists a real number such that the dual norm of any functional in the polar subset of `s` is less than or equal to this constant.",{"type":"∀ (𝕜 : Type u_1) [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {s : Set E}, s ∈ nhds 0 → Bornology.IsBounded (NormedSpace.polar 𝕜 s)","name":"NormedSpace.isBounded_polar_of_mem_nhds_zero","isProp":true,"docString":"This theorem states that, given a neighborhood `s` of the origin in a normed space `E` over a non-trivially normed field `𝕜`, all elements of the polar of `s` are bounded with respect to the ambient bornology. In other words, the dual norms of all functionals in the polar subset of `s` (i.e. those functionals which evaluate to something of norm at most one at all points `z` in `s`) are bounded by a constant. That is to say, there exists a real number such that the dual norm of any functional in the polar subset of `s` is less than or equal to this constant.","distance":0.50757551715511894929733216486056335270404815673828125}],["Continuity ",{"type":"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {σ : outParam (R →+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M₂ : outParam (Type u_5)} [inst_4 : TopologicalSpace M₂] [inst_5 : AddCommMonoid M₂] [inst_6 : Module R M]\n  [inst_7 : Module S M₂] [self : ContinuousSemilinearMapClass F σ M M₂] (f : F), Continuous ⇑f","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity ","distance":0.388351583753045181968133192640380002558231353759765625}],[" For all natural numbers n, n ≤ n.",{"type":"∀ (n : ℕ), n ≤ n","name":"Nat.le_refl","isProp":true,"docString":" For all natural numbers n, n ≤ n.","distance":0.496621995747431876910837900140904821455478668212890625}],["This theorem states that the logical negation of true, denoted as '!true' in Lean 4, is equal to false. In other words, if we negate or reverse the boolean value 'true', we obtain 'false'.",{"type":"(!true) = false","name":"Bool.not_true","isProp":true,"docString":"This theorem states that the logical negation of true, denoted as '!true' in Lean 4, is equal to false. In other words, if we negate or reverse the boolean value 'true', we obtain 'false'.","distance":0.51073866691626523817149063688702881336212158203125}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.39757942931604450809146555911866016685962677001953125}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.4028053560583588765808826792635954916477203369140625}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.405141872758707111135123568601557053625583648681640625}],["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.406658747759715499814348049767431803047657012939453125}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.406753271265003546464100736557156778872013092041015625}],["an object in the source category ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} →\n          {X : C} →\n            {S : CategoryTheory.Presieve X} →\n              {Y : D} → {f : Y ⟶ F.obj X} → CategoryTheory.Presieve.FunctorPushforwardStructure F S f → C","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.preobj","isProp":false,"docString":"an object in the source category ","distance":0.40683739915198657843831142599810846149921417236328125}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.407199626387071578204057686889427714049816131591796875}],["the category structure. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W : CategoryTheory.MorphismProperty C} →\n      [self : CategoryTheory.MorphismProperty.HasLocalization W] →\n        CategoryTheory.Category.{w, u} (CategoryTheory.MorphismProperty.HasLocalization.D W)","name":"CategoryTheory.MorphismProperty.HasLocalization.hD","isProp":false,"docString":"the category structure. ","distance":0.40773395408725610078448653439409099519252777099609375}],["the second row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₂","isProp":false,"docString":"the second row ","distance":0.409771771780738924828568769953562878072261810302734375}],["Category of categories. ",{"type":"Type (max (u + 1) u (v + 1))","name":"CategoryTheory.Cat","isProp":false,"docString":"Category of categories. ","distance":0.40997092904923493339452988948323763906955718994140625}],["compatibility condition ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {F : CategoryTheory.Functor C C}\n  {A₀ A₁ : CategoryTheory.Endofunctor.Algebra F} (self : CategoryTheory.Endofunctor.Algebra.Hom A₀ A₁),\n  CategoryTheory.CategoryStruct.comp (F.map self.f) A₁.str = CategoryTheory.CategoryStruct.comp A₀.str self.f","name":"CategoryTheory.Endofunctor.Algebra.Hom.h","isProp":true,"docString":"compatibility condition ","distance":0.411240033629541257287343114512623287737369537353515625}],["The composition of relations ",{"type":"{α : Type ua} → Set (α × α) → Set (α × α) → Set (α × α)","name":"compRel","isProp":false,"docString":"The composition of relations ","distance":0.412090817238169204728137628990225493907928466796875}],["compatibility with the composition ",{"type":"∀ {c : Type u → Type u} {hom : ⦃α β : Type u⦄ → c α → c β → Type u} (self : CategoryTheory.BundledHom hom)\n  {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n  CategoryTheory.BundledHom.toFun self Iα Iγ (CategoryTheory.BundledHom.comp self Iα Iβ Iγ g f) =\n    CategoryTheory.BundledHom.toFun self Iβ Iγ g ∘ CategoryTheory.BundledHom.toFun self Iα Iβ f","name":"CategoryTheory.BundledHom.comp_toFun","isProp":true,"docString":"compatibility with the composition ","distance":0.412294047108426209291565101011656224727630615234375}],["The empty weak sequence ",{"type":"{α : Type u} → Stream'.WSeq α","name":"Stream'.WSeq.nil","isProp":false,"docString":"The empty weak sequence ","distance":0.412731724366384000735052950403769500553607940673828125}],["the third row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₃","isProp":false,"docString":"the third row ","distance":0.41362770161574058391806829604320228099822998046875}],["verschiebung is a natural transformation ",{"type":"∀ {p : ℕ} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [inst : CommRing R] [inst_1 : CommRing S]\n  (f : R →+* S) (x : WittVector p R),\n  (WittVector.map f) (WittVector.verschiebung x) = WittVector.verschiebung ((WittVector.map f) x)","name":"WittVector.map_verschiebung","isProp":true,"docString":"verschiebung is a natural transformation ","distance":0.413686524944974320927570943240425549447536468505859375}],["The relation itself. ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.CategoryStruct.comp self.g₁ self.f₁ = CategoryTheory.CategoryStruct.comp self.g₂ self.f₂","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.w","isProp":true,"docString":"The relation itself. ","distance":0.4139342783046853213591020903550088405609130859375}],["A collection of comparisons. ",{"type":"Type","name":"Linarith.PCompSet","isProp":false,"docString":"A collection of comparisons. ","distance":0.414647420973494218454646897953352890908718109130859375}]]