[["an arrow ",{"type":"{V : Type u} â†’ [inst : Quiver V] â†’ (self : Quiver.Total V) â†’ self.left âŸ¶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.369066922585794821021210054823313839733600616455078125}],[" For all natural numbers n, n < n + 1.",{"type":"âˆ€ (n : â„•), n < n.succ","name":"Nat.lt.base","isProp":true,"docString":" For all natural numbers n, n < n + 1.","distance":0.495108018138805505703459175492753274738788604736328125}],["This theorem states that, given a neighborhood `s` of the origin in a normed space `E` over a non-trivially normed field `ð•œ`, all elements of the polar of `s` are bounded with respect to the ambient bornology. In other words, the dual norms of all functionals in the polar subset of `s` (i.e. those functionals which evaluate to something of norm at most one at all points `z` in `s`) are bounded by a constant. That is to say, there exists a real number such that the dual norm of any functional in the polar subset of `s` is less than or equal to this constant.",{"type":"âˆ€ (ð•œ : Type u_1) [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {s : Set E}, s âˆˆ nhds 0 â†’ Bornology.IsBounded (NormedSpace.polar ð•œ s)","name":"NormedSpace.isBounded_polar_of_mem_nhds_zero","isProp":true,"docString":"This theorem states that, given a neighborhood `s` of the origin in a normed space `E` over a non-trivially normed field `ð•œ`, all elements of the polar of `s` are bounded with respect to the ambient bornology. In other words, the dual norms of all functionals in the polar subset of `s` (i.e. those functionals which evaluate to something of norm at most one at all points `z` in `s`) are bounded by a constant. That is to say, there exists a real number such that the dual norm of any functional in the polar subset of `s` is less than or equal to this constant.","distance":0.50757551715511894929733216486056335270404815673828125}],["Continuity ",{"type":"âˆ€ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {Ïƒ : outParam (R â†’+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {Mâ‚‚ : outParam (Type u_5)} [inst_4 : TopologicalSpace Mâ‚‚] [inst_5 : AddCommMonoid Mâ‚‚] [inst_6 : Module R M]\n  [inst_7 : Module S Mâ‚‚] [self : ContinuousSemilinearMapClass F Ïƒ M Mâ‚‚] (f : F), Continuous â‡‘f","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity ","distance":0.388351583753045181968133192640380002558231353759765625}],[" For all natural numbers n, n â‰¤ n.",{"type":"âˆ€ (n : â„•), n â‰¤ n","name":"Nat.le_refl","isProp":true,"docString":" For all natural numbers n, n â‰¤ n.","distance":0.496621995747431876910837900140904821455478668212890625}],["This theorem states that the logical negation of true, denoted as '!true' in Lean 4, is equal to false. In other words, if we negate or reverse the boolean value 'true', we obtain 'false'.",{"type":"(!true) = false","name":"Bool.not_true","isProp":true,"docString":"This theorem states that the logical negation of true, denoted as '!true' in Lean 4, is equal to false. In other words, if we negate or reverse the boolean value 'true', we obtain 'false'.","distance":0.51073866691626523817149063688702881336212158203125}],["projection expression ",{"type":"Simps.ParsedProjectionData â†’ Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.39757942931604450809146555911866016685962677001953125}],["The empty finset ",{"type":"{Î± : Type u_1} â†’ Finset Î±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.4028053560583588765808826792635954916477203369140625}],["tensorator ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’\n        [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            {F : C â†’ D} â†’\n              [inst_4 : CategoryTheory.Functorial F] â†’\n                [self : CategoryTheory.LaxMonoidal F] â†’\n                  (X Y : C) â†’\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) âŸ¶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.Î¼","isProp":false,"docString":"tensorator ","distance":0.405141872758707111135123568601557053625583648681640625}],["The program. ",{"type":"{Î“ : Type u_1} â†’\n  {Î› : Type u_2} â†’\n    [inst : Inhabited Î›] â†’ Turing.TM0.Machine Î“ Î› â†’ Turing.TM0to1.Î›' â†’ Turing.TM1.Stmt Î“ Turing.TM0to1.Î›' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.406658747759715499814348049767431803047657012939453125}],["The empty word ",{"type":"{G : Type u_1} â†’\n  [inst : Group G] â†’\n    {A B : Subgroup G} â†’ {d : HNNExtension.NormalWord.TransversalPair G A B} â†’ HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.406753271265003546464100736557156778872013092041015625}],["an object in the source category ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        {F : CategoryTheory.Functor C D} â†’\n          {X : C} â†’\n            {S : CategoryTheory.Presieve X} â†’\n              {Y : D} â†’ {f : Y âŸ¶ F.obj X} â†’ CategoryTheory.Presieve.FunctorPushforwardStructure F S f â†’ C","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.preobj","isProp":false,"docString":"an object in the source category ","distance":0.40683739915198657843831142599810846149921417236328125}],["the first row ",{"type":"{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    [inst_1 : CategoryTheory.Abelian C] â†’ CategoryTheory.ShortComplex.SnakeInput C â†’ CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.Lâ‚","isProp":false,"docString":"the first row ","distance":0.407199626387071578204057686889427714049816131591796875}],["the category structure. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {W : CategoryTheory.MorphismProperty C} â†’\n      [self : CategoryTheory.MorphismProperty.HasLocalization W] â†’\n        CategoryTheory.Category.{w, u} (CategoryTheory.MorphismProperty.HasLocalization.D W)","name":"CategoryTheory.MorphismProperty.HasLocalization.hD","isProp":false,"docString":"the category structure. ","distance":0.40773395408725610078448653439409099519252777099609375}],["the second row ",{"type":"{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    [inst_1 : CategoryTheory.Abelian C] â†’ CategoryTheory.ShortComplex.SnakeInput C â†’ CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.Lâ‚‚","isProp":false,"docString":"the second row ","distance":0.409771771780738924828568769953562878072261810302734375}],["Category of categories. ",{"type":"Type (max (u + 1) u (v + 1))","name":"CategoryTheory.Cat","isProp":false,"docString":"Category of categories. ","distance":0.40997092904923493339452988948323763906955718994140625}],["compatibility condition ",{"type":"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {F : CategoryTheory.Functor C C}\n  {Aâ‚€ Aâ‚ : CategoryTheory.Endofunctor.Algebra F} (self : CategoryTheory.Endofunctor.Algebra.Hom Aâ‚€ Aâ‚),\n  CategoryTheory.CategoryStruct.comp (F.map self.f) Aâ‚.str = CategoryTheory.CategoryStruct.comp Aâ‚€.str self.f","name":"CategoryTheory.Endofunctor.Algebra.Hom.h","isProp":true,"docString":"compatibility condition ","distance":0.411240033629541257287343114512623287737369537353515625}],["The composition of relations ",{"type":"{Î± : Type ua} â†’ Set (Î± Ã— Î±) â†’ Set (Î± Ã— Î±) â†’ Set (Î± Ã— Î±)","name":"compRel","isProp":false,"docString":"The composition of relations ","distance":0.412090817238169204728137628990225493907928466796875}],["compatibility with the composition ",{"type":"âˆ€ {c : Type u â†’ Type u} {hom : â¦ƒÎ± Î² : Type uâ¦„ â†’ c Î± â†’ c Î² â†’ Type u} (self : CategoryTheory.BundledHom hom)\n  {Î± Î² Î³ : Type u} (IÎ± : c Î±) (IÎ² : c Î²) (IÎ³ : c Î³) (f : hom IÎ± IÎ²) (g : hom IÎ² IÎ³),\n  CategoryTheory.BundledHom.toFun self IÎ± IÎ³ (CategoryTheory.BundledHom.comp self IÎ± IÎ² IÎ³ g f) =\n    CategoryTheory.BundledHom.toFun self IÎ² IÎ³ g âˆ˜ CategoryTheory.BundledHom.toFun self IÎ± IÎ² f","name":"CategoryTheory.BundledHom.comp_toFun","isProp":true,"docString":"compatibility with the composition ","distance":0.412294047108426209291565101011656224727630615234375}],["The empty weak sequence ",{"type":"{Î± : Type u} â†’ Stream'.WSeq Î±","name":"Stream'.WSeq.nil","isProp":false,"docString":"The empty weak sequence ","distance":0.412731724366384000735052950403769500553607940673828125}],["the third row ",{"type":"{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    [inst_1 : CategoryTheory.Abelian C] â†’ CategoryTheory.ShortComplex.SnakeInput C â†’ CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.Lâ‚ƒ","isProp":false,"docString":"the third row ","distance":0.41362770161574058391806829604320228099822998046875}],["verschiebung is a natural transformation ",{"type":"âˆ€ {p : â„•} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [inst : CommRing R] [inst_1 : CommRing S]\n  (f : R â†’+* S) (x : WittVector p R),\n  (WittVector.map f) (WittVector.verschiebung x) = WittVector.verschiebung ((WittVector.map f) x)","name":"WittVector.map_verschiebung","isProp":true,"docString":"verschiebung is a natural transformation ","distance":0.413686524944974320927570943240425549447536468505859375}],["The relation itself. ",{"type":"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.CategoryStruct.comp self.gâ‚ self.fâ‚ = CategoryTheory.CategoryStruct.comp self.gâ‚‚ self.fâ‚‚","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.w","isProp":true,"docString":"The relation itself. ","distance":0.4139342783046853213591020903550088405609130859375}],["A collection of comparisons. ",{"type":"Type","name":"Linarith.PCompSet","isProp":false,"docString":"A collection of comparisons. ","distance":0.414647420973494218454646897953352890908718109130859375}]]