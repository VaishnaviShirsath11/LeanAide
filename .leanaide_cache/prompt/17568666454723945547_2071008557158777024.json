[["The statement to be proved inductively ",{"type":"{F : Type u_1} â†’\n  [inst : Field F] â†’ {E : Type u_2} â†’ [inst_1 : Field E] â†’ [inst_2 : Algebra F E] â†’ â†¥(solvableByRad F E) â†’ Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.286408952520357418247698433333425782620906829833984375}],[" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.",{"type":"âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {p : Finset (Finset Î±) â†’ Prop} (ð’œ : Finset (Finset Î±)),\n  p âˆ… â†’\n    p {âˆ…} â†’\n      (âˆ€ (a : Î±) â¦ƒð’œ : Finset (Finset Î±)â¦„, (âˆ€ s âˆˆ ð’œ, a âˆ‰ s) â†’ p ð’œ â†’ p (Finset.image (insert a) ð’œ)) â†’\n        (âˆ€ (a : Î±) â¦ƒð’œ : Finset (Finset Î±)â¦„,\n            p (Finset.filter (fun x => a âˆ‰ x) ð’œ) â†’ p (Finset.filter (fun x => a âˆˆ x) ð’œ) â†’ p ð’œ) â†’\n          p ð’œ","name":"Finset.family_induction_on","isProp":true,"docString":" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.","distance":0.416431008351586362525864615236059762537479400634765625}],["This theorem states that the number 2 is not equal to infinity. In Lean, \"âŠ¤\" is used to represent infinity, usually in the context of extended non-negative real numbers (where real numbers are extended by adding infinity as a value). The proof, which is not shown here, establishes that 2 cannot be the same as infinity, which is intuitively obvious in the realm of real numbers.",{"type":"(2 = âŠ¤) = False","name":"Mathlib.Data.ENNReal.Basic._auxLemma.32","isProp":true,"docString":"This theorem states that the number 2 is not equal to infinity. In Lean, \"âŠ¤\" is used to represent infinity, usually in the context of extended non-negative real numbers (where real numbers are extended by adding infinity as a value). The proof, which is not shown here, establishes that 2 cannot be the same as infinity, which is intuitively obvious in the realm of real numbers.","distance":0.400160187506628073350611884961836040019989013671875}],["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} â†’\n  [inst : CategoryTheory.SmallCategory J] â†’\n    (F : CategoryTheory.Functor J MonCat) â†’ CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.29832023037730592829319675729493610560894012451171875}],[" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.",{"type":"âˆ€ {R : Type u} {Ïƒ : Type u_1} [inst : CommSemiring R] {P : MvPolynomial Ïƒ R â†’ Prop} (p : MvPolynomial Ïƒ R),\n  (âˆ€ (u : Ïƒ â†’â‚€ â„•) (a : R), P ((MvPolynomial.monomial u) a)) â†’ (âˆ€ (p q : MvPolynomial Ïƒ R), P p â†’ P q â†’ P (p + q)) â†’ P p","name":"MvPolynomial.induction_on'","isProp":true,"docString":" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.","distance":0.416781277400161964674651926543447189033031463623046875}],["This theorem from Measure Theory in Mathlib (a library for the Lean Theorem Prover) states that for any two propositions `a` and `b`, the statement \"there exists an instance where `a` is true such that `b` is also true\" is equivalent to the statement \"`a` is true and `b` is true\". This establishes an equivalence between two different ways of expressing a joint assertion in logic.",{"type":"âˆ€ {b a : Prop}, (âˆƒ (_ : a), b) = (a âˆ§ b)","name":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.10","isProp":true,"docString":"This theorem from Measure Theory in Mathlib (a library for the Lean Theorem Prover) states that for any two propositions `a` and `b`, the statement \"there exists an instance where `a` is true such that `b` is also true\" is equivalent to the statement \"`a` is true and `b` is true\". This establishes an equivalence between two different ways of expressing a joint assertion in logic.","distance":0.40156471740262833503010142521816305816173553466796875}],["The proof that is the limit cone ",{"type":"{J : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} J] â†’\n    {C : Type u} â†’\n      [inst_1 : CategoryTheory.Category.{v, u} C] â†’\n        {F : CategoryTheory.Functor J C} â†’\n          (self : CategoryTheory.Limits.LimitCone F) â†’ CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.299035764829897410255199474704568274319171905517578125}],["The proof that it is the colimit cocone ",{"type":"{J : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} J] â†’\n    {C : Type u} â†’\n      [inst_1 : CategoryTheory.Category.{v, u} C] â†’\n        {F : CategoryTheory.Functor J C} â†’\n          (self : CategoryTheory.Limits.ColimitCocone F) â†’ CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.30374515722843986598178389613167382776737213134765625}],["Proof of right inverse ",{"type":"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse ","distance":0.307380077473629442774694098261534236371517181396484375}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} â†’\n  [inst : CategoryTheory.SmallCategory J] â†’\n    {C : Type u} â†’\n      [inst_1 : CategoryTheory.Category.{v, u} C] â†’\n        [inst_2 : CategoryTheory.IsConnected J] â†’\n          {B : C} â†’\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} â†’\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} â†’\n                CategoryTheory.Limits.IsLimit c â†’\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.310525211572116599523241120550665073096752166748046875}],["Compose two proofs by transitivity, generalized over the relations involved. ",{"type":"{Î± : Sort u_1} â†’\n  {Î² : Sort u_2} â†’\n    {Î³ : Sort u_3} â†’\n      {r : Î± â†’ Î² â†’ Sort u} â†’\n        {s : Î² â†’ Î³ â†’ Sort v} â†’\n          {t : outParam (Î± â†’ Î³ â†’ Sort w)} â†’ [self : Trans r s t] â†’ {a : Î±} â†’ {b : Î²} â†’ {c : Î³} â†’ r a b â†’ s b c â†’ t a c","name":"Trans.trans","isProp":false,"docString":"Compose two proofs by transitivity, generalized over the relations involved. ","distance":0.32289987926011709529205973012722097337245941162109375}],["Proof of left inverse ",{"type":"âˆ€ {Î± : Type u} [self : Rack Î±] (x : Î±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse ","distance":0.323719104131143409208704042612225748598575592041015625}],["Proof of the continuity of the map. ",{"type":"âˆ€ {F : Type u_1} {A : outParam (Type u_7)} {B : outParam (Type u_8)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous â‡‘f","name":"ContinuousMonoidHomClass.map_continuous","isProp":true,"docString":"Proof of the continuity of the map. ","distance":0.327225195274756630592349893049686215817928314208984375}],["Shows that `fib` indeed satisfies the Fibonacci recurrence `Fâ‚™â‚Šâ‚‚ = Fâ‚™ + Fâ‚™â‚Šâ‚.` ",{"type":"âˆ€ {n : â„•}, Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)","name":"Nat.fib_add_two","isProp":true,"docString":"Shows that `fib` indeed satisfies the Fibonacci recurrence `Fâ‚™â‚Šâ‚‚ = Fâ‚™ + Fâ‚™â‚Šâ‚.` ","distance":0.329702458387711228038341459978255443274974822998046875}],["Proof of type equality as an arrow ",{"type":"{n : â„•} â†’\n  (P : MvPFunctor.{u} (n + 1)) â†’\n    {a a' : P.A} â†’ a = a' â†’ TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) (MvPFunctor.B (MvPFunctor.drop P) a')","name":"MvPFunctor.castDropB","isProp":false,"docString":"Proof of type equality as an arrow ","distance":0.33143930602574267485493919593864120543003082275390625}],["Proof of continuity of the Hom. ",{"type":"âˆ€ {A : Type u_2} {B : Type u_3} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun","name":"ContinuousMonoidHom.continuous_toFun","isProp":true,"docString":"Proof of continuity of the Hom. ","distance":0.3315064254857225112260721289203502237796783447265625}],["Correspondence theorem ",{"type":"{R : Type u} â†’\n  {S : Type v} â†’\n    {F : Type u_1} â†’\n      [inst : Ring R] â†’\n        [inst_1 : Ring S] â†’\n          [inst_2 : RingHomClass F R S] â†’ (f : F) â†’ Function.Surjective â‡‘f â†’ Ideal S â‰ƒo { p // Ideal.comap f âŠ¥ â‰¤ p }","name":"Ideal.relIsoOfSurjective","isProp":false,"docString":"Correspondence theorem ","distance":0.335493599654685892286209991652867756783962249755859375}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] â†’\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] â†’\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) â†’\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.33854879586821606807234275038354098796844482421875}],["Use the above equivalence to prove we have a limit. ",{"type":"âˆ€ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","isProp":true,"docString":"Use the above equivalence to prove we have a limit. ","distance":0.340875618044433059683484543711529113352298736572265625}],["Shows that definability is closed under finite projections. ",{"type":"âˆ€ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Î± : Type uâ‚}\n  {Î² : Type u_1} {s : Set (Î² â†’ M)},\n  Set.Definable A L s â†’ âˆ€ (f : Î± â†’ Î²) [inst_1 : Finite Î±] [inst_2 : Finite Î²], Set.Definable A L ((fun g => g âˆ˜ f) '' s)","name":"Set.Definable.image_comp","isProp":true,"docString":"Shows that definability is closed under finite projections. ","distance":0.342445622243701064402188194435439072549343109130859375}],["Shows that all denominators are nonnegative. ",{"type":"âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 â‰¤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n","name":"GeneralizedContinuedFraction.zero_le_of_denom","isProp":true,"docString":"Shows that all denominators are nonnegative. ","distance":0.34273167444014374094507502377382479608058929443359375}],["A convenient way to show that a binary cofan is a colimit. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’\n      (s : CategoryTheory.Limits.BinaryCofan X Y) â†’\n        (desc : {T : C} â†’ (X âŸ¶ T) â†’ (Y âŸ¶ T) â†’ (s.pt âŸ¶ T)) â†’\n          (âˆ€ {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T),\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) (desc f g) = f) â†’\n            (âˆ€ {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T),\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) (desc f g) = g) â†’\n              (âˆ€ {T : C} (f : X âŸ¶ T) (g : Y âŸ¶ T) (m : s.pt âŸ¶ T),\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) m = f â†’\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) m = g â†’ m = desc f g) â†’\n                CategoryTheory.Limits.IsColimit s","name":"CategoryTheory.Limits.BinaryCofan.IsColimit.mk","isProp":false,"docString":"A convenient way to show that a binary cofan is a colimit. ","distance":0.342849313932918342562317093324963934719562530517578125}],["Shows that $e^{x} * e^{-x} = 1$ ",{"type":"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A],\n  PowerSeries.exp A * PowerSeries.evalNegHom (PowerSeries.exp A) = 1","name":"PowerSeries.exp_mul_exp_neg_eq_one","isProp":true,"docString":"Shows that $e^{x} * e^{-x} = 1$ ","distance":0.343185434735752414869836002253578044474124908447265625}],["Shows that $(e^{X})^k = e^{kX}$. ",{"type":"âˆ€ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra â„š A] (k : â„•),\n  PowerSeries.exp A ^ k = (PowerSeries.rescale â†‘k) (PowerSeries.exp A)","name":"PowerSeries.exp_pow_eq_rescale_exp","isProp":true,"docString":"Shows that $(e^{X})^k = e^{kX}$. ","distance":0.3461191039438791250404392485506832599639892578125}]]