[["The statement to be proved inductively ",{"type":"{F : Type u_1} →\n  [inst : Field F] → {E : Type u_2} → [inst_1 : Field E] → [inst_2 : Algebra F E] → ↥(solvableByRad F E) → Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.319768374751883743822844508031266741454601287841796875}],[" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.",{"type":"∀ {α : Type u_1} [inst : DecidableEq α] {p : Finset (Finset α) → Prop} (𝒜 : Finset (Finset α)),\n  p ∅ →\n    p {∅} →\n      (∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄, (∀ s ∈ 𝒜, a ∉ s) → p 𝒜 → p (Finset.image (insert a) 𝒜)) →\n        (∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄,\n            p (Finset.filter (fun x => a ∉ x) 𝒜) → p (Finset.filter (fun x => a ∈ x) 𝒜) → p 𝒜) →\n          p 𝒜","name":"Finset.family_induction_on","isProp":true,"docString":" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.","distance":0.443525922801293492891971936842310242354869842529296875}],["This theorem states that, for any two propositions `a` and `b`, the existence of a proof of `b` given a proof of `a` is equivalent to the conjunction of `a` and `b`. In other words, there exists a proof of `b` under the assumption that `a` is true if and only if both `a` and `b` are true.",{"type":"∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x","name":"Mathlib.Data.Finset.Basic._auxLemma.144","isProp":true,"docString":"This theorem states that, for any two propositions `a` and `b`, the existence of a proof of `b` given a proof of `a` is equivalent to the conjunction of `a` and `b`. In other words, there exists a proof of `b` under the assumption that `a` is true if and only if both `a` and `b` are true.","distance":0.4061067110763916243598714572726748883724212646484375}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        [inst_2 : CategoryTheory.IsConnected J] →\n          {B : C} →\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} →\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} →\n                CategoryTheory.Limits.IsLimit c →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.33502941090893012532347938758903183043003082275390625}],[" The theorem states that to prove a statement for every family of finite sets, it suffices to verify it for the empty family, the family containing only the empty set, and the family obtained by adding an element to a family, under the assumption that the statement holds for the subfamilies of sets not containing that element.",{"type":"∀ {α : Type u_1} [inst : DecidableEq α] {p : Finset (Finset α) → Prop} (𝒜 : Finset (Finset α)),\n  p ∅ →\n    p {∅} →\n      (∀ (a : α) ⦃𝒜 : Finset (Finset α)⦄, p (Finset.nonMemberSubfamily a 𝒜) → p (Finset.memberSubfamily a 𝒜) → p 𝒜) →\n        p 𝒜","name":"Finset.memberFamily_induction_on","isProp":true,"docString":" The theorem states that to prove a statement for every family of finite sets, it suffices to verify it for the empty family, the family containing only the empty set, and the family obtained by adding an element to a family, under the assumption that the statement holds for the subfamilies of sets not containing that element.","distance":0.4570093431306354592180696272407658398151397705078125}],["This theorem from Measure Theory in Mathlib (a library for the Lean Theorem Prover) states that for any two propositions `a` and `b`, the statement \"there exists an instance where `a` is true such that `b` is also true\" is equivalent to the statement \"`a` is true and `b` is true\". This establishes an equivalence between two different ways of expressing a joint assertion in logic.",{"type":"∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)","name":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.10","isProp":true,"docString":"This theorem from Measure Theory in Mathlib (a library for the Lean Theorem Prover) states that for any two propositions `a` and `b`, the statement \"there exists an instance where `a` is true such that `b` is also true\" is equivalent to the statement \"`a` is true and `b` is true\". This establishes an equivalence between two different ways of expressing a joint assertion in logic.","distance":0.40921320134061434092842546306201256811618804931640625}],["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J MonCat) → CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.335770539023004410683626019817893393337726593017578125}],["The proof that is the limit cone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.LimitCone F) → CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.339501647437290665632048103361739777028560638427734375}],["The proof that it is the colimit cocone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.ColimitCocone F) → CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.350187947404981991805783536619856022298336029052734375}],["Compose two proofs by transitivity, generalized over the relations involved. ",{"type":"{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c","name":"Trans.trans","isProp":false,"docString":"Compose two proofs by transitivity, generalized over the relations involved. ","distance":0.3536644792590959429645636191708035767078399658203125}],["(Impl) Prove that the lifted cone is limiting. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T : CategoryTheory.Monad C} →\n      {J : Type u} →\n        [inst_1 : CategoryTheory.Category.{v, u} J] →\n          (D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)) →\n            (c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) →\n              (t : CategoryTheory.Limits.IsLimit c) →\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Monad.ForgetCreatesLimits.liftedCone D c t)","name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedConeIsLimit","isProp":false,"docString":"(Impl) Prove that the lifted cone is limiting. ","distance":0.370110681789864892632380133363767527043819427490234375}],["Proof of right inverse ",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse ","distance":0.370552405542809826233252579186228103935718536376953125}],["Proof of the continuity of the map. ",{"type":"∀ {F : Type u_1} {A : outParam (Type u_7)} {B : outParam (Type u_8)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ⇑f","name":"ContinuousMonoidHomClass.map_continuous","isProp":true,"docString":"Proof of the continuity of the map. ","distance":0.372208812211782757994882331331609748303890228271484375}],["Shows that $(e^{X})^k = e^{kX}$. ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = (PowerSeries.rescale ↑k) (PowerSeries.exp A)","name":"PowerSeries.exp_pow_eq_rescale_exp","isProp":true,"docString":"Shows that $(e^{X})^k = e^{kX}$. ","distance":0.37368152022884071339348110996070317924022674560546875}],["Shows that definability is closed under finite projections. ",{"type":"∀ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {α : Type u₁}\n  {β : Type u_1} {s : Set (β → M)},\n  Set.Definable A L s → ∀ (f : α → β) [inst_1 : Finite α] [inst_2 : Finite β], Set.Definable A L ((fun g => g ∘ f) '' s)","name":"Set.Definable.image_comp","isProp":true,"docString":"Shows that definability is closed under finite projections. ","distance":0.379381427299408768849531270461739040911197662353515625}],["(Impl) Prove that the lifted cocone is colimiting. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T : CategoryTheory.Monad C} →\n      {J : Type u} →\n        [inst_1 : CategoryTheory.Category.{v, u} J] →\n          {D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)} →\n            (c : CategoryTheory.Limits.Cocone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) →\n              (t : CategoryTheory.Limits.IsColimit c) →\n                [inst_2 :\n                    CategoryTheory.Limits.PreservesColimit\n                      (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T)) T.toFunctor] →\n                  [inst_3 :\n                      CategoryTheory.Limits.PreservesColimit\n                        (CategoryTheory.Functor.comp (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))\n                          T.toFunctor)\n                        T.toFunctor] →\n                    CategoryTheory.Limits.IsColimit (CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone c t)","name":"CategoryTheory.Monad.ForgetCreatesColimits.liftedCoconeIsColimit","isProp":false,"docString":"(Impl) Prove that the lifted cocone is colimiting. ","distance":0.37972900876566573202808285714127123355865478515625}],["Use the above equivalence to prove we have a limit. ",{"type":"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","isProp":true,"docString":"Use the above equivalence to prove we have a limit. ","distance":0.37997056487202607311104429754777811467647552490234375}],["Proof of continuity of the Hom. ",{"type":"∀ {A : Type u_2} {B : Type u_3} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun","name":"ContinuousMonoidHom.continuous_toFun","isProp":true,"docString":"Proof of continuity of the Hom. ","distance":0.3804311369498025729996015797951258718967437744140625}],["To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X ≅ CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X → X = Y","name":"CategoryTheory.Subobject.eq_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ","distance":0.381291952919074417227562889820546843111515045166015625}],["A convenient way to show that a binary cofan is a colimit. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      (s : CategoryTheory.Limits.BinaryCofan X Y) →\n        (desc : {T : C} → (X ⟶ T) → (Y ⟶ T) → (s.pt ⟶ T)) →\n          (∀ {T : C} (f : X ⟶ T) (g : Y ⟶ T),\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) (desc f g) = f) →\n            (∀ {T : C} (f : X ⟶ T) (g : Y ⟶ T),\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) (desc f g) = g) →\n              (∀ {T : C} (f : X ⟶ T) (g : Y ⟶ T) (m : s.pt ⟶ T),\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) m = f →\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) m = g → m = desc f g) →\n                CategoryTheory.Limits.IsColimit s","name":"CategoryTheory.Limits.BinaryCofan.IsColimit.mk","isProp":false,"docString":"A convenient way to show that a binary cofan is a colimit. ","distance":0.381470788034710406311234009990585036575794219970703125}],["Proof of left inverse ",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse ","distance":0.383366721171502333742608925604145042598247528076171875}],["A version of **Matiyasevic's theorem** ",{"type":"∀ {α : Type} {f g : (α → ℕ) → ℕ}, Dioph.DiophFn f → Dioph.DiophFn g → Dioph.DiophFn fun v => f v ^ g v","name":"Dioph.pow_dioph","isProp":true,"docString":"A version of **Matiyasevic's theorem** ","distance":0.386109207116553554417492932770983316004276275634765625}],["Correspondence theorem ",{"type":"{R : Type u} →\n  {S : Type v} →\n    {F : Type u_1} →\n      [inst : Ring R] →\n        [inst_1 : Ring S] →\n          [inst_2 : RingHomClass F R S] → (f : F) → Function.Surjective ⇑f → Ideal S ≃o { p // Ideal.comap f ⊥ ≤ p }","name":"Ideal.relIsoOfSurjective","isProp":false,"docString":"Correspondence theorem ","distance":0.38664599474294192305023898370563983917236328125}],["Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` ",{"type":"∀ {n : ℕ}, Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)","name":"Nat.fib_add_two","isProp":true,"docString":"Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` ","distance":0.386905291405191642528649254018091596662998199462890625}]]