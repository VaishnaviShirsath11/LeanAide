[["The element of G ",{"type":"{N : Type u_1} ‚Üí {G : Type u_2} ‚Üí [inst : Group N] ‚Üí [inst_1 : Group G] ‚Üí {œÜ : G ‚Üí* MulAut N} ‚Üí N ‚ãä[œÜ] G ‚Üí G","name":"SemidirectProduct.right","isProp":false,"docString":"The element of G ","distance":0.37483553659393142876155025078332982957363128662109375}],[" For any finite simple graph G and vertex v, the minimum degree of G is less than or equal to the degree of v.",{"type":"‚àÄ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V), G.minDegree ‚â§ G.degree v","name":"SimpleGraph.minDegree_le_degree","isProp":true,"docString":" For any finite simple graph G and vertex v, the minimum degree of G is less than or equal to the degree of v.","distance":0.5010396550287390393663145005120895802974700927734375}],["This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.",{"type":"‚àÄ (n m : ‚Ñï), (SetTheory.PGame.nim ‚Üën + SetTheory.PGame.nim ‚Üëm).grundyValue = ‚Üë(n ^^^ m)","name":"SetTheory.PGame.grundyValue_nim_add_nim","isProp":true,"docString":"This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.","distance":0.484065607961120136781829614847083576023578643798828125}],["The gcongr widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"GCongrSelectionPanel","isProp":false,"docString":"The gcongr widget. ","distance":0.39970930391996917219188389935879968106746673583984375}],[" For any impartial game G in set theory, its Grundy value equals an ordinal o if and only if G is equivalent to a game of Nim with o stones under optimal play.",{"type":"‚àÄ {G : SetTheory.PGame} [inst : G.Impartial] {o : Ordinal.{u_1}}, G.grundyValue = o ‚Üî G ‚âà SetTheory.PGame.nim o","name":"SetTheory.PGame.grundyValue_eq_iff_equiv_nim","isProp":true,"docString":" For any impartial game G in set theory, its Grundy value equals an ordinal o if and only if G is equivalent to a game of Nim with o stones under optimal play.","distance":0.50344617122275236997808178784907795488834381103515625}],["This theorem in set theory, specifically in the study of combinatorial games, states that for any impartial game `G` (a game where the allowable moves depend only on the position and not on which of the two players is currently moving), the Grundy value of `G` is equal to an ordinal `o` if and only if `G` is equivalent to a game of nim with `o` stones. Here equivalence means that the two games have the same outcome under optimal play. Nim is a particular type of game where players alternately take one or more stones from a single pile, with the player taking the last stone winning. The Grundy value of an impartial game is a kind of \"nim-value\" which measures how the game behaves under the mex (minimum excludant) operation.",{"type":"‚àÄ {G : SetTheory.PGame} [inst : G.Impartial] {o : Ordinal.{u_1}}, G.grundyValue = o ‚Üî G ‚âà SetTheory.PGame.nim o","name":"SetTheory.PGame.grundyValue_eq_iff_equiv_nim","isProp":true,"docString":"This theorem in set theory, specifically in the study of combinatorial games, states that for any impartial game `G` (a game where the allowable moves depend only on the position and not on which of the two players is currently moving), the Grundy value of `G` is equal to an ordinal `o` if and only if `G` is equivalent to a game of nim with `o` stones. Here equivalence means that the two games have the same outcome under optimal play. Nim is a particular type of game where players alternately take one or more stones from a single pile, with the player taking the last stone winning. The Grundy value of an impartial game is a kind of \"nim-value\" which measures how the game behaves under the mex (minimum excludant) operation.","distance":0.487010272009360811740208418996189720928668975830078125}],["The grading function. ",{"type":"{ùïÜ : Type u_5} ‚Üí {Œ± : Type u_6} ‚Üí [inst : Preorder ùïÜ] ‚Üí [inst_1 : Preorder Œ±] ‚Üí [self : GradeOrder ùïÜ Œ±] ‚Üí Œ± ‚Üí ùïÜ","name":"GradeOrder.grade","isProp":false,"docString":"The grading function. ","distance":0.4129422526965027540057917576632462441921234130859375}],["`g` is nonnegative ",{"type":"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {T : ‚Ñï ‚Üí ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} {a b : Œ± ‚Üí ‚Ñù} {r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï},\n  AkraBazziRecurrence T g a b r ‚Üí ‚àÄ x ‚â• 0, 0 ‚â§ g x","name":"AkraBazziRecurrence.g_nonneg","isProp":true,"docString":"`g` is nonnegative ","distance":0.41635601209883532636268910209764726459980010986328125}],["commutation with `g'` ",{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {S‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C} {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ} {h‚ÇÅ : CategoryTheory.ShortComplex.RightHomologyData S‚ÇÅ}\n  {h‚ÇÇ : CategoryTheory.ShortComplex.RightHomologyData S‚ÇÇ}\n  (self : CategoryTheory.ShortComplex.RightHomologyMapData œÜ h‚ÇÅ h‚ÇÇ),\n  CategoryTheory.CategoryStruct.comp self.œÜQ (CategoryTheory.ShortComplex.RightHomologyData.g' h‚ÇÇ) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.RightHomologyData.g' h‚ÇÅ) œÜ.œÑ‚ÇÉ","name":"CategoryTheory.ShortComplex.RightHomologyMapData.commg'","isProp":true,"docString":"commutation with `g'` ","distance":0.41887423583237559654435244738124310970306396484375}],["The ground set ",{"type":"{Œ± : Type u_2} ‚Üí IndepMatroid Œ± ‚Üí Set Œ±","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.41897563892302402965839291937300004065036773681640625}],["The counit for the comonad `G`. ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    (G : CategoryTheory.Comonad C) ‚Üí G.toFunctor ‚ü∂ CategoryTheory.Functor.id C","name":"CategoryTheory.Comonad.Œµ","isProp":false,"docString":"The counit for the comonad `G`. ","distance":0.424606262881722595903255523808184079825878143310546875}],["an arrow ",{"type":"{V : Type u} ‚Üí [inst : Quiver V] ‚Üí (self : Quiver.Total V) ‚Üí self.left ‚ü∂ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.426064586956948598839289843454025685787200927734375}],["tensorator ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    [inst_1 : CategoryTheory.MonoidalCategory C] ‚Üí\n      {D : Type u‚ÇÇ} ‚Üí\n        [inst_2 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n          [inst_3 : CategoryTheory.MonoidalCategory D] ‚Üí\n            {F : C ‚Üí D} ‚Üí\n              [inst_4 : CategoryTheory.Functorial F] ‚Üí\n                [self : CategoryTheory.LaxMonoidal F] ‚Üí\n                  (X Y : C) ‚Üí\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ‚ü∂\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.Œº","isProp":false,"docString":"tensorator ","distance":0.431736859805520512001208999208756722509860992431640625}],["One has grade zero ",{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : SetLike S R] [inst_1 : One R] [inst_2 : Zero Œπ] {A : Œπ ‚Üí S}\n  [self : SetLike.GradedOne A], 1 ‚àà A 0","name":"SetLike.GradedOne.one_mem","isProp":true,"docString":"One has grade zero ","distance":0.43202432402094448349316735402680933475494384765625}],["The canonical injection of G's generators into G ",{"type":"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí [inst_1 : IsFreeGroup G] ‚Üí IsFreeGroup.Generators G ‚Üí G","name":"IsFreeGroup.of","isProp":false,"docString":"The canonical injection of G's generators into G ","distance":0.432406751231592834106010059258551336824893951416015625}],["The program. ",{"type":"{Œì : Type u_1} ‚Üí\n  {Œõ : Type u_2} ‚Üí\n    [inst : Inhabited Œõ] ‚Üí Turing.TM0.Machine Œì Œõ ‚Üí Turing.TM0to1.Œõ' ‚Üí Turing.TM1.Stmt Œì Turing.TM0to1.Œõ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.433300933642000674073102572947391308844089508056640625}],["The Gromov-Hausdorff space ",{"type":"Type","name":"GromovHausdorff.GHSpace","isProp":false,"docString":"The Gromov-Hausdorff space ","distance":0.433466646070333083695658160650054924190044403076171875}],["`G` is closed under negation ",{"type":"‚àÄ {R : Type u} [inst : Ring R] (self : Subring R) {x : R}, x ‚àà self.carrier ‚Üí -x ‚àà self.carrier","name":"Subring.neg_mem'","isProp":true,"docString":"`G` is closed under negation ","distance":0.433528392413639884761522580447490327060222625732421875}],["The basis of M. ",{"type":"{R : Type u_2} ‚Üí\n  [inst : CommRing R] ‚Üí\n    {M : Type u_3} ‚Üí\n      [inst_1 : AddCommGroup M] ‚Üí\n        [inst_2 : Module R M] ‚Üí\n          {N : Submodule R M} ‚Üí {Œπ : Type u_4} ‚Üí {n : ‚Ñï} ‚Üí Basis.SmithNormalForm N Œπ n ‚Üí Basis Œπ R M","name":"Basis.SmithNormalForm.bM","isProp":false,"docString":"The basis of M. ","distance":0.434490128139451758926270485972054302692413330078125}],["the underlying presieve ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí {X : C} ‚Üí CategoryTheory.Sieve X ‚Üí CategoryTheory.Presieve X","name":"CategoryTheory.Sieve.arrows","isProp":false,"docString":"the underlying presieve ","distance":0.43654203054449147725080138116027228534221649169921875}],["The empty finset ",{"type":"{Œ± : Type u_1} ‚Üí Finset Œ±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.43708740760016073778615464107133448123931884765625}],["projection expression ",{"type":"Simps.ParsedProjectionData ‚Üí Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.437776780265042908535377819134737364947795867919921875}],["The subgroup `G` of the group `G`. ",{"type":"{G : Type u_1} ‚Üí [inst : Group G] ‚Üí Top (Subgroup G)","name":"Subgroup.instTopSubgroup","isProp":false,"docString":"The subgroup `G` of the group `G`. ","distance":0.44047097567492332625960216319072060286998748779296875}],["`G` is cover-lifting wrt the induced topology. ",{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] {D : Type u_2}\n  [inst_1 : CategoryTheory.Category.{u_4, u_2} D] {G : CategoryTheory.Functor C D}\n  {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G] [inst_3 : CategoryTheory.Faithful G]\n  (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.Functor.IsCocontinuous G (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K","name":"CategoryTheory.LocallyCoverDense.inducedTopology_isCocontinuous","isProp":true,"docString":"`G` is cover-lifting wrt the induced topology. ","distance":0.44063472837566985962354237926774658262729644775390625}]]