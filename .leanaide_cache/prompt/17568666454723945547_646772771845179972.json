[["`g` is nonnegative ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → ∀ x ≥ 0, 0 ≤ g x","name":"AkraBazziRecurrence.g_nonneg","isProp":true,"docString":"`g` is nonnegative ","distance":0.307126261211016993168954059001407586038112640380859375}],[" If 'G' is a countable group acting measurably on measurable space ('α', μ) with 's' as a fundamental domain, then for any measurable set 't', the measure of 't' equals the sum of measures of intersections 't ∩ g(s)' over all elements 'g' in 'G'.",{"type":"∀ {G : Type u_1} {α : Type u_3} [inst : Group G] [inst_1 : MulAction G α] [inst_2 : MeasurableSpace α] {s : Set α}\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasurableSpace G] [inst_4 : MeasurableSMul G α]\n  [inst_5 : MeasureTheory.SMulInvariantMeasure G α μ] [inst_6 : Countable G],\n  MeasureTheory.IsFundamentalDomain G s μ → ∀ (t : Set α), ↑↑μ t = ∑' (g : G), ↑↑μ (g • t ∩ s)","name":"MeasureTheory.IsFundamentalDomain.measure_eq_tsum","isProp":true,"docString":" If 'G' is a countable group acting measurably on measurable space ('α', μ) with 's' as a fundamental domain, then for any measurable set 't', the measure of 't' equals the sum of measures of intersections 't ∩ g(s)' over all elements 'g' in 'G'.","distance":0.45559733871167684693403998608118854463100433349609375}],["This theorem, in the field of probability theory, states that if `f` and `g` are independent random variables with values in the extended nonnegative real numbers (usually denoted as [0, ∞]), then the expected value of the product of `f` and `g` is equal to the product of the expected values of `f` and `g`. The expectation is calculated with respect to a measure `μ` on a measurable space `Ω`. The variables `f` and `g` are functions from `Ω` to [0, ∞] and are assumed to be measurable, meaning the preimage of every measurable set under these functions is also measurable.",{"type":"∀ {Ω : Type u_1} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {f g : Ω → ENNReal},\n  Measurable f →\n    Measurable g →\n      ProbabilityTheory.IndepFun f g μ → ∫⁻ (ω : Ω), (f * g) ω ∂μ = (∫⁻ (ω : Ω), f ω ∂μ) * ∫⁻ (ω : Ω), g ω ∂μ","name":"ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun","isProp":true,"docString":"This theorem, in the field of probability theory, states that if `f` and `g` are independent random variables with values in the extended nonnegative real numbers (usually denoted as [0, ∞]), then the expected value of the product of `f` and `g` is equal to the product of the expected values of `f` and `g`. The expectation is calculated with respect to a measure `μ` on a measurable space `Ω`. The variables `f` and `g` are functions from `Ω` to [0, ∞] and are assumed to be measurable, meaning the preimage of every measurable set under these functions is also measurable.","distance":0.440160261526504559270733807352371513843536376953125}],["The element of G ",{"type":"{N : Type u_1} → {G : Type u_2} → [inst : Group N] → [inst_1 : Group G] → {φ : G →* MulAut N} → N ⋊[φ] G → G","name":"SemidirectProduct.right","isProp":false,"docString":"The element of G ","distance":0.311921110662611134056731998498435132205486297607421875}],[" For any measure space with measurable space and measure, and two functions from to the extended nonnegative real numbers with being almost everywhere less than or equal to almost everywhere measurable g, the integral of f with respect to μ and ε times the measure of {x | f(x) + ε < g(x)} is less than or equal to the integral of g with respect to μ.",{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f g : α → ENNReal},\n  μ.ae.EventuallyLE f g →\n    AEMeasurable g μ → ∀ (ε : ENNReal), ∫⁻ (a : α), f a ∂μ + ε * ↑↑μ {x | f x + ε ≤ g x} ≤ ∫⁻ (a : α), g a ∂μ","name":"MeasureTheory.lintegral_add_mul_meas_add_le_le_lintegral","isProp":true,"docString":" For any measure space with measurable space and measure, and two functions from to the extended nonnegative real numbers with being almost everywhere less than or equal to almost everywhere measurable g, the integral of f with respect to μ and ε times the measure of {x | f(x) + ε < g(x)} is less than or equal to the integral of g with respect to μ.","distance":0.458905615331706318027471525056171230971813201904296875}],["This theorem states that for any given measurable space 'α' and measure 'μ', if there are two functions 'f' and 'g' defined on a set 's' in 'α', and if both 'f' and 'g' are integrable on 's' with respect to the measure 'μ', and furthermore, if for every 'x' in 's', 'f(x)' is less than or equal to 'g(x)', then the volume of the region between the two functions 'f' and 'g' can be expressed as an integral. Specifically, the volume of the region between functions 'f' and 'g' is equal to the extended non-negative real number equivalent of the integral over 's' of '(g - f) y' with respect to the measure 'μ'.",{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {f g : α → ℝ} {s : Set α}\n  [inst_1 : MeasureTheory.SigmaFinite μ],\n  MeasureTheory.IntegrableOn f s μ →\n    MeasureTheory.IntegrableOn g s μ →\n      MeasurableSet s →\n        (∀ x ∈ s, f x ≤ g x) →\n          ↑↑(μ.prod MeasureTheory.volume) (regionBetween f g s) = ENNReal.ofReal (∫ (y : α) in s, (g - f) y ∂μ)","name":"volume_regionBetween_eq_integral","isProp":true,"docString":"This theorem states that for any given measurable space 'α' and measure 'μ', if there are two functions 'f' and 'g' defined on a set 's' in 'α', and if both 'f' and 'g' are integrable on 's' with respect to the measure 'μ', and furthermore, if for every 'x' in 's', 'f(x)' is less than or equal to 'g(x)', then the volume of the region between the two functions 'f' and 'g' can be expressed as an integral. Specifically, the volume of the region between functions 'f' and 'g' is equal to the extended non-negative real number equivalent of the integral over 's' of '(g - f) y' with respect to the measure 'μ'.","distance":0.445833095702395543202811722949263639748096466064453125}],["commutation with `g'` ",{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {S₁ S₂ : CategoryTheory.ShortComplex C} {φ : S₁ ⟶ S₂} {h₁ : CategoryTheory.ShortComplex.RightHomologyData S₁}\n  {h₂ : CategoryTheory.ShortComplex.RightHomologyData S₂}\n  (self : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂),\n  CategoryTheory.CategoryStruct.comp self.φQ (CategoryTheory.ShortComplex.RightHomologyData.g' h₂) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.RightHomologyData.g' h₁) φ.τ₃","name":"CategoryTheory.ShortComplex.RightHomologyMapData.commg'","isProp":true,"docString":"commutation with `g'` ","distance":0.350342864217352889522061332172597758471965789794921875}],["`g` grows polynomially ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → AkraBazziRecurrence.GrowsPolynomially g","name":"AkraBazziRecurrence.g_grows_poly","isProp":true,"docString":"`g` grows polynomially ","distance":0.354148781080537045085065983585081994533538818359375}],["a section of `S.g` ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Splitting S → (S.X₃ ⟶ S.X₂)","name":"CategoryTheory.ShortComplex.Splitting.s","isProp":false,"docString":"a section of `S.g` ","distance":0.3603593687249551091866806018515489995479583740234375}],["The extension of `g` along `f`. ",{"type":"{B : Type u} →\n  [inst : CategoryTheory.Bicategory B] →\n    {a b c : B} → {f : a ⟶ b} → {g : a ⟶ c} → CategoryTheory.Bicategory.RightExtension f g → (b ⟶ c)","name":"CategoryTheory.Bicategory.RightExtension.extension","isProp":false,"docString":"The extension of `g` along `f`. ","distance":0.365522811467796804318908243658370338380336761474609375}],["`G` is closed under negation ",{"type":"∀ {R : Type u} [inst : Ring R] (self : Subring R) {x : R}, x ∈ self.carrier → -x ∈ self.carrier","name":"Subring.neg_mem'","isProp":true,"docString":"`G` is closed under negation ","distance":0.36900731211224713224083870954927988350391387939453125}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.369905415543831661562279577992740087211132049560546875}],["The equalizer of `f` and `g` exists. ",{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X Y : C} (f g : X ⟶ Y),\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)","name":"CategoryTheory.NormalMonoCategory.hasLimit_parallelPair","isProp":true,"docString":"The equalizer of `f` and `g` exists. ","distance":0.373386874714042249490120184418628923594951629638671875}],["A map in the opposite direction to `f` and `g` ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → {f g : X ⟶ Y} → {Z : C} → {π : Y ⟶ Z} → CategoryTheory.IsSplitCoequalizer f g π → (Y ⟶ X)","name":"CategoryTheory.IsSplitCoequalizer.leftSection","isProp":false,"docString":"A map in the opposite direction to `f` and `g` ","distance":0.376791833261449771175222167585161514580249786376953125}],["The gcongr widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"GCongrSelectionPanel","isProp":false,"docString":"The gcongr widget. ","distance":0.37751983541765599117212559576728381216526031494140625}],["The coequalizer of `f` and `g` exists. ",{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] {X Y : C} (f g : X ⟶ Y),\n  CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f g)","name":"CategoryTheory.NormalEpiCategory.hasColimit_parallelPair","isProp":true,"docString":"The coequalizer of `f` and `g` exists. ","distance":0.3794179383011015982418712155777029693126678466796875}],["The counit for the comonad `G`. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    (G : CategoryTheory.Comonad C) → G.toFunctor ⟶ CategoryTheory.Functor.id C","name":"CategoryTheory.Comonad.ε","isProp":false,"docString":"The counit for the comonad `G`. ","distance":0.37972422181840015387166431537480093538761138916015625}],["`G` is closed under inverses ",{"type":"∀ {G : Type u_5} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier","name":"Subgroup.inv_mem'","isProp":true,"docString":"`G` is closed under inverses ","distance":0.380209919936161544473662843302008695900440216064453125}],["The image of `g` is the opposite of the image of `g.unop.` ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {A B : Cᵒᵖ} → (g : A ⟶ B) → (CategoryTheory.Limits.image g).unop ≅ CategoryTheory.Limits.image g.unop","name":"CategoryTheory.imageUnopUnop","isProp":false,"docString":"The image of `g` is the opposite of the image of `g.unop.` ","distance":0.383689411285161041664792946903617121279239654541015625}],["`f` is the coequalizer ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X Y : C} →\n      {f : X ⟶ Y} →\n        [self : CategoryTheory.RegularEpi f] →\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.Cofork.ofπ f\n              (_ :\n                CategoryTheory.CategoryStruct.comp CategoryTheory.RegularEpi.left f =\n                  CategoryTheory.CategoryStruct.comp CategoryTheory.RegularEpi.right f))","name":"CategoryTheory.RegularEpi.isColimit","isProp":false,"docString":"`f` is the coequalizer ","distance":0.3843620923902586472564735231571830809116363525390625}],["This is (-)^A. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (A : C) →\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] →\n        [inst_2 : CategoryTheory.Exponentiable A] → CategoryTheory.Functor C C","name":"CategoryTheory.exp","isProp":false,"docString":"This is (-)^A. ","distance":0.38468633834693821693662130201118998229503631591796875}],["A kernel of `f - g` is an equalizer of `f` and `g`. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {X Y : C} →\n        {f g : X ⟶ Y} →\n          {c : CategoryTheory.Limits.KernelFork (f - g)} →\n            CategoryTheory.Limits.IsLimit c →\n              CategoryTheory.Limits.IsLimit (CategoryTheory.Preadditive.forkOfKernelFork c)","name":"CategoryTheory.Preadditive.isLimitForkOfKernelFork","isProp":false,"docString":"A kernel of `f - g` is an equalizer of `f` and `g`. ","distance":0.388162973603807193168080402756459079682826995849609375}],["The lift of `g` along `f`. ",{"type":"{B : Type u} →\n  [inst : CategoryTheory.Bicategory B] →\n    {a b c : B} → {f : b ⟶ a} → {g : c ⟶ a} → CategoryTheory.Bicategory.RightLift f g → (c ⟶ b)","name":"CategoryTheory.Bicategory.RightLift.lift","isProp":false,"docString":"The lift of `g` along `f`. ","distance":0.38843485871106275819641950874938629567623138427734375}],["There is `g` such that `g • x = y`. ",{"type":"∀ {M : Type u_10} {α : Type u_11} [inst : SMul M α] [self : MulAction.IsPretransitive M α] (x y : α), ∃ g, g • x = y","name":"MulAction.IsPretransitive.exists_smul_eq","isProp":true,"docString":"There is `g` such that `g • x = y`. ","distance":0.38984367265962605042517452602623961865901947021484375}]]