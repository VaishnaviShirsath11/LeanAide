[["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.40217974363828801198650353398988954722881317138671875}],[" The order of a Sylow p-subgroup of a finite group G is coprime with the index of G/P, where P is a Sylow p-subgroup of G.",{"type":"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact p.Prime] (P : Sylow p G),\n  (Fintype.card ↥↑P).Coprime P.index","name":"Sylow.card_coprime_index","isProp":true,"docString":" The order of a Sylow p-subgroup of a finite group G is coprime with the index of G/P, where P is a Sylow p-subgroup of G.","distance":0.51253583042239814204776848782785236835479736328125}],["This theorem states that in the context of a linear order, the properties of being well-founded (`Set.IsWF`) and being a partially well-ordered set (`Set.IsPWO`) are equivalent for a given set. A set is said to be well-founded if there is no infinite descending sequence of elements in it, and a set is said to be partially well-ordered if any infinite sequence from it contains an infinite monotonically increasing subsequence. Therefore, this theorem provides an equivalence between these two properties in the case of linearly ordered sets.",{"type":"∀ {α : Type u_2} [inst : LinearOrder α] {s : Set α}, s.IsWF ↔ s.IsPWO","name":"Set.isWF_iff_isPWO","isProp":true,"docString":"This theorem states that in the context of a linear order, the properties of being well-founded (`Set.IsWF`) and being a partially well-ordered set (`Set.IsPWO`) are equivalent for a given set. A set is said to be well-founded if there is no infinite descending sequence of elements in it, and a set is said to be partially well-ordered if any infinite sequence from it contains an infinite monotonically increasing subsequence. Therefore, this theorem provides an equivalence between these two properties in the case of linearly ordered sets.","distance":0.48925504230129923666225977285648696124553680419921875}],["The left arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.left ⟶ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inl","isProp":false,"docString":"The left arrow of the walking cospan. ","distance":0.407655789385626354803804360926733352243900299072265625}],[" For any ordered ring R, additive commutative group V, R-module V, and additive torsor V over P, the strict betweenness relation Sbtw on P is a symmetric relation.",{"type":"∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V]\n  [inst_3 : AddTorsor V P] {x y z : P}, Sbtw R x y z ↔ Sbtw R z y x","name":"sbtw_comm","isProp":true,"docString":" For any ordered ring R, additive commutative group V, R-module V, and additive torsor V over P, the strict betweenness relation Sbtw on P is a symmetric relation.","distance":0.5127427481046809010223341829259879887104034423828125}],["This theorem states that for any types `R`, `V`, `P` where `R` is an ordered ring, `V` is an additive commutative group, `P` is an affine space over `V` with `R` as its scalar field, and `x`, `y`, `z` are points in this affine space, if `y` is strictly between `x` and `z` (according to the definition `Sbtw`), then `y` is also weakly between `x` and `z` (according to the definition `Wbtw`). In other words, the condition of a point being strictly between two other points implies the condition of the point being weakly between the same two points.",{"type":"∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V]\n  [inst_3 : AddTorsor V P] {x y z : P}, Sbtw R x y z → Wbtw R x y z","name":"Sbtw.wbtw","isProp":true,"docString":"This theorem states that for any types `R`, `V`, `P` where `R` is an ordered ring, `V` is an additive commutative group, `P` is an affine space over `V` with `R` as its scalar field, and `x`, `y`, `z` are points in this affine space, if `y` is strictly between `x` and `z` (according to the definition `Sbtw`), then `y` is also weakly between `x` and `z` (according to the definition `Wbtw`). In other words, the condition of a point being strictly between two other points implies the condition of the point being weakly between the same two points.","distance":0.490770381621201956523492526685004122555255889892578125}],["The left arrow of the walking span. ",{"type":"CategoryTheory.Limits.WalkingSpan.zero ⟶ CategoryTheory.Limits.WalkingSpan.left","name":"CategoryTheory.Limits.WalkingSpan.Hom.fst","isProp":false,"docString":"The left arrow of the walking span. ","distance":0.40871904868710251523822307717637158930301666259765625}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.408834060734401039116647780247149057686328887939453125}],["The right arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.right ⟶ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inr","isProp":false,"docString":"The right arrow of the walking cospan. ","distance":0.408841794175278383516314306689309887588024139404296875}],["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.41137051898033971664148111813119612634181976318359375}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.412340346811813585059525166798266582190990447998046875}],["The conv widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"ConvSelectionPanel","isProp":false,"docString":"The conv widget. ","distance":0.413211694056535516761385906647774390876293182373046875}],["lp space ",{"type":"Lean.ParserDescr","name":"lp.«termℓ^∞(_,_)»","isProp":false,"docString":"lp space ","distance":0.4143426782852024370384924623067490756511688232421875}],["The right arrow of the walking span. ",{"type":"CategoryTheory.Limits.WalkingSpan.zero ⟶ CategoryTheory.Limits.WalkingSpan.right","name":"CategoryTheory.Limits.WalkingSpan.Hom.snd","isProp":false,"docString":"The right arrow of the walking span. ","distance":0.416226822572498156294074078687117435038089752197265625}],["Action of a Shelf",{"type":"Lean.TrailingParserDescr","name":"Quandles.«term_◃_»","isProp":false,"docString":"Action of a Shelf","distance":0.4164848697069751803923054467304609715938568115234375}],["The calc widget. ",{"type":"ProofWidgets.Component CalcParams","name":"CalcPanel","isProp":false,"docString":"The calc widget. ","distance":0.416826691525008008465391640129382722079753875732421875}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.418293940550306164727345503706601448357105255126953125}],["The gcongr widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"GCongrSelectionPanel","isProp":false,"docString":"The gcongr widget. ","distance":0.419919531300096793291487529131700284779071807861328125}],["A choice of wide pushout. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (B : C) →\n        (objs : J → C) →\n          (arrows : (j : J) → B ⟶ objs j) → [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] → C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.42245944824557957186783596625900827348232269287109375}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.4229998507135068752660345126059837639331817626953125}],["Name of the presenter to use. ",{"type":"ProofWidgets.GetExprPresentationParams → Lean.Name","name":"ProofWidgets.GetExprPresentationParams.name","isProp":false,"docString":"Name of the presenter to use. ","distance":0.4231952088783150767170582184917293488979339599609375}],["The identity arrows of the walking cospan. ",{"type":"(X : CategoryTheory.Limits.WalkingCospan) → X ⟶ X","name":"CategoryTheory.Limits.WalkingCospan.Hom.id","isProp":false,"docString":"The identity arrows of the walking cospan. ","distance":0.423629193036502649238883577709202654659748077392578125}],["The identity arrows of the walking span. ",{"type":"(X : CategoryTheory.Limits.WalkingSpan) → X ⟶ X","name":"CategoryTheory.Limits.WalkingSpan.Hom.id","isProp":false,"docString":"The identity arrows of the walking span. ","distance":0.426794541746231936851785349062993191182613372802734375}],["The left point of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan","name":"CategoryTheory.Limits.WalkingCospan.left","isProp":false,"docString":"The left point of the walking cospan. ","distance":0.42760026577212795206861528640729375183582305908203125}]]