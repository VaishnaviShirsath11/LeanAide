[["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    (F : CategoryTheory.Functor J MonCat) ‚Üí CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.32745562556355711780753381390240974724292755126953125}],[" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.",{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {p : Finset (Finset Œ±) ‚Üí Prop} (ùíú : Finset (Finset Œ±)),\n  p ‚àÖ ‚Üí\n    p {‚àÖ} ‚Üí\n      (‚àÄ (a : Œ±) ‚¶Éùíú : Finset (Finset Œ±)‚¶Ñ, (‚àÄ s ‚àà ùíú, a ‚àâ s) ‚Üí p ùíú ‚Üí p (Finset.image (insert a) ùíú)) ‚Üí\n        (‚àÄ (a : Œ±) ‚¶Éùíú : Finset (Finset Œ±)‚¶Ñ,\n            p (Finset.filter (fun x => a ‚àâ x) ùíú) ‚Üí p (Finset.filter (fun x => a ‚àà x) ùíú) ‚Üí p ùíú) ‚Üí\n          p ùíú","name":"Finset.family_induction_on","isProp":true,"docString":" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.","distance":0.448216675772849793002450269341352395713329315185546875}],["This theorem states that to prove the equality of two linear maps (`f` and `g`) from the exterior algebra of an `R`-module `M` to another `R`-module `N`, it is enough to demonstrate that these maps agree on the exterior powers of `M`. This is proven by showing that the composition of `f` and `g` with the same alternating map, generated by applying the canonical injection of `M` into the exterior algebra, produces identical results for all natural numbers `i`.",{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup N]\n  [inst_3 : Module R M] [inst_4 : Module R N] ‚¶Éf g : ExteriorAlgebra R M ‚Üí‚Çó[R] N‚¶Ñ,\n  (‚àÄ (i : ‚Ñï), f.compAlternatingMap (ExteriorAlgebra.ŒπMulti R i) = g.compAlternatingMap (ExteriorAlgebra.ŒπMulti R i)) ‚Üí\n    f = g","name":"ExteriorAlgebra.lhom_ext","isProp":true,"docString":"This theorem states that to prove the equality of two linear maps (`f` and `g`) from the exterior algebra of an `R`-module `M` to another `R`-module `N`, it is enough to demonstrate that these maps agree on the exterior powers of `M`. This is proven by showing that the composition of `f` and `g` with the same alternating map, generated by applying the canonical injection of `M` into the exterior algebra, produces identical results for all natural numbers `i`.","distance":0.410287077930638399703155982933822087943553924560546875}],["The statement to be proved inductively ",{"type":"{F : Type u_1} ‚Üí\n  [inst : Field F] ‚Üí {E : Type u_2} ‚Üí [inst_1 : Field E] ‚Üí [inst_2 : Algebra F E] ‚Üí ‚Ü•(solvableByRad F E) ‚Üí Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.332308590499922062999615945955156348645687103271484375}],[" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.",{"type":"‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {P : MvPolynomial œÉ R ‚Üí Prop} (p : MvPolynomial œÉ R),\n  (‚àÄ (u : œÉ ‚Üí‚ÇÄ ‚Ñï) (a : R), P ((MvPolynomial.monomial u) a)) ‚Üí (‚àÄ (p q : MvPolynomial œÉ R), P p ‚Üí P q ‚Üí P (p + q)) ‚Üí P p","name":"MvPolynomial.induction_on'","isProp":true,"docString":" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.","distance":0.45132585059027874319070861020009033381938934326171875}],["This theorem states that, for any two propositions `a` and `b`, the existence of a proof of `b` given a proof of `a` is equivalent to the conjunction of `a` and `b`. In other words, there exists a proof of `b` under the assumption that `a` is true if and only if both `a` and `b` are true.",{"type":"‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop}, (¬¨‚àÄ (x : Œ±), p x) = ‚àÉ x, ¬¨p x","name":"Mathlib.Data.Finset.Basic._auxLemma.144","isProp":true,"docString":"This theorem states that, for any two propositions `a` and `b`, the existence of a proof of `b` given a proof of `a` is equivalent to the conjunction of `a` and `b`. In other words, there exists a proof of `b` under the assumption that `a` is true if and only if both `a` and `b` are true.","distance":0.4172251805987012840404304370167665183544158935546875}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        [inst_2 : CategoryTheory.IsConnected J] ‚Üí\n          {B : C} ‚Üí\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} ‚Üí\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} ‚Üí\n                CategoryTheory.Limits.IsLimit c ‚Üí\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.341495023522400575899382602074183523654937744140625}],["The proof that it is the colimit cocone ",{"type":"{J : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        {F : CategoryTheory.Functor J C} ‚Üí\n          (self : CategoryTheory.Limits.ColimitCocone F) ‚Üí CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.347889995601592227902898457614355720579624176025390625}],["The proof that is the limit cone ",{"type":"{J : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        {F : CategoryTheory.Functor J C} ‚Üí\n          (self : CategoryTheory.Limits.LimitCone F) ‚Üí CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.354414595844133650803797763728653080761432647705078125}],["Proof of continuity of the Hom. ",{"type":"‚àÄ {A : Type u_2} {B : Type u_3} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun","name":"ContinuousMonoidHom.continuous_toFun","isProp":true,"docString":"Proof of continuity of the Hom. ","distance":0.361295995525753088628562181838788092136383056640625}],["Proof of right inverse ",{"type":"‚àÄ {Œ± : Type u} [self : Rack Œ±] (x : Œ±), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse ","distance":0.367197871410080700638189910023356787860393524169921875}],["(Impl) Prove that the lifted cocone is colimiting. ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {T : CategoryTheory.Monad C} ‚Üí\n      {J : Type u} ‚Üí\n        [inst_1 : CategoryTheory.Category.{v, u} J] ‚Üí\n          {D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)} ‚Üí\n            (c : CategoryTheory.Limits.Cocone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) ‚Üí\n              (t : CategoryTheory.Limits.IsColimit c) ‚Üí\n                [inst_2 :\n                    CategoryTheory.Limits.PreservesColimit\n                      (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T)) T.toFunctor] ‚Üí\n                  [inst_3 :\n                      CategoryTheory.Limits.PreservesColimit\n                        (CategoryTheory.Functor.comp (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))\n                          T.toFunctor)\n                        T.toFunctor] ‚Üí\n                    CategoryTheory.Limits.IsColimit (CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone c t)","name":"CategoryTheory.Monad.ForgetCreatesColimits.liftedCoconeIsColimit","isProp":false,"docString":"(Impl) Prove that the lifted cocone is colimiting. ","distance":0.3697258436187171870557222064235247671604156494140625}],["(Impl) Prove that the lifted cone is limiting. ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {T : CategoryTheory.Monad C} ‚Üí\n      {J : Type u} ‚Üí\n        [inst_1 : CategoryTheory.Category.{v, u} J] ‚Üí\n          (D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)) ‚Üí\n            (c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) ‚Üí\n              (t : CategoryTheory.Limits.IsLimit c) ‚Üí\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Monad.ForgetCreatesLimits.liftedCone D c t)","name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedConeIsLimit","isProp":false,"docString":"(Impl) Prove that the lifted cone is limiting. ","distance":0.36995352597486697021622603642754256725311279296875}],["To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X ‚âÖ CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X ‚Üí X = Y","name":"CategoryTheory.Subobject.eq_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ","distance":0.37074537803724194606758146619540639221668243408203125}],["Correspondence theorem ",{"type":"{R : Type u} ‚Üí\n  {S : Type v} ‚Üí\n    {F : Type u_1} ‚Üí\n      [inst : Ring R] ‚Üí\n        [inst_1 : Ring S] ‚Üí\n          [inst_2 : RingHomClass F R S] ‚Üí (f : F) ‚Üí Function.Surjective ‚áëf ‚Üí Ideal S ‚âÉo { p // Ideal.comap f ‚ä• ‚â§ p }","name":"Ideal.relIsoOfSurjective","isProp":false,"docString":"Correspondence theorem ","distance":0.370908337184784164808348805308924056589603424072265625}],["Proof of the continuity of the map. ",{"type":"‚àÄ {F : Type u_1} {A : outParam (Type u_7)} {B : outParam (Type u_8)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ‚áëf","name":"ContinuousMonoidHomClass.map_continuous","isProp":true,"docString":"Proof of the continuity of the map. ","distance":0.37103367117945940112377911646035499870777130126953125}],["Compose two proofs by transitivity, generalized over the relations involved. ",{"type":"{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {Œ≥ : Sort u_3} ‚Üí\n      {r : Œ± ‚Üí Œ≤ ‚Üí Sort u} ‚Üí\n        {s : Œ≤ ‚Üí Œ≥ ‚Üí Sort v} ‚Üí\n          {t : outParam (Œ± ‚Üí Œ≥ ‚Üí Sort w)} ‚Üí [self : Trans r s t] ‚Üí {a : Œ±} ‚Üí {b : Œ≤} ‚Üí {c : Œ≥} ‚Üí r a b ‚Üí s b c ‚Üí t a c","name":"Trans.trans","isProp":false,"docString":"Compose two proofs by transitivity, generalized over the relations involved. ","distance":0.376804803295670842633313668557093478739261627197265625}],["Proof of left inverse ",{"type":"‚àÄ {Œ± : Type u} [self : Rack Œ±] (x : Œ±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse ","distance":0.37937679408327340535578287017415277659893035888671875}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.37950989155092529347967911235173232853412628173828125}],["Shows that definability is closed under finite projections. ",{"type":"‚àÄ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {Œ± : Type u‚ÇÅ}\n  {Œ≤ : Type u_1} {s : Set (Œ≤ ‚Üí M)},\n  Set.Definable A L s ‚Üí ‚àÄ (f : Œ± ‚Üí Œ≤) [inst_1 : Finite Œ±] [inst_2 : Finite Œ≤], Set.Definable A L ((fun g => g ‚àò f) '' s)","name":"Set.Definable.image_comp","isProp":true,"docString":"Shows that definability is closed under finite projections. ","distance":0.381373860807916020831953574088402092456817626953125}],["Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. ",{"type":"‚àÄ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ‚Ñö A] (n : ‚Ñï),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ‚Üëk ^ p * (algebraMap ‚Ñö A) (‚Üë(Nat.factorial p))‚Åª¬π","name":"PowerSeries.exp_pow_sum","isProp":true,"docString":"Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. ","distance":0.382192490269228357657738115449319593608379364013671875}],["Use the above equivalence to prove we have a limit. ",{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","isProp":true,"docString":"Use the above equivalence to prove we have a limit. ","distance":0.383431285004352695455764887810801155865192413330078125}],["A convenient way to show that a binary cofan is a colimit. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí\n      (s : CategoryTheory.Limits.BinaryCofan X Y) ‚Üí\n        (desc : {T : C} ‚Üí (X ‚ü∂ T) ‚Üí (Y ‚ü∂ T) ‚Üí (s.pt ‚ü∂ T)) ‚Üí\n          (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) (desc f g) = f) ‚Üí\n            (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) (desc f g) = g) ‚Üí\n              (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (m : s.pt ‚ü∂ T),\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) m = f ‚Üí\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) m = g ‚Üí m = desc f g) ‚Üí\n                CategoryTheory.Limits.IsColimit s","name":"CategoryTheory.Limits.BinaryCofan.IsColimit.mk","isProp":false,"docString":"A convenient way to show that a binary cofan is a colimit. ","distance":0.3858873968275255972315562758012674748897552490234375}],["To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. ",{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) ‚Üí x ‚àà CliffordAlgebra.evenOdd Q 1 ‚Üí Prop},\n  (‚àÄ (v : M), P ((CliffordAlgebra.Œπ Q) v) (_ : (CliffordAlgebra.Œπ Q) v ‚àà CliffordAlgebra.evenOdd Q 1)) ‚Üí\n    (‚àÄ {x y : CliffordAlgebra Q} {hx : x ‚àà CliffordAlgebra.evenOdd Q 1} {hy : y ‚àà CliffordAlgebra.evenOdd Q 1},\n        P x hx ‚Üí P y hy ‚Üí P (x + y) (_ : x + y ‚àà CliffordAlgebra.evenOdd Q 1)) ‚Üí\n      (‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : CliffordAlgebra Q} {hx : x ‚àà CliffordAlgebra.evenOdd Q 1},\n          P x hx ‚Üí\n            P ((CliffordAlgebra.Œπ Q) m‚ÇÅ * (CliffordAlgebra.Œπ Q) m‚ÇÇ * x)\n              (_ : (CliffordAlgebra.Œπ Q) m‚ÇÅ * (CliffordAlgebra.Œπ Q) m‚ÇÇ * x ‚àà CliffordAlgebra.evenOdd Q 1)) ‚Üí\n        ‚àÄ (x : CliffordAlgebra Q) (hx : x ‚àà CliffordAlgebra.evenOdd Q 1), P x hx","name":"CliffordAlgebra.odd_induction","isProp":true,"docString":"To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. ","distance":0.3861058704283806264356826432049274444580078125}]]