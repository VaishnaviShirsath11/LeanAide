[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.35842500053363013368112888201721943914890289306640625}],[" For any ordered ring R, additive commutative group V, R-module V, and additive torsor V over P, the strict betweenness relation Sbtw on P is a symmetric relation.",{"type":"∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V]\n  [inst_3 : AddTorsor V P] {x y z : P}, Sbtw R x y z ↔ Sbtw R z y x","name":"sbtw_comm","isProp":true,"docString":" For any ordered ring R, additive commutative group V, R-module V, and additive torsor V over P, the strict betweenness relation Sbtw on P is a symmetric relation.","distance":0.502195372706228493342450747149996459484100341796875}],["This theorem states that for any types `R`, `V`, `P` where `R` is an ordered ring, `V` is an additive commutative group, `P` is an affine space over `V` with `R` as its scalar field, and `x`, `y`, `z` are points in this affine space, if `y` is strictly between `x` and `z` (according to the definition `Sbtw`), then `y` is also weakly between `x` and `z` (according to the definition `Wbtw`). In other words, the condition of a point being strictly between two other points implies the condition of the point being weakly between the same two points.",{"type":"∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V]\n  [inst_3 : AddTorsor V P] {x y z : P}, Sbtw R x y z → Wbtw R x y z","name":"Sbtw.wbtw","isProp":true,"docString":"This theorem states that for any types `R`, `V`, `P` where `R` is an ordered ring, `V` is an additive commutative group, `P` is an affine space over `V` with `R` as its scalar field, and `x`, `y`, `z` are points in this affine space, if `y` is strictly between `x` and `z` (according to the definition `Sbtw`), then `y` is also weakly between `x` and `z` (according to the definition `Wbtw`). In other words, the condition of a point being strictly between two other points implies the condition of the point being weakly between the same two points.","distance":0.483284744839172331065668686278513632714748382568359375}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.3637475694456033803447780883288942277431488037109375}],[" For any vector space V over a ring k and any torsor P over V, the difference between any two points in P lies in the vector span of {p₁, p₂}.",{"type":"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p₁ p₂ : P), p₁ -ᵥ p₂ ∈ vectorSpan k {p₁, p₂}","name":"vsub_mem_vectorSpan_pair","isProp":true,"docString":" For any vector space V over a ring k and any torsor P over V, the difference between any two points in P lies in the vector span of {p₁, p₂}.","distance":0.50759330686005210697686607090872712433338165283203125}],["This theorem states that in the context of a linear order, the properties of being well-founded (`Set.IsWF`) and being a partially well-ordered set (`Set.IsPWO`) are equivalent for a given set. A set is said to be well-founded if there is no infinite descending sequence of elements in it, and a set is said to be partially well-ordered if any infinite sequence from it contains an infinite monotonically increasing subsequence. Therefore, this theorem provides an equivalence between these two properties in the case of linearly ordered sets.",{"type":"∀ {α : Type u_2} [inst : LinearOrder α] {s : Set α}, s.IsWF ↔ s.IsPWO","name":"Set.isWF_iff_isPWO","isProp":true,"docString":"This theorem states that in the context of a linear order, the properties of being well-founded (`Set.IsWF`) and being a partially well-ordered set (`Set.IsPWO`) are equivalent for a given set. A set is said to be well-founded if there is no infinite descending sequence of elements in it, and a set is said to be partially well-ordered if any infinite sequence from it contains an infinite monotonically increasing subsequence. Therefore, this theorem provides an equivalence between these two properties in the case of linearly ordered sets.","distance":0.488447804027540899429737919490435160696506500244140625}],["The right arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.right ⟶ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inr","isProp":false,"docString":"The right arrow of the walking cospan. ","distance":0.365998187615489189994377738912589848041534423828125}],["The left arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.left ⟶ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inl","isProp":false,"docString":"The left arrow of the walking cospan. ","distance":0.36698771786785011617126883720629848539829254150390625}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.37145437211463272486611231215647421777248382568359375}],["The left arrow of the walking span. ",{"type":"CategoryTheory.Limits.WalkingSpan.zero ⟶ CategoryTheory.Limits.WalkingSpan.left","name":"CategoryTheory.Limits.WalkingSpan.Hom.fst","isProp":false,"docString":"The left arrow of the walking span. ","distance":0.371827742598955401920335361864999867975711822509765625}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.372860345677407389874957743813865818083286285400390625}],["lp space ",{"type":"Lean.ParserDescr","name":"lp.«termℓ^∞(_,_)»","isProp":false,"docString":"lp space ","distance":0.37486170157844045380812758594402112066745758056640625}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.37692390103509609833309923487831838428974151611328125}],["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.37720100578299009530525154332281090319156646728515625}],["The right arrow of the walking span. ",{"type":"CategoryTheory.Limits.WalkingSpan.zero ⟶ CategoryTheory.Limits.WalkingSpan.right","name":"CategoryTheory.Limits.WalkingSpan.Hom.snd","isProp":false,"docString":"The right arrow of the walking span. ","distance":0.37789036793189845209184341001673601567745208740234375}],["The conv widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"ConvSelectionPanel","isProp":false,"docString":"The conv widget. ","distance":0.378827297547761732143811741480021737515926361083984375}],["A choice of wide pushout. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (B : C) →\n        (objs : J → C) →\n          (arrows : (j : J) → B ⟶ objs j) → [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] → C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.379242714662569591066443308591260574758052825927734375}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.3802199495602776035951819721958599984645843505859375}],["The gcongr widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"GCongrSelectionPanel","isProp":false,"docString":"The gcongr widget. ","distance":0.382047232638397515902539680610061623156070709228515625}],["The head type ",{"type":"PFunctor.{u} → Type u","name":"PFunctor.A","isProp":false,"docString":"The head type ","distance":0.382614638829138986597655502919224090874195098876953125}],["The identity arrows of the walking cospan. ",{"type":"(X : CategoryTheory.Limits.WalkingCospan) → X ⟶ X","name":"CategoryTheory.Limits.WalkingCospan.Hom.id","isProp":false,"docString":"The identity arrows of the walking cospan. ","distance":0.3837460320477135145011970962514169514179229736328125}],["Lp space ",{"type":"{α : Type u_6} →\n  (E : Type u_5) →\n    {m : MeasurableSpace α} →\n      [inst : NormedAddCommGroup E] →\n        ENNReal → (μ : autoParam (MeasureTheory.Measure α) _auto✝) → AddSubgroup (α →ₘ[μ] E)","name":"MeasureTheory.Lp","isProp":false,"docString":"Lp space ","distance":0.3841983307214444920418827678076922893524169921875}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.38430583267326701157884372150874696671962738037109375}],["The calc widget. ",{"type":"ProofWidgets.Component CalcParams","name":"CalcPanel","isProp":false,"docString":"The calc widget. ","distance":0.387021348676792553700209964517853222787380218505859375}]]