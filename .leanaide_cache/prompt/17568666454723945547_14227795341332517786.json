[["The statement to be proved inductively ",{"type":"{F : Type u_1} ‚Üí\n  [inst : Field F] ‚Üí {E : Type u_2} ‚Üí [inst_1 : Field E] ‚Üí [inst_2 : Algebra F E] ‚Üí ‚Ü•(solvableByRad F E) ‚Üí Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.28693170344172946872873808388249017298221588134765625}],[" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.",{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {p : Finset (Finset Œ±) ‚Üí Prop} (ùíú : Finset (Finset Œ±)),\n  p ‚àÖ ‚Üí\n    p {‚àÖ} ‚Üí\n      (‚àÄ (a : Œ±) ‚¶Éùíú : Finset (Finset Œ±)‚¶Ñ, (‚àÄ s ‚àà ùíú, a ‚àâ s) ‚Üí p ùíú ‚Üí p (Finset.image (insert a) ùíú)) ‚Üí\n        (‚àÄ (a : Œ±) ‚¶Éùíú : Finset (Finset Œ±)‚¶Ñ,\n            p (Finset.filter (fun x => a ‚àâ x) ùíú) ‚Üí p (Finset.filter (fun x => a ‚àà x) ùíú) ‚Üí p ùíú) ‚Üí\n          p ùíú","name":"Finset.family_induction_on","isProp":true,"docString":" The theorem states that to prove a property for all families of finite sets, it suffices to verify it for the empty family, the family consisting only of the empty set, and show that if the property holds for families without a specific element and with that element in every set, then it holds for their union.","distance":0.419272269279067411051897806828492321074008941650390625}],["This theorem states that to prove the equality of two linear maps (`f` and `g`) from the exterior algebra of an `R`-module `M` to another `R`-module `N`, it is enough to demonstrate that these maps agree on the exterior powers of `M`. This is proven by showing that the composition of `f` and `g` with the same alternating map, generated by applying the canonical injection of `M` into the exterior algebra, produces identical results for all natural numbers `i`.",{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup N]\n  [inst_3 : Module R M] [inst_4 : Module R N] ‚¶Éf g : ExteriorAlgebra R M ‚Üí‚Çó[R] N‚¶Ñ,\n  (‚àÄ (i : ‚Ñï), f.compAlternatingMap (ExteriorAlgebra.ŒπMulti R i) = g.compAlternatingMap (ExteriorAlgebra.ŒπMulti R i)) ‚Üí\n    f = g","name":"ExteriorAlgebra.lhom_ext","isProp":true,"docString":"This theorem states that to prove the equality of two linear maps (`f` and `g`) from the exterior algebra of an `R`-module `M` to another `R`-module `N`, it is enough to demonstrate that these maps agree on the exterior powers of `M`. This is proven by showing that the composition of `f` and `g` with the same alternating map, generated by applying the canonical injection of `M` into the exterior algebra, produces identical results for all natural numbers `i`.","distance":0.39374727767923778376513155308202840387821197509765625}],["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    (F : CategoryTheory.Functor J MonCat) ‚Üí CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.292282291281709738495209194297785870730876922607421875}],[" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.",{"type":"‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {P : MvPolynomial œÉ R ‚Üí Prop} (p : MvPolynomial œÉ R),\n  (‚àÄ (u : œÉ ‚Üí‚ÇÄ ‚Ñï) (a : R), P ((MvPolynomial.monomial u) a)) ‚Üí (‚àÄ (p q : MvPolynomial œÉ R), P p ‚Üí P q ‚Üí P (p + q)) ‚Üí P p","name":"MvPolynomial.induction_on'","isProp":true,"docString":" To prove a property holds for any multivariate polynomial over a commutative semiring, it suffices to show that it holds for all monomials and is preserved under polynomial addition.","distance":0.42695818318735068164215817887452431023120880126953125}],["This theorem states that, for any two propositions `a` and `b`, the existence of a proof of `b` given a proof of `a` is equivalent to the conjunction of `a` and `b`. In other words, there exists a proof of `b` under the assumption that `a` is true if and only if both `a` and `b` are true.",{"type":"‚àÄ {Œ± : Sort u_1} {p : Œ± ‚Üí Prop}, (¬¨‚àÄ (x : Œ±), p x) = ‚àÉ x, ¬¨p x","name":"Mathlib.Data.Finset.Basic._auxLemma.144","isProp":true,"docString":"This theorem states that, for any two propositions `a` and `b`, the existence of a proof of `b` given a proof of `a` is equivalent to the conjunction of `a` and `b`. In other words, there exists a proof of `b` under the assumption that `a` is true if and only if both `a` and `b` are true.","distance":0.406378256647578928184572077952907420694828033447265625}],["The proof that is the limit cone ",{"type":"{J : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        {F : CategoryTheory.Functor J C} ‚Üí\n          (self : CategoryTheory.Limits.LimitCone F) ‚Üí CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.3004770962339537998531113771605305373668670654296875}],["The proof that it is the colimit cocone ",{"type":"{J : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        {F : CategoryTheory.Functor J C} ‚Üí\n          (self : CategoryTheory.Limits.ColimitCocone F) ‚Üí CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.30225148702559156976832355212536640465259552001953125}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        [inst_2 : CategoryTheory.IsConnected J] ‚Üí\n          {B : C} ‚Üí\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} ‚Üí\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} ‚Üí\n                CategoryTheory.Limits.IsLimit c ‚Üí\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.3121836324302886822579239378683269023895263671875}],["Proof of right inverse ",{"type":"‚àÄ {Œ± : Type u} [self : Rack Œ±] (x : Œ±), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse ","distance":0.32456111991989688991822049501934088766574859619140625}],["Proof of continuity of the Hom. ",{"type":"‚àÄ {A : Type u_2} {B : Type u_3} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun","name":"ContinuousMonoidHom.continuous_toFun","isProp":true,"docString":"Proof of continuity of the Hom. ","distance":0.32704703061303563860207077595987357199192047119140625}],["Proof of the continuity of the map. ",{"type":"‚àÄ {F : Type u_1} {A : outParam (Type u_7)} {B : outParam (Type u_8)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ‚áëf","name":"ContinuousMonoidHomClass.map_continuous","isProp":true,"docString":"Proof of the continuity of the map. ","distance":0.327428980769864319544382169624441303312778472900390625}],["Correspondence theorem ",{"type":"{R : Type u} ‚Üí\n  {S : Type v} ‚Üí\n    {F : Type u_1} ‚Üí\n      [inst : Ring R] ‚Üí\n        [inst_1 : Ring S] ‚Üí\n          [inst_2 : RingHomClass F R S] ‚Üí (f : F) ‚Üí Function.Surjective ‚áëf ‚Üí Ideal S ‚âÉo { p // Ideal.comap f ‚ä• ‚â§ p }","name":"Ideal.relIsoOfSurjective","isProp":false,"docString":"Correspondence theorem ","distance":0.331752543713991265850182799113099463284015655517578125}],["Compose two proofs by transitivity, generalized over the relations involved. ",{"type":"{Œ± : Sort u_1} ‚Üí\n  {Œ≤ : Sort u_2} ‚Üí\n    {Œ≥ : Sort u_3} ‚Üí\n      {r : Œ± ‚Üí Œ≤ ‚Üí Sort u} ‚Üí\n        {s : Œ≤ ‚Üí Œ≥ ‚Üí Sort v} ‚Üí\n          {t : outParam (Œ± ‚Üí Œ≥ ‚Üí Sort w)} ‚Üí [self : Trans r s t] ‚Üí {a : Œ±} ‚Üí {b : Œ≤} ‚Üí {c : Œ≥} ‚Üí r a b ‚Üí s b c ‚Üí t a c","name":"Trans.trans","isProp":false,"docString":"Compose two proofs by transitivity, generalized over the relations involved. ","distance":0.335251563620128589793267792629194445908069610595703125}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.33650833998138518499132487704628147184848785400390625}],["Proof of left inverse ",{"type":"‚àÄ {Œ± : Type u} [self : Rack Œ±] (x : Œ±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse ","distance":0.338585534412389421721201188120176084339618682861328125}],["To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B : C} {X Y : CategoryTheory.Subobject B}\n  (f : CategoryTheory.Subobject.underlying.obj X ‚âÖ CategoryTheory.Subobject.underlying.obj Y),\n  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.Subobject.arrow Y) = CategoryTheory.Subobject.arrow X ‚Üí X = Y","name":"CategoryTheory.Subobject.eq_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ","distance":0.344579655220515757019228431090596131980419158935546875}],["Shows that `fib` indeed satisfies the Fibonacci recurrence `F‚Çô‚Çä‚ÇÇ = F‚Çô + F‚Çô‚Çä‚ÇÅ.` ",{"type":"‚àÄ {n : ‚Ñï}, Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)","name":"Nat.fib_add_two","isProp":true,"docString":"Shows that `fib` indeed satisfies the Fibonacci recurrence `F‚Çô‚Çä‚ÇÇ = F‚Çô + F‚Çô‚Çä‚ÇÅ.` ","distance":0.344588166287197850135015642081270925700664520263671875}],["A convenient way to show that a binary cofan is a colimit. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí\n      (s : CategoryTheory.Limits.BinaryCofan X Y) ‚Üí\n        (desc : {T : C} ‚Üí (X ‚ü∂ T) ‚Üí (Y ‚ü∂ T) ‚Üí (s.pt ‚ü∂ T)) ‚Üí\n          (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) (desc f g) = f) ‚Üí\n            (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) (desc f g) = g) ‚Üí\n              (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (m : s.pt ‚ü∂ T),\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) m = f ‚Üí\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) m = g ‚Üí m = desc f g) ‚Üí\n                CategoryTheory.Limits.IsColimit s","name":"CategoryTheory.Limits.BinaryCofan.IsColimit.mk","isProp":false,"docString":"A convenient way to show that a binary cofan is a colimit. ","distance":0.345173522995179504757601307574077509343624114990234375}],["(Impl) Prove that the lifted cone is limiting. ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {T : CategoryTheory.Monad C} ‚Üí\n      {J : Type u} ‚Üí\n        [inst_1 : CategoryTheory.Category.{v, u} J] ‚Üí\n          (D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)) ‚Üí\n            (c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) ‚Üí\n              (t : CategoryTheory.Limits.IsLimit c) ‚Üí\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Monad.ForgetCreatesLimits.liftedCone D c t)","name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedConeIsLimit","isProp":false,"docString":"(Impl) Prove that the lifted cone is limiting. ","distance":0.34600002653016748155323512037284672260284423828125}],["(Impl) Prove that the lifted cocone is colimiting. ",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {T : CategoryTheory.Monad C} ‚Üí\n      {J : Type u} ‚Üí\n        [inst_1 : CategoryTheory.Category.{v, u} J] ‚Üí\n          {D : CategoryTheory.Functor J (CategoryTheory.Monad.Algebra T)} ‚Üí\n            (c : CategoryTheory.Limits.Cocone (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))) ‚Üí\n              (t : CategoryTheory.Limits.IsColimit c) ‚Üí\n                [inst_2 :\n                    CategoryTheory.Limits.PreservesColimit\n                      (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T)) T.toFunctor] ‚Üí\n                  [inst_3 :\n                      CategoryTheory.Limits.PreservesColimit\n                        (CategoryTheory.Functor.comp (CategoryTheory.Functor.comp D (CategoryTheory.Monad.forget T))\n                          T.toFunctor)\n                        T.toFunctor] ‚Üí\n                    CategoryTheory.Limits.IsColimit (CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone c t)","name":"CategoryTheory.Monad.ForgetCreatesColimits.liftedCoconeIsColimit","isProp":false,"docString":"(Impl) Prove that the lifted cocone is colimiting. ","distance":0.347479953176452471819146694542723707854747772216796875}],["Proof of type equality as an arrow ",{"type":"{n : ‚Ñï} ‚Üí\n  (P : MvPFunctor.{u} (n + 1)) ‚Üí\n    {a a' : P.A} ‚Üí a = a' ‚Üí TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) (MvPFunctor.B (MvPFunctor.drop P) a')","name":"MvPFunctor.castDropB","isProp":false,"docString":"Proof of type equality as an arrow ","distance":0.348249812629376431782901590850087814033031463623046875}],["Use the above equivalence to prove we have a limit. ",{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit","isProp":true,"docString":"Use the above equivalence to prove we have a limit. ","distance":0.3504319343535773345621464613941498100757598876953125}],["Shows that all denominators are nonnegative. ",{"type":"‚àÄ {K : Type u_1} {v : K} {n : ‚Ñï} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 ‚â§ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n","name":"GeneralizedContinuedFraction.zero_le_of_denom","isProp":true,"docString":"Shows that all denominators are nonnegative. ","distance":0.35080758274041079491922801025793887674808502197265625}]]