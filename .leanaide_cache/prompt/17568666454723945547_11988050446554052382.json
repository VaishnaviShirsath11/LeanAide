[["The program. ",{"type":"{Œì : Type u_1} ‚Üí\n  {Œõ : Type u_2} ‚Üí\n    [inst : Inhabited Œõ] ‚Üí Turing.TM0.Machine Œì Œõ ‚Üí Turing.TM0to1.Œõ' ‚Üí Turing.TM1.Stmt Œì Turing.TM0to1.Œõ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.3678487383257780241052614655927754938602447509765625}],[" The interior of a set is contained in its closure.",{"type":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X], interior s ‚äÜ closure s","name":"interior_subset_closure","isProp":true,"docString":" The interior of a set is contained in its closure.","distance":0.5138208078710475579242711319238878786563873291015625}],["This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] {A : Set E} {x : E}, x ‚àà Set.exposedPoints ùïú A ‚Üî IsExposed ùïú A {x}","name":"mem_exposedPoints_iff_exposed_singleton","isProp":true,"docString":"This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.","distance":0.4996444493003775466632987445336766541004180908203125}],["Show the equalizing cone is a limit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPullbacks C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerCone F)","name":"CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerConeIsLimit","isProp":false,"docString":"Show the equalizing cone is a limit ","distance":0.374626569513607010630806826156913302838802337646484375}],[" The sign of real number 0 is 0.",{"type":"Real.sign 0 = 0","name":"Real.sign_zero","isProp":true,"docString":" The sign of real number 0 is 0.","distance":0.521506076329659062906785038649104535579681396484375}],["This theorem states that in any category `C` with objects `Z`, `X`, `Y`, and `P`, and morphisms `f : Z ‚ü∂ X`, `g : Z ‚ü∂ Y`, `inl : X ‚ü∂ P`, and `inr : Y ‚ü∂ P`, if `f` and `inr` are isomorphisms and the diagram composed of these morphisms commutes, then the diagram is a pushout in the category. In category theory, a pushout is a kind of limit which can be thought of as a way of \"gluing\" objects together along a shared part.",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {Z X Y P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P}\n  {inr : Y ‚ü∂ P} [inst_1 : CategoryTheory.IsIso f] [inst_2 : CategoryTheory.IsIso inr],\n  CategoryTheory.CommSq f g inl inr ‚Üí CategoryTheory.IsPushout f g inl inr","name":"CategoryTheory.IsPushout.of_horiz_isIso","isProp":true,"docString":"This theorem states that in any category `C` with objects `Z`, `X`, `Y`, and `P`, and morphisms `f : Z ‚ü∂ X`, `g : Z ‚ü∂ Y`, `inl : X ‚ü∂ P`, and `inr : Y ‚ü∂ P`, if `f` and `inr` are isomorphisms and the diagram composed of these morphisms commutes, then the diagram is a pushout in the category. In category theory, a pushout is a kind of limit which can be thought of as a way of \"gluing\" objects together along a shared part.","distance":0.51221687191376952252852561286999844014644622802734375}],["an arrow ",{"type":"{V : Type u} ‚Üí [inst : Quiver V] ‚Üí (self : Quiver.Total V) ‚Üí self.left ‚ü∂ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.37803006211667267155718263893504627048969268798828125}],["Continuity ",{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M‚ÇÇ : outParam (Type u_5)} [inst_4 : TopologicalSpace M‚ÇÇ] [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M]\n  [inst_7 : Module S M‚ÇÇ] [self : ContinuousSemilinearMapClass F œÉ M M‚ÇÇ] (f : F), Continuous ‚áëf","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity ","distance":0.385380462404017354316465571173466742038726806640625}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.385970119909743447639272062588133849203586578369140625}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.386340101075123121265875170138315297663211822509765625}],["Expand the square ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] (x y : F),\n  ‚Äñx - y‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - 2 * ‚ü™x, y‚ü´_‚Ñù + ‚Äñy‚Äñ ^ 2","name":"norm_sub_sq_real","isProp":true,"docString":"Expand the square ","distance":0.38647801928883307454043460893444716930389404296875}],["Real part ",{"type":"UpperHalfPlane ‚Üí ‚Ñù","name":"UpperHalfPlane.re","isProp":false,"docString":"Real part ","distance":0.387049532128250717288864279908011667430400848388671875}],["The empty word ",{"type":"{G : Type u_1} ‚Üí\n  [inst : Group G] ‚Üí\n    {A B : Subgroup G} ‚Üí {d : HNNExtension.NormalWord.TransversalPair G A B} ‚Üí HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.3897278220234599022120391964563168585300445556640625}],["The empty finset ",{"type":"{Œ± : Type u_1} ‚Üí Finset Œ±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.3904515854373118433073841515579260885715484619140625}],["the first row ",{"type":"{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    [inst_1 : CategoryTheory.Abelian C] ‚Üí CategoryTheory.ShortComplex.SnakeInput C ‚Üí CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L‚ÇÅ","isProp":false,"docString":"the first row ","distance":0.391526510594216947680479279370047152042388916015625}],["All epis are split ",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [self : CategoryTheory.SplitEpiCategory C] {X Y : C}\n  (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Epi f], CategoryTheory.IsSplitEpi f","name":"CategoryTheory.SplitEpiCategory.isSplitEpi_of_epi","isProp":true,"docString":"All epis are split ","distance":0.39309779914575104786678139134892262518405914306640625}],["projection expression ",{"type":"Simps.ParsedProjectionData ‚Üí Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.393994638681012698810945948935113847255706787109375}],["The ground set ",{"type":"{Œ± : Type u_2} ‚Üí IndepMatroid Œ± ‚Üí Set Œ±","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.39620008603826295523475664595025591552257537841796875}],["A choice of wide pushout. ",{"type":"{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      (B : C) ‚Üí\n        (objs : J ‚Üí C) ‚Üí\n          (arrows : (j : J) ‚Üí B ‚ü∂ objs j) ‚Üí [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] ‚Üí C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.3973450465629777550446988243493251502513885498046875}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        [inst_2 : CategoryTheory.IsConnected J] ‚Üí\n          {B : C} ‚Üí\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} ‚Üí\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} ‚Üí\n                CategoryTheory.Limits.IsLimit c ‚Üí\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.3973468394934769332138557729194872081279754638671875}],["There is a splitting ",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.399114812243245131728741625920520164072513580322265625}],["The one of the ring ",{"type":"{d : ‚Ñ§} ‚Üí One (‚Ñ§‚àöd)","name":"Zsqrtd.instOneZsqrtd","isProp":false,"docString":"The one of the ring ","distance":0.3994690885049323458844128253986127674579620361328125}],["The empty pre-set ",{"type":"PSet","name":"PSet.empty","isProp":false,"docString":"The empty pre-set ","distance":0.401176320625155347077139822431490756571292877197265625}],["The lift. ",{"type":"{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    {A B X Y : C} ‚Üí\n      {f : A ‚ü∂ X} ‚Üí\n        {i : A ‚ü∂ B} ‚Üí\n          {p : X ‚ü∂ Y} ‚Üí\n            {g : B ‚ü∂ Y} ‚Üí {sq : CategoryTheory.CommSq f i p g} ‚Üí CategoryTheory.CommSq.LiftStruct sq ‚Üí (B ‚ü∂ X)","name":"CategoryTheory.CommSq.LiftStruct.l","isProp":false,"docString":"The lift. ","distance":0.401614000237885571120699523817165754735469818115234375}]]