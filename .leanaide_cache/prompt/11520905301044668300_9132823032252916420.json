[["Equivalence between the set of natural numbers which are `≥ k` and `ℕ`, given by `n → n - k`. ",{"type":"(k : ℕ) → { n // n ∉ Multiset.range k } ≃ ℕ","name":"notMemRangeEquiv","isProp":false,"docString":"Equivalence between the set of natural numbers which are `≥ k` and `ℕ`, given by `n → n - k`. ","distance":0.712478939798163679597564623691141605377197265625}],[" For all natural numbers `k`, `m`, and `n`, `k` divides `m` if and only if `k` divides `m + n`. (Or, equivalently, `k` | `m` ⇔ `k` | `(m + n)`.)",{"type":"∀ {k m n : ℕ}, k ∣ n → (k ∣ m ↔ k ∣ m + n)","name":"Nat.dvd_add_iff_left","isProp":true,"docString":" For all natural numbers `k`, `m`, and `n`, `k` divides `m` if and only if `k` divides `m + n`. (Or, equivalently, `k` | `m` ⇔ `k` | `(m + n)`.)","distance":0.587727157205831129971329573891125619411468505859375}],["This theorem states that for all natural numbers `k`, `m`, and `n`, if `k` divides `n`, then `k` divides `m` if and only if `k` divides `m + n`. In mathematical notation, this can be written as: ∀ k, m, n ∈ ℕ, if k | n, then k | m ⇔ k | (m + n).",{"type":"∀ {k m n : ℕ}, k ∣ n → (k ∣ m ↔ k ∣ m + n)","name":"Nat.dvd_add_iff_left","isProp":true,"docString":"This theorem states that for all natural numbers `k`, `m`, and `n`, if `k` divides `n`, then `k` divides `m` if and only if `k` divides `m + n`. In mathematical notation, this can be written as: ∀ k, m, n ∈ ℕ, if k | n, then k | m ⇔ k | (m + n).","distance":0.68673143867067409917837039756705053150653839111328125}],["If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\nfor some `k`. ",{"type":"∀ {n : ℤ} (m : ℤ), 0 < n → ((∃ k, n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m)","name":"Int.exists_lt_and_lt_iff_not_dvd","isProp":true,"docString":"If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\nfor some `k`. ","distance":0.73287305050320217247872278676368296146392822265625}],[" For all natural numbers `n` greater than zero and `k` greater than one, `n` > `k` > 0 implies `n` / `k` < `n`.",{"type":"∀ {n k : ℕ}, 0 < n → 1 < k → n / k < n","name":"Nat.div_lt_self","isProp":true,"docString":" For all natural numbers `n` greater than zero and `k` greater than one, `n` > `k` > 0 implies `n` / `k` < `n`.","distance":0.63712775581892377996240384163684211671352386474609375}],["This theorem states that for every pair of natural numbers `n` and `k`, if `n` is greater than zero and `k` is greater than one, then the integer division of `n` by `k` is less than `n`. In other words, dividing a positive natural number by another natural number greater than one results in a number which is less than the original number.",{"type":"∀ {n k : ℕ}, 0 < n → 1 < k → n / k < n","name":"Nat.div_lt_self","isProp":true,"docString":"This theorem states that for every pair of natural numbers `n` and `k`, if `n` is greater than zero and `k` is greater than one, then the integer division of `n` by `k` is less than `n`. In other words, dividing a positive natural number by another natural number greater than one results in a number which is less than the original number.","distance":0.71322154230463274959816999398753978312015533447265625}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.74328176937479717434342774140532128512859344482421875}],["`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ",{"type":"{n : ℕ} → Fin2 n → (k : ℕ) → Fin2 (n + k)","name":"Fin2.add","isProp":false,"docString":"`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ","distance":0.74662486263391281138268595896079204976558685302734375}],["If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n`\nthat are equal mod `k`. ",{"type":"∀ {s : Set ℕ}, s.Infinite → ∀ {k : ℕ}, 0 < k → ∃ m ∈ s, ∃ n ∈ s, m < n ∧ m ≡ n [MOD k]","name":"Nat.exists_lt_modEq_of_infinite","isProp":true,"docString":"If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n`\nthat are equal mod `k`. ","distance":0.780298663777941658992176598985679447650909423828125}],["We define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n",{"type":"ℕ+ → ℕ → ℕ → ℕ+ × ℕ","name":"PNat.modDivAux","isProp":false,"docString":"We define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n","distance":0.78622728148676090942359451219090260565280914306640625}],["We define `m % k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` This ensures that `m % k` is always positive.\n",{"type":"ℕ+ → ℕ+ → ℕ+","name":"PNat.mod","isProp":false,"docString":"We define `m % k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` This ensures that `m % k` is always positive.\n","distance":0.79179351078621940107638010886148549616336822509765625}],["If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ",{"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ","distance":0.7921546416256342038053617216064594686031341552734375}],["`(n + 1).ascFactorial k = (n + k) ! / n !` but without ℕ-division. See\n`Nat.ascFactorial_eq_div` for the version with ℕ-division. ",{"type":"∀ (n k : ℕ), n.factorial * (n + 1).ascFactorial k = (n + k).factorial","name":"Nat.factorial_mul_ascFactorial","isProp":true,"docString":"`(n + 1).ascFactorial k = (n + k) ! / n !` but without ℕ-division. See\n`Nat.ascFactorial_eq_div` for the version with ℕ-division. ","distance":0.80952394537711125366286069038324058055877685546875}],["`mod_div m k = (m % k, m / k)`.\nWe define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n",{"type":"ℕ+ → ℕ+ → ℕ+ × ℕ","name":"PNat.modDiv","isProp":false,"docString":"`mod_div m k = (m % k, m / k)`.\nWe define `m % k` and `m / k` in the same way as for `ℕ`\nexcept that when `m = n * k` we take `m % k = k` and\n`m / k = n - 1`.  This ensures that `m % k` is always positive\nand `m = (m % k) + k * (m / k)` in all cases.  Later we\ndefine a function `div_exact` which gives the usual `m / k`\nin the case where `k` divides `m`.\n","distance":0.8147054144445469159308004236663691699504852294921875}],["For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. ",{"type":"∀ {R : Type u_2} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n","name":"isLittleO_pow_const_const_pow_of_one_lt","isProp":true,"docString":"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. ","distance":0.8190630785411145975416502551524899899959564208984375}],["Multiplication modulo `n` ",{"type":"{n : ℕ} → Fin n → Fin n → Fin n","name":"Fin.mul","isProp":false,"docString":"Multiplication modulo `n` ","distance":0.8219092879723373101796823902986943721771240234375}],["`m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. ",{"type":"∀ {m n k : ℕ}, n * k < m → m < n * (k + 1) → ¬n ∣ m","name":"Nat.not_dvd_of_between_consec_multiples","isProp":true,"docString":"`m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. ","distance":0.82354669562484994482787215019925497472286224365234375}],["We have\n`cyclotomic n R = (X ^ k - 1) /ₘ (∏ i ∈ Nat.properDivisors k, cyclotomic i K)`. ",{"type":"∀ {R : Type u_1} [inst : CommRing R] {n : ℕ},\n  0 < n → Polynomial.cyclotomic n R = (Polynomial.X ^ n - 1) /ₘ ∏ i ∈ n.properDivisors, Polynomial.cyclotomic i R","name":"Polynomial.cyclotomic_eq_X_pow_sub_one_div","isProp":true,"docString":"We have\n`cyclotomic n R = (X ^ k - 1) /ₘ (∏ i ∈ Nat.properDivisors k, cyclotomic i K)`. ","distance":0.82688791146935491926939221229986287653446197509765625}],["A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.",{"type":"∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n","name":"Nat.dvd_add_self_left","isProp":true,"docString":"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.","distance":0.82788492390557977262943722962518222630023956298828125}],["If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. ",{"type":"∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0)","name":"tendsto_pow_const_mul_const_pow_of_abs_lt_one","isProp":true,"docString":"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. ","distance":0.833817383086120411661568141425959765911102294921875}],["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.83440938698398137152167919339262880384922027587890625}],["`n.descFactorial k = n! / (n - k)!` but without ℕ-division. See `Nat.descFactorial_eq_div`\nfor the version using ℕ-division. ",{"type":"∀ {n k : ℕ}, k ≤ n → (n - k).factorial * n.descFactorial k = n.factorial","name":"Nat.factorial_mul_descFactorial","isProp":true,"docString":"`n.descFactorial k = n! / (n - k)!` but without ℕ-division. See `Nat.descFactorial_eq_div`\nfor the version using ℕ-division. ","distance":0.83525132892864639710950314110959880053997039794921875}],["`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. ",{"type":"{R : Type u_1} → [inst : CommMonoidWithZero R] → R → Prop","name":"IsPrimePow","isProp":false,"docString":"`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. ","distance":0.838172643971371922333446491393260657787322998046875}],["We define `m / k` in the same way as for `ℕ` except that when `m = n * k` we take\n`m / k = n - 1`. This ensures that `m = (m % k) + k * (m / k)` in all cases. Later we\ndefine a function `div_exact` which gives the usual `m / k` in the case where `k` divides `m`.\n",{"type":"ℕ+ → ℕ+ → ℕ","name":"PNat.div","isProp":false,"docString":"We define `m / k` in the same way as for `ℕ` except that when `m = n * k` we take\n`m / k = n - 1`. This ensures that `m = (m % k) + k * (m / k)` in all cases. Later we\ndefine a function `div_exact` which gives the usual `m / k` in the case where `k` divides `m`.\n","distance":0.838790660080655836594587526633404195308685302734375}]]