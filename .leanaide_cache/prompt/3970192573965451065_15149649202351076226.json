[["If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ",{"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ","distance":0.63901350251167576832500571981654502451419830322265625}],[" For any natural numbers `m` and `n` with `m < n`, there exists a natural number `k` such that `n = m + k + 1`.",{"type":"∀ {m n : ℕ}, m < n → ∃ k, n = m + k + 1","name":"Nat.exists_eq_add_of_lt","isProp":true,"docString":" For any natural numbers `m` and `n` with `m < n`, there exists a natural number `k` such that `n = m + k + 1`.","distance":0.587986387988641556745506022707559168338775634765625}],["This theorem states that for any positive natural number `n` that is not equal to `1`, there exists another positive natural number `k` such that `n` is the successor of `k`. In other words, if a positive natural number is not `1`, then it can be expressed as `k + 1` for some positive natural number `k`.",{"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"This theorem states that for any positive natural number `n` that is not equal to `1`, there exists another positive natural number `k` such that `n` is the successor of `k`. In other words, if a positive natural number is not `1`, then it can be expressed as `k + 1` for some positive natural number `k`.","distance":0.6428889649426705599211118169478140771389007568359375}],[" For every positive natural number `n` different from `1`, there exists a natural number `k` such that `n = Suc(k)`. (Here, `Suc` denotes the successor function.)",{"value":null,"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","statement":"theorem PNat.exists_eq_succ_of_ne_one : ∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1 := by sorry","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ","description":"This theorem states that for any positive natural number `n` that is not equal to `1`, there exists another positive natural number `k` such that `n` is the successor of `k`. In other words, if a positive natural number is not `1`, then it can be expressed as `k + 1` for some positive natural number `k`.","concise-description":" For every positive natural number `n` different from `1`, there exists a natural number `k` such that `n = Suc(k)`. (Here, `Suc` denotes the successor function.)"}],["Equivalence between the set of natural numbers which are `≥ k` and `ℕ`, given by `n → n - k`. ",{"type":"(k : ℕ) → { n // n ∉ Multiset.range k } ≃ ℕ","name":"notMemRangeEquiv","isProp":false,"docString":"Equivalence between the set of natural numbers which are `≥ k` and `ℕ`, given by `n → n - k`. ","distance":0.713398541184185663865946480655111372470855712890625}],[" A natural number `n` is equivalent to being odd, as defined in Lean 4, if and only if `n` modulo 2 equals 1, which is equivalent to `n` being expressible as `2*k + 1` for some natural number `k`.",{"type":"∀ {n : ℕ}, Odd n ↔ n % 2 = 1","name":"Nat.odd_iff","isProp":true,"docString":" A natural number `n` is equivalent to being odd, as defined in Lean 4, if and only if `n` modulo 2 equals 1, which is equivalent to `n` being expressible as `2*k + 1` for some natural number `k`.","distance":0.60240852102002662160629142817924730479717254638671875}],["This theorem states that for any natural number `n` that is not zero, there exists another natural number `k` such that `n` is the successor of `k`. In other words, if you have a nonzero natural number, it must be one greater than another natural number.",{"type":"∀ {n : ℕ}, n ≠ 0 → ∃ k, n = k.succ","name":"Nat.exists_eq_succ_of_ne_zero","isProp":true,"docString":"This theorem states that for any natural number `n` that is not zero, there exists another natural number `k` such that `n` is the successor of `k`. In other words, if you have a nonzero natural number, it must be one greater than another natural number.","distance":0.70912050754657396378632938649388961493968963623046875}],[" For any natural number `n` and `k`, the prime factorization of `n` raised to the power of `k` is `k` times the prime factorization of `n`. Equivalently, the power of each prime `p` in the prime factorization of `n^k` is `k` times its power in the prime factorization of `n`.",{"value":null,"type":"∀ (n k : ℕ), (n ^ k).factorization = k • n.factorization","statement":"theorem Nat.factorization_pow : ∀ (n k : ℕ), (n ^ k).factorization = k • n.factorization := by sorry","name":"Nat.factorization_pow","isProp":true,"docString":"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` ","description":"This theorem states that for any natural numbers `n` and `k`, the prime factorization of `n` raised to the power of `k` is the same as `k` times the prime factorization of `n`. In other words, the multiplicity of each prime factor `p` in `n^k` is `k` times the multiplicity of `p` in `n`. This is equivalent to the mathematical statement that for any prime `p`, the power of `p` in the prime factorization of `n^k` is `k` times the power of `p` in the prime factorization of `n`.","concise-description":" For any natural number `n` and `k`, the prime factorization of `n` raised to the power of `k` is `k` times the prime factorization of `n`. Equivalently, the power of each prime `p` in the prime factorization of `n^k` is `k` times its power in the prime factorization of `n`."}],["For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. ",{"type":"∀ {R : Type u_2} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n","name":"isLittleO_pow_const_const_pow_of_one_lt","isProp":true,"docString":"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. ","distance":0.731372292142242752532865779357962310314178466796875}],[" For all natural numbers `k` and `n`, if `k > 0` then `n < n + k`.",{"type":"∀ {k n : ℕ}, 0 < k → n < n + k","name":"Nat.lt_add_of_pos_right","isProp":true,"docString":" For all natural numbers `k` and `n`, if `k > 0` then `n < n + k`.","distance":0.61261042120071007577308819236350245773792266845703125}],["This theorem states that for all natural numbers `n` and `k`, `n` is less than or equal to `n + k`. In mathematical terms, this theorem confirms that adding any natural number to another natural number results in a number that is either greater than or equal to the original number. It's an important foundational aspect of number theory and arithmetic.",{"type":"∀ (n k : ℕ), n ≤ n + k","name":"Nat.le_add_right","isProp":true,"docString":"This theorem states that for all natural numbers `n` and `k`, `n` is less than or equal to `n + k`. In mathematical terms, this theorem confirms that adding any natural number to another natural number results in a number that is either greater than or equal to the original number. It's an important foundational aspect of number theory and arithmetic.","distance":0.712652581313220512271300322026945650577545166015625}],["`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ",{"type":"{n : ℕ} → Fin2 n → (k : ℕ) → Fin2 (n + k)","name":"Fin2.add","isProp":false,"docString":"`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ","distance":0.75237452602099563758741851415834389626979827880859375}],[" For all natural numbers `k` and `n`, if `k > 0` then `n < k + n`.",{"type":"∀ {k n : ℕ}, 0 < k → n < k + n","name":"Nat.lt_add_of_pos_left","isProp":true,"docString":" For all natural numbers `k` and `n`, if `k > 0` then `n < k + n`.","distance":0.622958929545577522191024399944581091403961181640625}],["This theorem states that for any natural numbers `n`, `m`, and `k` where `n` is less than or equal to `m` and `m` is less than or equal to `k`, and any function `next` that takes a natural number `k` and a value of type `C k` and produces a value of type `C (k + 1)`, and any value `x` of type `C n`, the result of applying the function `Nat.leRecOn` (which recursively applies `next` starting with `x` until it reaches a certain natural number) to `n`, `m`, and `k` with `next` and `x` is equivalent to applying `Nat.leRecOn` to `m` and `k` with `next` and the result of applying `Nat.leRecOn` to `n` and `m` with `next` and `x`.",{"type":"∀ {C : ℕ → Sort u_1} {n m k : ℕ} (hnm : n ≤ m) (hmk : m ≤ k) {next : {k : ℕ} → C k → C (k + 1)} (x : C n),\n  Nat.leRecOn ⋯ next x = Nat.leRecOn hmk next (Nat.leRecOn hnm next x)","name":"Nat.leRecOn_trans","isProp":true,"docString":"This theorem states that for any natural numbers `n`, `m`, and `k` where `n` is less than or equal to `m` and `m` is less than or equal to `k`, and any function `next` that takes a natural number `k` and a value of type `C k` and produces a value of type `C (k + 1)`, and any value `x` of type `C n`, the result of applying the function `Nat.leRecOn` (which recursively applies `next` starting with `x` until it reaches a certain natural number) to `n`, `m`, and `k` with `next` and `x` is equivalent to applying `Nat.leRecOn` to `m` and `k` with `next` and the result of applying `Nat.leRecOn` to `n` and `m` with `next` and `x`.","distance":0.760703616882966837664525883155874907970428466796875}],["Multiplication by `(n + 1 : ℕ)` behaves as expected. ",{"type":"∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = AddMonoid.nsmul n x + x","name":"AddMonoid.nsmul_succ","isProp":true,"docString":"Multiplication by `(n + 1 : ℕ)` behaves as expected. ","distance":0.77644585000691723752908046662923879921436309814453125}],["Raising to the power `(n + 1 : ℕ)` behaves as expected. ",{"type":"∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (n : ℕ) (x : α),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = CanonicallyOrderedCommSemiring.npow n x * x","name":"CanonicallyOrderedCommSemiring.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ℕ)` behaves as expected. ","distance":0.78892598388110091178759830654598772525787353515625}],["`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. ",{"type":"{R : Type u_1} → [inst : CommMonoidWithZero R] → R → Prop","name":"IsPrimePow","isProp":false,"docString":"`n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be\nwritten as `p^k`. ","distance":0.80242302713670865532691323096514679491519927978515625}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.81441621033092681525289435739978216588497161865234375}]]