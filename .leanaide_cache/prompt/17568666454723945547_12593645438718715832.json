[["Show the equalizing cone is a limit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPullbacks C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerCone F)","name":"CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerConeIsLimit","isProp":false,"docString":"Show the equalizing cone is a limit ","distance":0.44295297790947241178827198382350616157054901123046875}],[" For all natural numbers n, n ‚â§ n.",{"type":"‚àÄ (n : ‚Ñï), n ‚â§ n","name":"Nat.le_refl","isProp":true,"docString":" For all natural numbers n, n ‚â§ n.","distance":0.55475550817927654634331702254712581634521484375}],["This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] {A : Set E} {x : E}, x ‚àà Set.exposedPoints ùïú A ‚Üî IsExposed ùïú A {x}","name":"mem_exposedPoints_iff_exposed_singleton","isProp":true,"docString":"This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.","distance":0.52266400257987621902344699265086092054843902587890625}],["Expand the square ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] (x y : F),\n  ‚Äñx - y‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - 2 * ‚ü™x, y‚ü´_‚Ñù + ‚Äñy‚Äñ ^ 2","name":"norm_sub_sq_real","isProp":true,"docString":"Expand the square ","distance":0.44351262174621430833809654359356500208377838134765625}],[" For all natural numbers n and m with m > 0, m^n ‚â• 1.",{"type":"‚àÄ (n m : ‚Ñï), 0 < m ‚Üí 1 ‚â§ m ^ n","name":"Nat.one_le_pow","isProp":true,"docString":" For all natural numbers n and m with m > 0, m^n ‚â• 1.","distance":0.55539828847758343499663169495761394500732421875}],["This theorem states that for any type `C` that forms a category, and any object `X` in that category, if `X` has an injective presentation, then the object `J` in that injective presentation is injective. In other words, if there is a monomorphism (an injective morphism) from `X` to `J`, then `J` is injective. This is typically used in category theory, a field of mathematics that deals with abstract algebraic structures and their relationships.",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X : C} (self : CategoryTheory.InjectivePresentation X),\n  CategoryTheory.Injective self.J","name":"CategoryTheory.InjectivePresentation.injective","isProp":true,"docString":"This theorem states that for any type `C` that forms a category, and any object `X` in that category, if `X` has an injective presentation, then the object `J` in that injective presentation is injective. In other words, if there is a monomorphism (an injective morphism) from `X` to `J`, then `J` is injective. This is typically used in category theory, a field of mathematics that deals with abstract algebraic structures and their relationships.","distance":0.53438029424044841686480822318117134273052215576171875}],["Action of a Shelf",{"type":"Lean.TrailingParserDescr","name":"Quandles.¬´term_‚óÉ_¬ª","isProp":false,"docString":"Action of a Shelf","distance":0.4451912069158783236133558602887205779552459716796875}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        [inst_2 : CategoryTheory.IsConnected J] ‚Üí\n          {B : C} ‚Üí\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} ‚Üí\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} ‚Üí\n                CategoryTheory.Limits.IsLimit c ‚Üí\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.44602051696567002192495010604034177958965301513671875}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.446996039349732920964441973410430364310741424560546875}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.449457195661022879118462469705264084041118621826171875}],["projection expression ",{"type":"Simps.ParsedProjectionData ‚Üí Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.457366096689446222089969751323224045336246490478515625}],["Print an ordinal notation ",{"type":"ONote ‚Üí String","name":"ONote.toString","isProp":false,"docString":"Print an ordinal notation ","distance":0.457822417144658821985814256549929268658161163330078125}],["The gcongr widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"GCongrSelectionPanel","isProp":false,"docString":"The gcongr widget. ","distance":0.460125313170252681072014411256532184779644012451171875}],["Name of the presenter to use. ",{"type":"ProofWidgets.GetExprPresentationParams ‚Üí Lean.Name","name":"ProofWidgets.GetExprPresentationParams.name","isProp":false,"docString":"Name of the presenter to use. ","distance":0.46437820124404216581837090416229330003261566162109375}],["The program. ",{"type":"{Œì : Type u_1} ‚Üí\n  {Œõ : Type u_2} ‚Üí\n    [inst : Inhabited Œõ] ‚Üí Turing.TM0.Machine Œì Œõ ‚Üí Turing.TM0to1.Œõ' ‚Üí Turing.TM1.Stmt Œì Turing.TM0to1.Œõ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.464511766440853290927037733126780949532985687255859375}],["A choice of wide pushout. ",{"type":"{J : Type w} ‚Üí\n  {C : Type u} ‚Üí\n    [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n      (B : C) ‚Üí\n        (objs : J ‚Üí C) ‚Üí\n          (arrows : (j : J) ‚Üí B ‚ü∂ objs j) ‚Üí [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] ‚Üí C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.464788576139149645083392670130706392228603363037109375}],["Shows that $(e^{X})^k = e^{kX}$. ",{"type":"‚àÄ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ‚Ñö A] (k : ‚Ñï),\n  PowerSeries.exp A ^ k = (PowerSeries.rescale ‚Üëk) (PowerSeries.exp A)","name":"PowerSeries.exp_pow_eq_rescale_exp","isProp":true,"docString":"Shows that $(e^{X})^k = e^{kX}$. ","distance":0.46495449860143855946859048344776965677738189697265625}],["The empty finset ",{"type":"{Œ± : Type u_1} ‚Üí Finset Œ±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.466662390026118256702858388962340541183948516845703125}],["the first row ",{"type":"{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    [inst_1 : CategoryTheory.Abelian C] ‚Üí CategoryTheory.ShortComplex.SnakeInput C ‚Üí CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L‚ÇÅ","isProp":false,"docString":"the first row ","distance":0.468314385544306210906739806887344457209110260009765625}],["The supremum of the principal segment ",{"type":"{Œ± : Type u_4} ‚Üí {Œ≤ : Type u_5} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚â∫i s ‚Üí Œ≤","name":"PrincipalSeg.top","isProp":false,"docString":"The supremum of the principal segment ","distance":0.468752491889143196868161567181232385337352752685546875}],["Show information about the alignment status of a lean 3 definition. ",{"type":"Lean.ParserDescr","name":"Mathlib.Prelude.Rename.lookup3","isProp":false,"docString":"Show information about the alignment status of a lean 3 definition. ","distance":0.46967997350136558853961332715698517858982086181640625}],["The basis of M. ",{"type":"{R : Type u_2} ‚Üí\n  [inst : CommRing R] ‚Üí\n    {M : Type u_3} ‚Üí\n      [inst_1 : AddCommGroup M] ‚Üí\n        [inst_2 : Module R M] ‚Üí\n          {N : Submodule R M} ‚Üí {Œπ : Type u_4} ‚Üí {n : ‚Ñï} ‚Üí Basis.SmithNormalForm N Œπ n ‚Üí Basis Œπ R M","name":"Basis.SmithNormalForm.bM","isProp":false,"docString":"The basis of M. ","distance":0.470443766841508459464193947496823966503143310546875}],["The (open) thickening is an open set. ",{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {E : Set Œ±}, IsOpen (Metric.thickening Œ¥ E)","name":"Metric.isOpen_thickening","isProp":true,"docString":"The (open) thickening is an open set. ","distance":0.4705811263926589216310958363465033471584320068359375}],["Supremum of a set ",{"type":"{Œ± : Type u_9} ‚Üí [self : SupSet Œ±] ‚Üí Set Œ± ‚Üí Œ±","name":"SupSet.sSup","isProp":false,"docString":"Supremum of a set ","distance":0.47167587789605558423744469109806232154369354248046875}]]