[["Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑k ^ p * (algebraMap ℚ A) (↑(Nat.factorial p))⁻¹","name":"PowerSeries.exp_pow_sum","isProp":true,"docString":"Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. ","distance":0.28117298841647386797859553553280420601367950439453125}],[" For any multiplicative function $f$ with $f(1) = 1$ and natural number $n \\neq 0$, $f(n) = \\prod\\_{p \\mid n} f(p)^{k\\_p}$, where $p$ ranges over prime factors of $n$ and $k\\_p$ is their multiplicity. Given $f(x) = f(y)$ for coprime $x, y$, this expression holds.",{"type":"∀ {β : Type u_1} [inst : CommMonoid β] (f : ℕ → β),\n  (∀ (x y : ℕ), x.Coprime y → f (x * y) = f x * f y) →\n    f 1 = 1 → ∀ {n : ℕ}, n ≠ 0 → f n = n.factorization.prod fun p k => f (p ^ k)","name":"Nat.multiplicative_factorization","isProp":true,"docString":" For any multiplicative function $f$ with $f(1) = 1$ and natural number $n \\neq 0$, $f(n) = \\prod\\_{p \\mid n} f(p)^{k\\_p}$, where $p$ ranges over prime factors of $n$ and $k\\_p$ is their multiplicity. Given $f(x) = f(y)$ for coprime $x, y$, this expression holds.","distance":0.314194045919304276726080615844693966209888458251953125}],["This theorem states that for any two given integers `n₁` and `n₂`, the power of negative one to the sum of these integers is equal to the product of the power of negative one to `n₁` and the power of negative one to `n₂`. In mathematical terms, this theorem establishes that $(-1)^{n₁ + n₂} = (-1)^{n₁} * (-1)^{n₂}$.",{"type":"∀ (n₁ n₂ : ℤ), (n₁ + n₂).negOnePow = n₁.negOnePow * n₂.negOnePow","name":"Int.negOnePow_add","isProp":true,"docString":"This theorem states that for any two given integers `n₁` and `n₂`, the power of negative one to the sum of these integers is equal to the product of the power of negative one to `n₁` and the power of negative one to `n₂`. In mathematical terms, this theorem establishes that $(-1)^{n₁ + n₂} = (-1)^{n₁} * (-1)^{n₂}$.","distance":0.306960220557628671311789503306499682366847991943359375}],["Multiplication by `n` is a polynomial function. ",{"type":"∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ), WittVector.IsPoly p fun R _Rcr x => x * ↑n","name":"WittVector.mulN_isPoly","isProp":true,"docString":"Multiplication by `n` is a polynomial function. ","distance":0.313974714755496042695170899605727754533290863037109375}],[" For any additive commutative group M and function f from natural numbers to M, the sum of f(i) from i=0 to n+1, minus the sum of f(i) from i=0 to n, equals f(n). In symbols, $\\sum\\_{i=0}^{n+1} f(i) - \\sum\\_{i=0}^{n} f(i) = f(n)$.",{"type":"∀ {M : Type u_3} (f : ℕ → M) {n : ℕ} [inst : AddCommGroup M],\n  (((Finset.range (n + 1)).sum fun i => f i) - (Finset.range n).sum fun i => f i) = f n","name":"Finset.sum_range_succ_sub_sum","isProp":true,"docString":" For any additive commutative group M and function f from natural numbers to M, the sum of f(i) from i=0 to n+1, minus the sum of f(i) from i=0 to n, equals f(n). In symbols, $\\sum\\_{i=0}^{n+1} f(i) - \\sum\\_{i=0}^{n} f(i) = f(n)$.","distance":0.324221504632756618580202712109894491732120513916015625}],["This theorem states that for any type `R` that is a non-associative semiring and any function `f` from two natural numbers to `R`, the sum of the product of the binomial coefficient \"n+1 choose i\" and `f(i, n+1-i)` over all natural numbers less than `n+2` is equal to the sum of two separate sums over all natural numbers less than `n+1`. The first sum is the product of the binomial coefficient \"n choose i\" and `f(i, n+1-i)`, and the second sum is the product of the binomial coefficient \"n choose i\" and `f(i+1, n-i)`. This means that you can split a sum that goes up to `n+2` into two sums that go up to `n+1` with slightly modified terms.",{"type":"∀ {R : Type u_3} [inst : NonAssocSemiring R] (f : ℕ → ℕ → R) (n : ℕ),\n  ((Finset.range (n + 2)).sum fun i => ↑((n + 1).choose i) * f i (n + 1 - i)) =\n    ((Finset.range (n + 1)).sum fun i => ↑(n.choose i) * f i (n + 1 - i)) +\n      (Finset.range (n + 1)).sum fun i => ↑(n.choose i) * f (i + 1) (n - i)","name":"Finset.sum_choose_succ_mul","isProp":true,"docString":"This theorem states that for any type `R` that is a non-associative semiring and any function `f` from two natural numbers to `R`, the sum of the product of the binomial coefficient \"n+1 choose i\" and `f(i, n+1-i)` over all natural numbers less than `n+2` is equal to the sum of two separate sums over all natural numbers less than `n+1`. The first sum is the product of the binomial coefficient \"n choose i\" and `f(i, n+1-i)`, and the second sum is the product of the binomial coefficient \"n choose i\" and `f(i+1, n-i)`. This means that you can split a sum that goes up to `n+2` into two sums that go up to `n+1` with slightly modified terms.","distance":0.314327358151960112309097894467413425445556640625}],["The map $n \\mapsto \\prod_{p \\mid n} f(p)$ as an arithmetic function ",{"type":"{R : Type u_1} → [inst : CommMonoidWithZero R] → (ℕ → R) → Nat.ArithmeticFunction R","name":"Nat.ArithmeticFunction.prodPrimeFactors","isProp":false,"docString":"The map $n \\mapsto \\prod_{p \\mid n} f(p)$ as an arithmetic function ","distance":0.314343878438369805916607901963288895785808563232421875}],["Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  (PowerSeries.rescale a) (PowerSeries.exp A) * (PowerSeries.rescale b) (PowerSeries.exp A) =\n    (PowerSeries.rescale (a + b)) (PowerSeries.exp A)","name":"PowerSeries.exp_mul_exp_eq_exp_add","isProp":true,"docString":"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ ","distance":0.31948720071028391398471057982533238828182220458984375}],["Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` ",{"type":"∀ {n : ℕ}, Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)","name":"Nat.fib_add_two","isProp":true,"docString":"Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.` ","distance":0.3199084673087491115239799910341389477252960205078125}],["The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\n  (PowerSeries.mk fun n => (Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * (PowerSeries.rescale t) (PowerSeries.exp A)","name":"Polynomial.bernoulli_generating_function","isProp":true,"docString":"The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ ","distance":0.321529507948164650077416126805474050343036651611328125}],["The sum of `(n+1).choose i * f i (n+1-i)` can be split into two sums at rank `n`,\nrespectively of `n.choose i * f i (n+1-i)` and `n.choose i * f (i+1) (n-i)`. ",{"type":"∀ {R : Type u_3} [inst : NonAssocSemiring R] (f : ℕ → ℕ → R) (n : ℕ),\n  (Finset.sum (Finset.range (n + 2)) fun i => ↑(Nat.choose (n + 1) i) * f i (n + 1 - i)) =\n    (Finset.sum (Finset.range (n + 1)) fun i => ↑(Nat.choose n i) * f i (n + 1 - i)) +\n      Finset.sum (Finset.range (n + 1)) fun i => ↑(Nat.choose n i) * f (i + 1) (n - i)","name":"Finset.sum_choose_succ_mul","isProp":true,"docString":"The sum of `(n+1).choose i * f i (n+1-i)` can be split into two sums at rank `n`,\nrespectively of `n.choose i * f i (n+1-i)` and `n.choose i * f (i+1) (n-i)`. ","distance":0.323765651382028118998590571209206245839595794677734375}],["The Bernoulli numbers:\nthe $n$-th Bernoulli number $B_n$ is defined recursively via\n$$B_n = 1 - \\sum_{k < n} \\binom{n}{k}\\frac{B_k}{n+1-k}$$ ",{"type":"ℕ → ℚ","name":"bernoulli'","isProp":false,"docString":"The Bernoulli numbers:\nthe $n$-th Bernoulli number $B_n$ is defined recursively via\n$$B_n = 1 - \\sum_{k < n} \\binom{n}{k}\\frac{B_k}{n+1-k}$$ ","distance":0.3250917307146032886322473132167942821979522705078125}],["The multiplicity of `p` in `(p * n)!` is `n` more than that of `n!`. ",{"type":"∀ {n p : ℕ}, Nat.Prime p → multiplicity p (Nat.factorial (p * n)) = multiplicity p (Nat.factorial n) + ↑n","name":"Nat.Prime.multiplicity_factorial_mul","isProp":true,"docString":"The multiplicity of `p` in `(p * n)!` is `n` more than that of `n!`. ","distance":0.327201868613639479388410791216301731765270233154296875}],["Shows that $e^{x} * e^{-x} = 1$ ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * PowerSeries.evalNegHom (PowerSeries.exp A) = 1","name":"PowerSeries.exp_mul_exp_neg_eq_one","isProp":true,"docString":"Shows that $e^{x} * e^{-x} = 1$ ","distance":0.32757555007412830772040024385205470025539398193359375}],["`∏ i, (f i + g i) = (∏ i, f i) + ∑ i, g i * (∏ j < i, f j + g j) * (∏ j > i, f j)`. ",{"type":"∀ {ι : Type u_1} {α : Type u_2} [inst : LinearOrder ι] [inst_1 : CommSemiring α] (s : Finset ι) (f g : ι → α),\n  (Finset.prod s fun i => f i + g i) =\n    (Finset.prod s fun i => f i) +\n      Finset.sum s fun i =>\n        (g i * Finset.prod (Finset.filter (fun x => x < i) s) fun j => f j + g j) *\n          Finset.prod (Finset.filter (fun j => i < j) s) fun j => f j","name":"Finset.prod_add_ordered","isProp":true,"docString":"`∏ i, (f i + g i) = (∏ i, f i) + ∑ i, g i * (∏ j < i, f j + g j) * (∏ j > i, f j)`. ","distance":0.32877973851023456486331042469828389585018157958984375}],["The conjugate exponent of `p` is `q = p/(p-1)`, so that `1/p + 1/q = 1`. ",{"type":"ℝ → ℝ","name":"Real.conjugateExponent","isProp":false,"docString":"The conjugate exponent of `p` is `q = p/(p-1)`, so that `1/p + 1/q = 1`. ","distance":0.332631705704871605266959022628725506365299224853515625}],["Given `P 0`, `P 1`, and `P (p ^ n)` for positive prime powers, and a way to extend `P a` and\n`P b` to `P (a * b)` when `a, b` are positive coprime, we can define `P` for all natural numbers. ",{"type":"{P : ℕ → Sort u_1} →\n  ((p n : ℕ) → Nat.Prime p → 0 < n → P (p ^ n)) →\n    P 0 → P 1 → ((a b : ℕ) → 1 < a → 1 < b → Nat.Coprime a b → P a → P b → P (a * b)) → (a : ℕ) → P a","name":"Nat.recOnPosPrimePosCoprime","isProp":false,"docString":"Given `P 0`, `P 1`, and `P (p ^ n)` for positive prime powers, and a way to extend `P a` and\n`P b` to `P (a * b)` when `a, b` are positive coprime, we can define `P` for all natural numbers. ","distance":0.333178352760397478160570017280406318604946136474609375}],["The recurrence relation satisfied by the Fibonacci sequence. ",{"type":"{α : Type u_1} → [inst : CommSemiring α] → LinearRecurrence α","name":"fibRec","isProp":false,"docString":"The recurrence relation satisfied by the Fibonacci sequence. ","distance":0.33388401336033390887081395703717134892940521240234375}],["Given `P 0`, `P (p ^ n)` for all prime powers, and a way to extend `P a` and `P b` to\n`P (a * b)` when `a, b` are positive coprime, we can define `P` for all natural numbers. ",{"type":"{P : ℕ → Sort u_1} →\n  P 0 →\n    ((p n : ℕ) → Nat.Prime p → P (p ^ n)) →\n      ((a b : ℕ) → 1 < a → 1 < b → Nat.Coprime a b → P a → P b → P (a * b)) → (a : ℕ) → P a","name":"Nat.recOnPrimeCoprime","isProp":false,"docString":"Given `P 0`, `P (p ^ n)` for all prime powers, and a way to extend `P a` and `P b` to\n`P (a * b)` when `a, b` are positive coprime, we can define `P` for all natural numbers. ","distance":0.335446472237519055514809451779001392424106597900390625}],["Multiplication by positive integers is injective ",{"type":"∀ {R : Type u_1} [inst : Semiring R] [self : BinomialRing R] (n : ℕ), n ≠ 0 → Function.Injective fun x => n • x","name":"BinomialRing.nsmul_right_injective","isProp":true,"docString":"Multiplication by positive integers is injective ","distance":0.336672263294200913019693643946084193885326385498046875}],["The `p`-adic valuation of `(p * n)!` is `n` more than that of `n!`. ",{"type":"∀ {p : ℕ} (n : ℕ) [hp : Fact (Nat.Prime p)], padicValNat p (Nat.factorial (p * n)) = padicValNat p (Nat.factorial n) + n","name":"padicValNat_factorial_mul","isProp":true,"docString":"The `p`-adic valuation of `(p * n)!` is `n` more than that of `n!`. ","distance":0.33718051029798512541191257696482352912425994873046875}],["The function `n ↦ x log n + log n! - (log x + ... + log (x + n))`, which we will show tends to\n`log (Gamma x)` as `n → ∞`. ",{"type":"ℝ → ℕ → ℝ","name":"Real.BohrMollerup.logGammaSeq","isProp":false,"docString":"The function `n ↦ x log n + log n! - (log x + ... + log (x + n))`, which we will show tends to\n`log (Gamma x)` as `n → ∞`. ","distance":0.3431874727985666506668849251582287251949310302734375}],["The multiplicity of `p` in `(p * (n + 1))!` is one more than the sum\nof the multiplicities of `p` in `(p * n)!` and `n + 1`. ",{"type":"∀ {n p : ℕ},\n  Nat.Prime p →\n    multiplicity p (Nat.factorial (p * (n + 1))) = multiplicity p (Nat.factorial (p * n)) + multiplicity p (n + 1) + 1","name":"Nat.Prime.multiplicity_factorial_mul_succ","isProp":true,"docString":"The multiplicity of `p` in `(p * (n + 1))!` is one more than the sum\nof the multiplicities of `p` in `(p * n)!` and `n + 1`. ","distance":0.343854070903326036745539795447257347404956817626953125}],["factorial notation `n!` ",{"type":"Lean.TrailingParserDescr","name":"Nat.term_!","isProp":false,"docString":"factorial notation `n!` ","distance":0.344782771588966696629796615525265224277973175048828125}]]