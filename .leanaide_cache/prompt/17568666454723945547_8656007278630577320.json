[["This is (-)^A. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (A : C) →\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] →\n        [inst_2 : CategoryTheory.Exponentiable A] → CategoryTheory.Functor C C","name":"CategoryTheory.exp","isProp":false,"docString":"This is (-)^A. ","distance":0.347020473720732580691361590652377344667911529541015625}],[" If $A$ is a subset of $B$ and $B$ is not a subset of $A$, then $A$ is a proper subset of $B$.",{"type":"∀ {α : Type u} [inst : HasSubset α] [inst_1 : HasSSubset α]\n  [inst_2 : IsNonstrictStrictOrder α (fun x x_1 => x ⊆ x_1) fun x x_1 => x ⊂ x_1] {a b : α}, a ⊆ b → ¬b ⊆ a → a ⊂ b","name":"HasSubset.Subset.ssubset_of_not_subset","isProp":true,"docString":" If $A$ is a subset of $B$ and $B$ is not a subset of $A$, then $A$ is a proper subset of $B$.","distance":0.461154544453339365617239309358410537242889404296875}],["This theorem states that, given a measurable space and a real-valued function that is integrable over a measure on this space, the integral of the function truncated to the interval `(-A, A]` converges to the integral of the entire function as `A` approaches infinity. In other words, if we consider progressively larger and larger intervals to compute the integral of our function, the result of these computations will tend to the true value of the integral of the function over the entire space.",{"type":"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ},\n  MeasureTheory.Integrable f μ →\n    Filter.Tendsto (fun A => ∫ (x : α), ProbabilityTheory.truncation f A x ∂μ) Filter.atTop (nhds (∫ (x : α), f x ∂μ))","name":"ProbabilityTheory.tendsto_integral_truncation","isProp":true,"docString":"This theorem states that, given a measurable space and a real-valued function that is integrable over a measure on this space, the integral of the function truncated to the interval `(-A, A]` converges to the integral of the entire function as `A` approaches infinity. In other words, if we consider progressively larger and larger intervals to compute the integral of our function, the result of these computations will tend to the true value of the integral of the function over the entire space.","distance":0.45892608320159788970471481661661528050899505615234375}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.376326959876648270419963182575884275138378143310546875}],[" The biconditional relation \"a ↔ b\" is an equivalence relation and is therefore commutative.",{"type":"∀ {a b : Prop}, (a ↔ b) ↔ (b ↔ a)","name":"Iff.comm","isProp":true,"docString":" The biconditional relation \"a ↔ b\" is an equivalence relation and is therefore commutative.","distance":0.474498015860803368237696986398077569901943206787109375}],["This theorem states that for any proposition 'a', the biconditional (a ↔ True) is equivalent to the proposition 'a' itself. In plain words, it means that if 'a' is equivalent to 'True', then 'a' must be true, and vice versa. This theorem hence acts like a bridge between the logical equivalence to 'True' and the truth of a proposition.",{"type":"∀ {a : Prop}, (a ↔ True) ↔ a","name":"iff_true_iff","isProp":true,"docString":"This theorem states that for any proposition 'a', the biconditional (a ↔ True) is equivalent to the proposition 'a' itself. In plain words, it means that if 'a' is equivalent to 'True', then 'a' must be true, and vice versa. This theorem hence acts like a bridge between the logical equivalence to 'True' and the truth of a proposition.","distance":0.461355076620142245946709635973093099892139434814453125}],["The basis of M. ",{"type":"{R : Type u_2} →\n  [inst : CommRing R] →\n    {M : Type u_3} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          {N : Submodule R M} → {ι : Type u_4} → {n : ℕ} → Basis.SmithNormalForm N ι n → Basis ι R M","name":"Basis.SmithNormalForm.bM","isProp":false,"docString":"The basis of M. ","distance":0.37657388982759021356372386435396037995815277099609375}],["A (bundled) uniform space. ",{"type":"Type (u + 1)","name":"UniformSpaceCat","isProp":false,"docString":"A (bundled) uniform space. ","distance":0.38283364229774508036285851630964316427707672119140625}],["Exactly one of the following is true (although we don't prove this here). ",{"type":"∀ (x y : SetTheory.PGame), x < y ∨ x ≈ y ∨ y < x ∨ SetTheory.PGame.Fuzzy x y","name":"SetTheory.PGame.lt_or_equiv_or_gt_or_fuzzy","isProp":true,"docString":"Exactly one of the following is true (although we don't prove this here). ","distance":0.384979530218067356184263871909934096038341522216796875}],["The b's are less than 1 ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → ∀ (i : α), b i < 1","name":"AkraBazziRecurrence.b_lt_one","isProp":true,"docString":"The b's are less than 1 ","distance":0.38599984497778738745665805254247970879077911376953125}],["The `a`'s are nonzero ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → ∀ (i : α), 0 < a i","name":"AkraBazziRecurrence.a_pos","isProp":true,"docString":"The `a`'s are nonzero ","distance":0.386426984640216353295016915581072680652141571044921875}],["The relation itself. ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.CategoryStruct.comp self.g₁ self.f₁ = CategoryTheory.CategoryStruct.comp self.g₂ self.f₂","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.w","isProp":true,"docString":"The relation itself. ","distance":0.3922463989015672058968675628420896828174591064453125}],["The supremum of the partition is `a` ",{"type":"∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a), Finset.sup self.parts id = a","name":"Finpartition.supParts","isProp":true,"docString":"The supremum of the partition is `a` ","distance":0.3934499618300757450839455486857332289218902587890625}],["The initial state. ",{"type":"Mathlib.Notation3.MatchState","name":"Mathlib.Notation3.MatchState.empty","isProp":false,"docString":"The initial state. ","distance":0.393506435865928205775077231010072864592075347900390625}],["`a` is between `a` and `a`. ",{"type":"∀ {α : Type u_1} [self : CircularPreorder α] (a : α), btw a a a","name":"CircularPreorder.btw_refl","isProp":true,"docString":"`a` is between `a` and `a`. ","distance":0.395023021079184577519782806120929308235645294189453125}],["The positive part function. ",{"type":"Lean.TrailingParserDescr","name":"«term_⁺»","isProp":false,"docString":"The positive part function. ","distance":0.395271817652043611079903939753421582281589508056640625}],["The basis of N. ",{"type":"{R : Type u_2} →\n  [inst : CommRing R] →\n    {M : Type u_3} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          {N : Submodule R M} → {ι : Type u_4} → {n : ℕ} → Basis.SmithNormalForm N ι n → Basis (Fin n) R ↥N","name":"Basis.SmithNormalForm.bN","isProp":false,"docString":"The basis of N. ","distance":0.3954933626297656434900318345171399414539337158203125}],["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.39582076018007328332970473638852126896381378173828125}],["The element of G ",{"type":"{N : Type u_1} → {G : Type u_2} → [inst : Group N] → [inst_1 : Group G] → {φ : G →* MulAut N} → N ⋊[φ] G → G","name":"SemidirectProduct.right","isProp":false,"docString":"The element of G ","distance":0.397745177739917965542559841196634806692600250244140625}],["Arity of the function ",{"type":"{D : Type u_1} →\n  {C : Type u_2} → [inst : OrderedAddCommMonoid C] → {Γ : ValuedCSP D C} → {ι : Type u_3} → ValuedCSP.Term Γ ι → ℕ","name":"ValuedCSP.Term.n","isProp":false,"docString":"Arity of the function ","distance":0.397849772283830116492708839359693229198455810546875}],["The addition rule. ",{"type":"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (self : Projectivization.Subspace K V) (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) (hvw : v + w ≠ 0),\n  Projectivization.mk K v hv ∈ self.carrier →\n    Projectivization.mk K w hw ∈ self.carrier → Projectivization.mk K (v + w) hvw ∈ self.carrier","name":"Projectivization.Subspace.mem_add'","isProp":true,"docString":"The addition rule. ","distance":0.398515760004047925324499601629213429987430572509765625}],["an auxiliary type ",{"type":"{I₁ : Type u_6} →\n  {I₂ : Type u_7} →\n    {I₃ : Type u_8} →\n      {J : Type u_9} → {r : I₁ × I₂ × I₃ → J} → CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r → Type u_10","name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.I₁₂","isProp":false,"docString":"an auxiliary type ","distance":0.398655072397615273249726897120126523077487945556640625}],["the axiom of choice ",{"type":"∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)","name":"Classical.axiomOfChoice","isProp":true,"docString":"the axiom of choice ","distance":0.399287395886121831978243790217675268650054931640625}],["We can shrink `A` to any smaller size. ",{"type":"∀ {α : Type u_1} (A : Finset α), ∀ i ≤ A.card, ∃ B ⊆ A, B.card = i","name":"Finset.exists_smaller_set","isProp":true,"docString":"We can shrink `A` to any smaller size. ","distance":0.399860843038482960398738441654131747782230377197265625}]]