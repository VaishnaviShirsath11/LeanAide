[["Show the equalizing cone is a limit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPullbacks C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerCone F)","name":"CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerConeIsLimit","isProp":false,"docString":"Show the equalizing cone is a limit ","distance":0.41874517095225993745799542011809535324573516845703125}],[" For any category J, any category C with colimits of shape J, and any functors F and G from J to C with a natural transformation Œ± from F to G, the diagram commutes, where the horizontal arrows are the coprojections and the vertical arrows are the maps induced by Œ± and the coprojections to the colimits.",{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]\n  {F : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasColimitsOfShape J C]\n  {G : CategoryTheory.Functor J C} (Œ± : F ‚ü∂ G) (j : J),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F j) (CategoryTheory.Limits.colim.map Œ±) =\n    CategoryTheory.CategoryStruct.comp (Œ±.app j) (CategoryTheory.Limits.colimit.Œπ G j)","name":"CategoryTheory.Limits.colimit.Œπ_map","isProp":true,"docString":" For any category J, any category C with colimits of shape J, and any functors F and G from J to C with a natural transformation Œ± from F to G, the diagram commutes, where the horizontal arrows are the coprojections and the vertical arrows are the maps induced by Œ± and the coprojections to the colimits.","distance":0.54542429944915837847219108880381099879741668701171875}],["This theorem states that the negation of 'False' is 'True'. In the context of boolean logic, where '¬¨' represents the logical 'not' operation, this theorem asserts the fundamental law that 'not False' equates to 'True'.",{"type":"(¬¨False) = True","name":"Mathlib.Topology.Instances.ENNReal._auxLemma.22","isProp":true,"docString":"This theorem states that the negation of 'False' is 'True'. In the context of boolean logic, where '¬¨' represents the logical 'not' operation, this theorem asserts the fundamental law that 'not False' equates to 'True'.","distance":0.5060432820688502975059464006335474550724029541015625}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} ‚Üí\n  [inst : CategoryTheory.SmallCategory J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        [inst_2 : CategoryTheory.IsConnected J] ‚Üí\n          {B : C} ‚Üí\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} ‚Üí\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} ‚Üí\n                CategoryTheory.Limits.IsLimit c ‚Üí\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.4233644430765146626782780003850348293781280517578125}],[" The theorem asserts that the negation of False is True. In mathematical notation, ¬¨False = True.",{"type":"(¬¨False) = True","name":"Mathlib.Logic.Equiv.Basic._auxLemma.2","isProp":true,"docString":" The theorem asserts that the negation of False is True. In mathematical notation, ¬¨False = True.","distance":0.54736759905367515788299215273582376539707183837890625}],["This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] {A : Set E} {x : E}, x ‚àà Set.exposedPoints ùïú A ‚Üî IsExposed ùïú A {x}","name":"mem_exposedPoints_iff_exposed_singleton","isProp":true,"docString":"This theorem states that for any topological space 'ùïú', ordered ring 'ùïú', additive commutative monoid 'E', topological space 'E', module 'ùïú E', set 'A' of 'E', and point 'x' in 'E', a point 'x' belongs to the set of exposed points of 'A' if and only if the singleton set containing 'x' is exposed with respect to 'A'. In other words, a point is exposed with respect to a set if and only if there is a hyperplane such that the intersection of the hyperplane with the set is exactly that point, and this is equivalent to the situation where the singleton set containing that point maximizes some functional over the original set.","distance":0.5113026664474096261159274945384822785854339599609375}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] ‚Üí\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] ‚Üí\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) ‚Üí\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.42448334382748942328333896512049250304698944091796875}],["Expand the square ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] (x y : F),\n  ‚Äñx - y‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - 2 * ‚ü™x, y‚ü´_‚Ñù + ‚Äñy‚Äñ ^ 2","name":"norm_sub_sq_real","isProp":true,"docString":"Expand the square ","distance":0.427725461133778017686069006231264211237430572509765625}],["The proof that is the limit cone ",{"type":"{J : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] ‚Üí\n    {C : Type u} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v, u} C] ‚Üí\n        {F : CategoryTheory.Functor J C} ‚Üí\n          (self : CategoryTheory.Limits.LimitCone F) ‚Üí CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.428663436241622342048884775067563168704509735107421875}],["an arrow ",{"type":"{V : Type u} ‚Üí [inst : Quiver V] ‚Üí (self : Quiver.Total V) ‚Üí self.left ‚ü∂ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.429911270378925902679867476763320155441761016845703125}],["the first row ",{"type":"{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    [inst_1 : CategoryTheory.Abelian C] ‚Üí CategoryTheory.ShortComplex.SnakeInput C ‚Üí CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L‚ÇÅ","isProp":false,"docString":"the first row ","distance":0.4307476367450657761537513579241931438446044921875}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.431379370214420798657073419235530309379100799560546875}],["projection expression ",{"type":"Simps.ParsedProjectionData ‚Üí Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.432882302262337093079480609958409331738948822021484375}],["This is (-)^A. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    (A : C) ‚Üí\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] ‚Üí\n        [inst_2 : CategoryTheory.Exponentiable A] ‚Üí CategoryTheory.Functor C C","name":"CategoryTheory.exp","isProp":false,"docString":"This is (-)^A. ","distance":0.43619067545009804209854564760462380945682525634765625}],["The left arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.left ‚ü∂ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inl","isProp":false,"docString":"The left arrow of the walking cospan. ","distance":0.4379014602312685244811518714413978159427642822265625}],["The right arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.right ‚ü∂ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inr","isProp":false,"docString":"The right arrow of the walking cospan. ","distance":0.438187065934145414392020256855175830423831939697265625}],["Real part ",{"type":"UpperHalfPlane ‚Üí ‚Ñù","name":"UpperHalfPlane.re","isProp":false,"docString":"Real part ","distance":0.438252455164433951662061872411868534982204437255859375}],["the third row ",{"type":"{C : Type u_1} ‚Üí\n  [inst : CategoryTheory.Category.{u_2, u_1} C] ‚Üí\n    [inst_1 : CategoryTheory.Abelian C] ‚Üí CategoryTheory.ShortComplex.SnakeInput C ‚Üí CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L‚ÇÉ","isProp":false,"docString":"the third row ","distance":0.439384421917823619896381615035352297127246856689453125}],["The empty finset ",{"type":"{Œ± : Type u_1} ‚Üí Finset Œ±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.441948700392234494760401730673038400709629058837890625}],["The program. ",{"type":"{Œì : Type u_1} ‚Üí\n  {Œõ : Type u_2} ‚Üí\n    [inst : Inhabited Œõ] ‚Üí Turing.TM0.Machine Œì Œõ ‚Üí Turing.TM0to1.Œõ' ‚Üí Turing.TM1.Stmt Œì Turing.TM0to1.Œõ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.44197890323221089570182584793656133115291595458984375}],["The statement to be proved inductively ",{"type":"{F : Type u_1} ‚Üí\n  [inst : Field F] ‚Üí {E : Type u_2} ‚Üí [inst_1 : Field E] ‚Üí [inst_2 : Algebra F E] ‚Üí ‚Ü•(solvableByRad F E) ‚Üí Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.442841677058884386486425910334219224750995635986328125}],["The supremum of the principal segment ",{"type":"{Œ± : Type u_4} ‚Üí {Œ≤ : Type u_5} ‚Üí {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí r ‚â∫i s ‚Üí Œ≤","name":"PrincipalSeg.top","isProp":false,"docString":"The supremum of the principal segment ","distance":0.445823335562420874911282453467720188200473785400390625}],["The left arrow of the walking span. ",{"type":"CategoryTheory.Limits.WalkingSpan.zero ‚ü∂ CategoryTheory.Limits.WalkingSpan.left","name":"CategoryTheory.Limits.WalkingSpan.Hom.fst","isProp":false,"docString":"The left arrow of the walking span. ","distance":0.445995861784547698025704676183522678911685943603515625}],["A convenient way to show that a binary cofan is a colimit. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí\n      (s : CategoryTheory.Limits.BinaryCofan X Y) ‚Üí\n        (desc : {T : C} ‚Üí (X ‚ü∂ T) ‚Üí (Y ‚ü∂ T) ‚Üí (s.pt ‚ü∂ T)) ‚Üí\n          (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n              CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) (desc f g) = f) ‚Üí\n            (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T),\n                CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) (desc f g) = g) ‚Üí\n              (‚àÄ {T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (m : s.pt ‚ü∂ T),\n                  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inl s) m = f ‚Üí\n                    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.BinaryCofan.inr s) m = g ‚Üí m = desc f g) ‚Üí\n                CategoryTheory.Limits.IsColimit s","name":"CategoryTheory.Limits.BinaryCofan.IsColimit.mk","isProp":false,"docString":"A convenient way to show that a binary cofan is a colimit. ","distance":0.446026156212579127924300337326712906360626220703125}]]