[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.277174451857636394702666393641266040503978729248046875}],[" For any complex number a, a can be expressed as the sum of its real part and the imaginary part multiplied by the imaginary unit (a = ℜ a + I * ℑ a).",{"type":"∀ {A : Type u_1} [inst : AddCommGroup A] [inst_1 : Module ℂ A] [inst_2 : StarAddMonoid A] [inst_3 : StarModule ℂ A]\n  (a : A), ↑(realPart a) + Complex.I • ↑(imaginaryPart a) = a","name":"realPart_add_I_smul_imaginaryPart","isProp":true,"docString":" For any complex number a, a can be expressed as the sum of its real part and the imaginary part multiplied by the imaginary unit (a = ℜ a + I * ℑ a).","distance":0.440256580654138696129251684396876953542232513427734375}],["This theorem states that for any integer 'a', the product of 0 and 'a' is always 0. It's a formal expression of the well-known mathematical rule that multiplying any number by zero results in zero.",{"type":"∀ (a : ℤ), 0 * a = 0","name":"Int.zero_mul","isProp":true,"docString":"This theorem states that for any integer 'a', the product of 0 and 'a' is always 0. It's a formal expression of the well-known mathematical rule that multiplying any number by zero results in zero.","distance":0.4544965160539451431986890383996069431304931640625}],["This is (-)^A. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (A : C) →\n      [inst_1 : CategoryTheory.Limits.HasFiniteProducts C] →\n        [inst_2 : CategoryTheory.Exponentiable A] → CategoryTheory.Functor C C","name":"CategoryTheory.exp","isProp":false,"docString":"This is (-)^A. ","distance":0.307351253473989227682494629334541969001293182373046875}],[" For all natural numbers a, a is the minimum value of a and a.",{"type":"∀ (a : ℕ), min a a = a","name":"Nat.min_self","isProp":true,"docString":" For all natural numbers a, a is the minimum value of a and a.","distance":0.443032779351666572420498368956032209098339080810546875}],["This theorem states that for any proposition 'a', the biconditional of 'a' and 'False' is equivalent to the negation of 'a'. In other words, 'a' is equivalent to 'False' if and only if 'a' is not true.",{"type":"∀ {a : Prop}, (a ↔ False) ↔ ¬a","name":"iff_false_iff","isProp":true,"docString":"This theorem states that for any proposition 'a', the biconditional of 'a' and 'False' is equivalent to the negation of 'a'. In other words, 'a' is equivalent to 'False' if and only if 'a' is not true.","distance":0.456740050966556843103916207837755791842937469482421875}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.32452358561104610590319907714729197323322296142578125}],["Continuity ",{"type":"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {σ : outParam (R →+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M₂ : outParam (Type u_5)} [inst_4 : TopologicalSpace M₂] [inst_5 : AddCommMonoid M₂] [inst_6 : Module R M]\n  [inst_7 : Module S M₂] [self : ContinuousSemilinearMapClass F σ M M₂] (f : F), Continuous ⇑f","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity ","distance":0.324882471690855989532309422429534606635570526123046875}],["The `a`'s are nonzero ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → ∀ (i : α), 0 < a i","name":"AkraBazziRecurrence.a_pos","isProp":true,"docString":"The `a`'s are nonzero ","distance":0.330591234101721198612722218967974185943603515625}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.332941147659510494616341702567297033965587615966796875}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.33510208967884647091040051236632280051708221435546875}],["a first integer ",{"type":"{n : ℤ} → CochainComplex.HomComplex.Triplet n → ℤ","name":"CochainComplex.HomComplex.Triplet.p","isProp":false,"docString":"a first integer ","distance":0.338238645091676171094974279185407795011997222900390625}],["an auxiliary type ",{"type":"{I₁ : Type u_6} →\n  {I₂ : Type u_7} →\n    {I₃ : Type u_8} →\n      {J : Type u_9} → {r : I₁ × I₂ × I₃ → J} → CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r → Type u_10","name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.I₁₂","isProp":false,"docString":"an auxiliary type ","distance":0.338556243536284828810067892845836468040943145751953125}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.338993946245002841788362957231584005057811737060546875}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.34202919618627858344694914194406010210514068603515625}],["The basis of M. ",{"type":"{R : Type u_2} →\n  [inst : CommRing R] →\n    {M : Type u_3} →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] →\n          {N : Submodule R M} → {ι : Type u_4} → {n : ℕ} → Basis.SmithNormalForm N ι n → Basis ι R M","name":"Basis.SmithNormalForm.bM","isProp":false,"docString":"The basis of M. ","distance":0.342033611106895119036153118941001594066619873046875}],["The universal class ",{"type":"Class","name":"Class.univ","isProp":false,"docString":"The universal class ","distance":0.34398025869241000140874575663474388420581817626953125}],["A realizer of the neighborhood of a point. ",{"type":"{α : Type u_1} → [inst : TopologicalSpace α] → Ctop.Realizer α → (a : α) → Filter.Realizer (nhds a)","name":"Ctop.Realizer.nhds","isProp":false,"docString":"A realizer of the neighborhood of a point. ","distance":0.344293703830891251183032863991684280335903167724609375}],["The empty pre-set ",{"type":"PSet","name":"PSet.empty","isProp":false,"docString":"The empty pre-set ","distance":0.344997750942242886740274343537748791277408599853515625}],["the second row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₂","isProp":false,"docString":"the second row ","distance":0.345734563218391688366182279423810541629791259765625}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.34579271168486080956228079230641014873981475830078125}],["The initial state. ",{"type":"Mathlib.Notation3.MatchState","name":"Mathlib.Notation3.MatchState.empty","isProp":false,"docString":"The initial state. ","distance":0.345831076410207938209850908606313169002532958984375}],["The supremum of the partition is `a` ",{"type":"∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a), Finset.sup self.parts id = a","name":"Finpartition.supParts","isProp":true,"docString":"The supremum of the partition is `a` ","distance":0.3462483837315073476048610245925374329090118408203125}],["The lift. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {A B X Y : C} →\n      {f : A ⟶ X} →\n        {i : A ⟶ B} →\n          {p : X ⟶ Y} →\n            {g : B ⟶ Y} → {sq : CategoryTheory.CommSq f i p g} → CategoryTheory.CommSq.LiftStruct sq → (B ⟶ X)","name":"CategoryTheory.CommSq.LiftStruct.l","isProp":false,"docString":"The lift. ","distance":0.3468057116083593793831596485688351094722747802734375}]]