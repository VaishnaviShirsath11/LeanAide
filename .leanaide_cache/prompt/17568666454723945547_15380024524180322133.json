[["To prove that the lift of a supremum is bounded by some cardinal `t`,\nit suffices to show that the lift of each cardinal is bounded by `t`. ",{"type":"∀ {ι : Type v} {f : ι → Cardinal.{w}} {t : Cardinal.{max u w}},\n  BddAbove (Set.range f) → (∀ (i : ι), Cardinal.lift.{u, w} (f i) ≤ t) → Cardinal.lift.{u, w} (iSup f) ≤ t","name":"Cardinal.lift_iSup_le","isProp":true,"docString":"To prove that the lift of a supremum is bounded by some cardinal `t`,\nit suffices to show that the lift of each cardinal is bounded by `t`. ","distance":0.329838384581673860207473580885562114417552947998046875}],[" For all real numbers `t`, if 0 ≤ t ≤ 1 then t ≥ 0. (The unit interval includes 0, so an alternative statement is: For all real numbers `t`, if 0 ≤ t then t ≥ 0.)",{"type":"∀ {t : ↑unitInterval}, 0 ≤ t","name":"unitInterval.nonneg'","isProp":true,"docString":" For all real numbers `t`, if 0 ≤ t ≤ 1 then t ≥ 0. (The unit interval includes 0, so an alternative statement is: For all real numbers `t`, if 0 ≤ t then t ≥ 0.)","distance":0.392132081218970640623666668034275062382221221923828125}],["This theorem states that for every real number `t` in the unit interval `[0,1]`, the number `1 - t` is also in the unit interval. In other words, if you subtract any number from the unit interval `[0,1]` from `1`, the result will still be within the unit interval `[0,1]`.",{"type":"∀ (t : ↑unitInterval), 1 - ↑t ∈ unitInterval","name":"unitInterval.symm.proof_1","isProp":true,"docString":"This theorem states that for every real number `t` in the unit interval `[0,1]`, the number `1 - t` is also in the unit interval. In other words, if you subtract any number from the unit interval `[0,1]` from `1`, the result will still be within the unit interval `[0,1]`.","distance":0.387839003808235049941544048124342225492000579833984375}],["the equivalence given by multiplication on the left by `t`  ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} →\n      ↥A ≃* ↥B →\n        {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d ≃ HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.unitsSMulEquiv","isProp":false,"docString":"the equivalence given by multiplication on the left by `t`  ","distance":0.33411977789764468749211800968623720109462738037109375}],[" For all real numbers `t`, if `t` belongs to the unit interval [0,1], then `t` ≤ 1.",{"type":"∀ {t : ↑unitInterval}, t ≤ 1","name":"unitInterval.le_one'","isProp":true,"docString":" For all real numbers `t`, if `t` belongs to the unit interval [0,1], then `t` ≤ 1.","distance":0.399546304600236379389599505884689278900623321533203125}],["This theorem states that for all real numbers `t` and `x`, and for all natural numbers `n`, the function `y => (x - y) ^ (n + 1)` has a derivative at the point `t`. The derivative at this point is given by `-(↑n + 1) * (x - t) ^ n`. This is a helper lemma used in the calculation of the derivative of the monomial that appears in Taylor expansions.",{"type":"∀ (t x : ℝ) (n : ℕ), HasDerivAt (fun y => (x - y) ^ (n + 1)) (-(↑n + 1) * (x - t) ^ n) t","name":"monomial_has_deriv_aux","isProp":true,"docString":"This theorem states that for all real numbers `t` and `x`, and for all natural numbers `n`, the function `y => (x - y) ^ (n + 1)` has a derivative at the point `t`. The derivative at this point is given by `-(↑n + 1) * (x - t) ^ n`. This is a helper lemma used in the calculation of the derivative of the monomial that appears in Taylor expansions.","distance":0.389304027482058445652768341460614465177059173583984375}],["A proof of tm outputting l' when given l. ",{"type":"(tm : Turing.FinTM2) → List (Turing.FinTM2.Γ tm tm.k₀) → Option (List (Turing.FinTM2.Γ tm tm.k₁)) → Type","name":"Turing.TM2Outputs","isProp":false,"docString":"A proof of tm outputting l' when given l. ","distance":0.352915155925798529334969089177320711314678192138671875}],["If `t` is bounded, then so is `s ∩ t` ",{"type":"∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddAbove t → BddAbove (s ∩ t)","name":"BddAbove.inter_of_right","isProp":true,"docString":"If `t` is bounded, then so is `s ∩ t` ","distance":0.35623322746481089762227156825247220695018768310546875}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        [inst_2 : CategoryTheory.IsConnected J] →\n          {B : C} →\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} →\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} →\n                CategoryTheory.Limits.IsLimit c →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.3605501144343754571508497974718920886516571044921875}],["The `t` coefficient of an admissible linear change of variables. ",{"type":"{R : Type u} → [inst : CommRing R] → WeierstrassCurve.VariableChange R → R","name":"WeierstrassCurve.VariableChange.t","isProp":false,"docString":"The `t` coefficient of an admissible linear change of variables. ","distance":0.366621637402136324457302407608949579298496246337890625}],["Elaborate `t` in a way that is suitable for linarith. ",{"type":"Lean.Name → Lean.Term → Lean.Elab.Tactic.TacticM Lean.Expr","name":"elabLinarithArg","isProp":false,"docString":"Elaborate `t` in a way that is suitable for linarith. ","distance":0.3676876477845170132496832593460567295551300048828125}],["If `s` is bounded, then so is `s ∩ t` ",{"type":"∀ {α : Type u} [inst : Preorder α] {s t : Set α}, BddBelow s → BddBelow (s ∩ t)","name":"BddBelow.inter_of_left","isProp":true,"docString":"If `s` is bounded, then so is `s ∩ t` ","distance":0.369039588768185489175976954356883652508258819580078125}],["The map `ϕ t` as a homeomorphism. ",{"type":"{τ : Type u_1} →\n  [inst : AddCommGroup τ] →\n    [inst_1 : TopologicalSpace τ] →\n      [inst_2 : TopologicalAddGroup τ] → {α : Type u_2} → [inst_3 : TopologicalSpace α] → Flow τ α → τ → α ≃ₜ α","name":"Flow.toHomeomorph","isProp":false,"docString":"The map `ϕ t` as a homeomorphism. ","distance":0.37034251377480920108808959412272088229656219482421875}],["The statement to be proved inductively ",{"type":"{F : Type u_1} →\n  [inst : Field F] → {E : Type u_2} → [inst_1 : Field E] → [inst_2 : Algebra F E] → ↥(solvableByRad F E) → Prop","name":"solvableByRad.P","isProp":false,"docString":"The statement to be proved inductively ","distance":0.370670242271176897386197879313840530812740325927734375}],["Evidence that the proposed colimit is the colimit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    (F : CategoryTheory.Functor J MonCat) → CategoryTheory.Limits.IsColimit (MonCat.Colimits.colimitCocone F)","name":"MonCat.Colimits.colimitIsColimit","isProp":false,"docString":"Evidence that the proposed colimit is the colimit. ","distance":0.371887968290341597299430986822699196636676788330078125}],["`t` is in the upper shadow of `𝒜` iff there is a `s ∈ 𝒜` from which we can remove one element\nto get `t`. ",{"type":"∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {𝒜 : Finset (Finset α)} {t : Finset α},\n  t ∈ Finset.upShadow 𝒜 ↔ ∃ s ∈ 𝒜, ∃ a ∉ s, insert a s = t","name":"Finset.mem_upShadow_iff","isProp":true,"docString":"`t` is in the upper shadow of `𝒜` iff there is a `s ∈ 𝒜` from which we can remove one element\nto get `t`. ","distance":0.374512242648097293251652217804803512990474700927734375}],["`s ×ˢ t` is homeomorphic to `s × t`. ",{"type":"{X : Type u_1} →\n  {Y : Type u_2} →\n    [inst : TopologicalSpace X] → [inst_1 : TopologicalSpace Y] → (s : Set X) → (t : Set Y) → ↑(s ×ˢ t) ≃ₜ ↑s × ↑t","name":"Homeomorph.Set.prod","isProp":false,"docString":"`s ×ˢ t` is homeomorphic to `s × t`. ","distance":0.374877464443958974271708939340896904468536376953125}],["The proof that it is the colimit cocone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.ColimitCocone F) → CategoryTheory.Limits.IsColimit self.cocone","name":"CategoryTheory.Limits.ColimitCocone.isColimit","isProp":false,"docString":"The proof that it is the colimit cocone ","distance":0.376699915028879506184722458783653564751148223876953125}],["A term `t` with variables indexed by `α` can be evaluated by giving a value to each variable. ",{"type":"{L : FirstOrder.Language} →\n  {M : Type w} → [inst : FirstOrder.Language.Structure L M] → {α : Type u'} → (α → M) → FirstOrder.Language.Term L α → M","name":"FirstOrder.Language.Term.realize","isProp":false,"docString":"A term `t` with variables indexed by `α` can be evaluated by giving a value to each variable. ","distance":0.378967135823717493625650831745588220655918121337890625}],["If `s ⊆ t` and `t` is bounded above, then so is `s`. ",{"type":"∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → BddAbove t → BddAbove s","name":"BddAbove.mono","isProp":true,"docString":"If `s ⊆ t` and `t` is bounded above, then so is `s`. ","distance":0.379028938759350120246693904846324585378170013427734375}],["Markov's inequality for the counting measure with hypothesis using `tsum` in `ℝ≥0∞`. ",{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] {a : α → ENNReal},\n  Measurable a →\n    ∀ {c : ENNReal},\n      ∑' (i : α), a i ≤ c → ∀ {ε : ENNReal}, ε ≠ 0 → ε ≠ ⊤ → ↑↑MeasureTheory.Measure.count {i | ε ≤ a i} ≤ c / ε","name":"ENNReal.count_const_le_le_of_tsum_le","isProp":true,"docString":"Markov's inequality for the counting measure with hypothesis using `tsum` in `ℝ≥0∞`. ","distance":0.380591856855738541742795177924563176929950714111328125}],["The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\n  (PowerSeries.mk fun n => (Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * (PowerSeries.rescale t) (PowerSeries.exp A)","name":"Polynomial.bernoulli_generating_function","isProp":true,"docString":"The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ ","distance":0.38257411857270129385000245747505687177181243896484375}],["`t` is in the shadow of `𝒜` iff there is a `s ∈ 𝒜` from which we can remove one element to\nget `t`. ",{"type":"∀ {α : Type u_1} [inst : DecidableEq α] {𝒜 : Finset (Finset α)} {t : Finset α},\n  t ∈ Finset.shadow 𝒜 ↔ ∃ s ∈ 𝒜, ∃ a ∈ s, Finset.erase s a = t","name":"Finset.mem_shadow_iff","isProp":true,"docString":"`t` is in the shadow of `𝒜` iff there is a `s ∈ 𝒜` from which we can remove one element to\nget `t`. ","distance":0.383700244658174260958816148558980785310268402099609375}],["If `s ≤ t`, then there is an embedding `s ⧸ H.subgroupOf s ↪ t ⧸ H.subgroupOf t`. ",{"type":"{α : Type u_1} →\n  [inst : Group α] →\n    {s t : Subgroup α} → (H : Subgroup α) → s ≤ t → ↥s ⧸ Subgroup.subgroupOf H s ↪ ↥t ⧸ Subgroup.subgroupOf H t","name":"Subgroup.quotientSubgroupOfEmbeddingOfLE","isProp":false,"docString":"If `s ≤ t`, then there is an embedding `s ⧸ H.subgroupOf s ↪ t ⧸ H.subgroupOf t`. ","distance":0.384032901729135234258905029491870664060115814208984375}]]