[["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.384553866522101939207090026684454642236232757568359375}],[" For all natural numbers n, n ≤ n.",{"type":"∀ (n : ℕ), n ≤ n","name":"Nat.le_refl","isProp":true,"docString":" For all natural numbers n, n ≤ n.","distance":0.521471615847014735578568433993496000766754150390625}],["This theorem states the reversed version of Modus Ponens for 'if and only if'. Given two propositions `a` and `b`, if we know that `a` is equivalent to `b` (denoted `a ↔ b`), and we also know that `b` is true, then we can conclude that `a` is also true. This theorem is a fundamental rule of inference in propositional logic.",{"type":"∀ {a b : Prop}, (a ↔ b) → b → a","name":"Iff.mpr","isProp":true,"docString":"This theorem states the reversed version of Modus Ponens for 'if and only if'. Given two propositions `a` and `b`, if we know that `a` is equivalent to `b` (denoted `a ↔ b`), and we also know that `b` is true, then we can conclude that `a` is also true. This theorem is a fundamental rule of inference in propositional logic.","distance":0.5066801612305056323748431168496608734130859375}],["Expand the square ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x - y‖ ^ 2 = ‖x‖ ^ 2 - 2 * ⟪x, y⟫_ℝ + ‖y‖ ^ 2","name":"norm_sub_sq_real","isProp":true,"docString":"Expand the square ","distance":0.405749972006056836004717069954494945704936981201171875}],[" The interior of a set is contained in its closure.",{"type":"∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], interior s ⊆ closure s","name":"interior_subset_closure","isProp":true,"docString":" The interior of a set is contained in its closure.","distance":0.5244157784371215047514169782516546547412872314453125}],["This is the statement of the Phragmen-Lindelöf Principle in the context of a strip `U = {z ∈ ℂ | a < Re(z) < b}` in the complex plane. Suppose `f : ℂ → E` is a function that is differentiable on `U` and continuous on its closure, and the norm `‖f z‖` is bounded from above by `A * exp(B * exp(c * |Im(z)|))` on `U` for some `c < π / (b - a)`, and `f(z) = 0` on the boundary of `U`. Then the theorem states that `f` is identically zero on the closed strip `{z ∈ ℂ | a ≤ Re(z) ≤ b}`. In other words, if `f` vanishes on the boundary of `U` and its norm doesn't grow too fast within `U`, then `f` must vanish everywhere in the closed strip.",{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {a b : ℝ} {f : ℂ → E},\n  DiffContOnCl ℂ f (Complex.re ⁻¹' Set.Ioo a b) →\n    (∃ c < Real.pi / (b - a),\n        ∃ B,\n          f =O[Filter.comap (abs ∘ Complex.im) Filter.atTop ⊓ Filter.principal (Complex.re ⁻¹' Set.Ioo a b)] fun z =>\n            (B * (c * |z.im|).exp).exp) →\n      (∀ (z : ℂ), z.re = a → f z = 0) → (∀ (z : ℂ), z.re = b → f z = 0) → Set.EqOn f 0 (Complex.re ⁻¹' Set.Icc a b)","name":"PhragmenLindelof.eq_zero_on_vertical_strip","isProp":true,"docString":"This is the statement of the Phragmen-Lindelöf Principle in the context of a strip `U = {z ∈ ℂ | a < Re(z) < b}` in the complex plane. Suppose `f : ℂ → E` is a function that is differentiable on `U` and continuous on its closure, and the norm `‖f z‖` is bounded from above by `A * exp(B * exp(c * |Im(z)|))` on `U` for some `c < π / (b - a)`, and `f(z) = 0` on the boundary of `U`. Then the theorem states that `f` is identically zero on the closed strip `{z ∈ ℂ | a ≤ Re(z) ≤ b}`. In other words, if `f` vanishes on the boundary of `U` and its norm doesn't grow too fast within `U`, then `f` must vanish everywhere in the closed strip.","distance":0.50717030321837075490520874154753983020782470703125}],["Show the equalizing cone is a limit ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] →\n      [inst_2 : CategoryTheory.Limits.HasPullbacks C] →\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) →\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerCone F)","name":"CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.equalizerConeIsLimit","isProp":false,"docString":"Show the equalizing cone is a limit ","distance":0.41185793677405502233312972748535685241222381591796875}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.4149770925318641001666719603235833346843719482421875}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.415283375454988057384753119549714028835296630859375}],["Name of the presenter to use. ",{"type":"ProofWidgets.GetExprPresentationParams → Lean.Name","name":"ProofWidgets.GetExprPresentationParams.name","isProp":false,"docString":"Name of the presenter to use. ","distance":0.417189736062627491985921324157970957458019256591796875}],["(Impl) Show that the raised cone is a limit. ",{"type":"{J : Type v} →\n  [inst : CategoryTheory.SmallCategory J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        [inst_2 : CategoryTheory.IsConnected J] →\n          {B : C} →\n            {F : CategoryTheory.Functor J (CategoryTheory.Over B)} →\n              {c : CategoryTheory.Limits.Cone (CategoryTheory.Functor.comp F (CategoryTheory.Over.forget B))} →\n                CategoryTheory.Limits.IsLimit c →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Over.CreatesConnected.raiseCone c)","name":"CategoryTheory.Over.CreatesConnected.raisedConeIsLimit","isProp":false,"docString":"(Impl) Show that the raised cone is a limit. ","distance":0.417696355241083561171677729362272657454013824462890625}],["A choice of wide pushout. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (B : C) →\n        (objs : J → C) →\n          (arrows : (j : J) → B ⟶ objs j) → [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] → C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.418127343422890429547322810321929864585399627685546875}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.41837253917357497545737032851320691406726837158203125}],["The lift. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {A B X Y : C} →\n      {f : A ⟶ X} →\n        {i : A ⟶ B} →\n          {p : X ⟶ Y} →\n            {g : B ⟶ Y} → {sq : CategoryTheory.CommSq f i p g} → CategoryTheory.CommSq.LiftStruct sq → (B ⟶ X)","name":"CategoryTheory.CommSq.LiftStruct.l","isProp":false,"docString":"The lift. ","distance":0.421374133551440543943300554019515402615070343017578125}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.4230366231002899990443211208912543952465057373046875}],["Matches applications. ",{"type":"Mathlib.Notation3.Matcher → Mathlib.Notation3.Matcher → Mathlib.Notation3.Matcher","name":"Mathlib.Notation3.matchApp","isProp":false,"docString":"Matches applications. ","distance":0.423370708707423493155630467299488373100757598876953125}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.423560893803172688887315189276705496013164520263671875}],["The proof that is the limit cone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.LimitCone F) → CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.423739626836844907042944896602421067655086517333984375}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.423883845889320987065929102755035273730754852294921875}],["The empty pre-set ",{"type":"PSet","name":"PSet.empty","isProp":false,"docString":"The empty pre-set ","distance":0.426681765097744525316869612652226351201534271240234375}],["The set of points. ",{"type":"{K : Type u_1} →\n  {V : Type u_2} →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → Projectivization.Subspace K V → Set (Projectivization K V)","name":"Projectivization.Subspace.carrier","isProp":false,"docString":"The set of points. ","distance":0.427089718363134862588736950783641077578067779541015625}],["Show the equalizing cocone is a colimit ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] →\n      [inst_2 : CategoryTheory.Limits.HasPushouts C] →\n        (F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C) →\n          CategoryTheory.Limits.IsColimit\n            (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCocone F)","name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.coequalizerCoconeIsColimit","isProp":false,"docString":"Show the equalizing cocone is a colimit ","distance":0.42716325113539799218642656342126429080963134765625}],["All epis are split ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [self : CategoryTheory.SplitEpiCategory C] {X Y : C}\n  (f : X ⟶ Y) [inst_1 : CategoryTheory.Epi f], CategoryTheory.IsSplitEpi f","name":"CategoryTheory.SplitEpiCategory.isSplitEpi_of_epi","isProp":true,"docString":"All epis are split ","distance":0.428087829239428396821409705808036960661411285400390625}],["Real part ",{"type":"UpperHalfPlane → ℝ","name":"UpperHalfPlane.re","isProp":false,"docString":"Real part ","distance":0.428421713916063262583833193275495432317256927490234375}]]