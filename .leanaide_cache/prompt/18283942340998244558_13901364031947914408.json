[["If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ",{"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ","distance":0.1931529463217834530208705245968303643167018890380859375}],[" For every positive natural number `n` different from `1`, there exists a natural number `k` such that `n = Suc(k)`. (Here, `Suc` denotes the successor function.)",{"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":" For every positive natural number `n` different from `1`, there exists a natural number `k` such that `n = Suc(k)`. (Here, `Suc` denotes the successor function.)","distance":0.21649794703373104187704711875994689762592315673828125}],["This theorem states that for any positive natural number `n` that is not equal to `1`, there exists another positive natural number `k` such that `n` is the successor of `k`. In other words, if a positive natural number is not `1`, then it can be expressed as `k + 1` for some positive natural number `k`.",{"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"This theorem states that for any positive natural number `n` that is not equal to `1`, there exists another positive natural number `k` such that `n` is the successor of `k`. In other words, if a positive natural number is not `1`, then it can be expressed as `k + 1` for some positive natural number `k`.","distance":0.2060248903357621286236422974980087019503116607666015625}],[" The theorem `Nat.choose_succ_succ` in Lean 4 states that for all natural numbers `n` and `k`, the binomial coefficient of `n+1` choose `k+1` equals the sum of the binomial coefficients of `n` choose `k` and `n` choose `k+1`. In mathematical notation, $\\binom{n+1}{k+1} = \\binom{n}{k} + \\binom{n}{k+1}$.",{"value":null,"type":"∀ (n k : ℕ), n.succ.choose k.succ = n.choose k + n.choose k.succ","statement":"theorem Nat.choose_succ_succ : ∀ (n k : ℕ), n.succ.choose k.succ = n.choose k + n.choose k.succ := by sorry","name":"Nat.choose_succ_succ","isProp":true,"description":"The theorem `Nat.choose_succ_succ` is about binomial coefficients (commonly denoted by \"n choose k\") in combinatorics. It states that for all natural numbers `n` and `k`, the binomial coefficient of `n+1` choose `k+1` is equal to the sum of the binomial coefficient of `n` choose `k` and the binomial coefficient of `n` choose `k+1`. In other words, this theorem is a formalization of the Pascal's Rule, which is a fundamental property of binomial coefficients used in combinatorial mathematics. The theorem may be written in LaTeX mathematics as: $\\binom{n+1}{k+1} = \\binom{n}{k} + \\binom{n}{k+1}$.","concise-description":" The theorem `Nat.choose_succ_succ` in Lean 4 states that for all natural numbers `n` and `k`, the binomial coefficient of `n+1` choose `k+1` equals the sum of the binomial coefficients of `n` choose `k` and `n` choose `k+1`. In mathematical notation, $\\binom{n+1}{k+1} = \\binom{n}{k} + \\binom{n}{k+1}$."}],["Equivalence between the set of natural numbers which are `≥ k` and `ℕ`, given by `n → n - k`. ",{"type":"(k : ℕ) → { n // n ∉ Multiset.range k } ≃ ℕ","name":"notMemRangeEquiv","isProp":false,"docString":"Equivalence between the set of natural numbers which are `≥ k` and `ℕ`, given by `n → n - k`. ","distance":0.229500981842682694189505809845286421477794647216796875}],[" For any natural numbers `m` and `n` with `m < n`, there exists a natural number `k` such that `n = m + k + 1`.",{"type":"∀ {m n : ℕ}, m < n → ∃ k, n = m + k + 1","name":"Nat.exists_eq_add_of_lt","isProp":true,"docString":" For any natural numbers `m` and `n` with `m < n`, there exists a natural number `k` such that `n = m + k + 1`.","distance":0.24729373134135546052903009695000946521759033203125}],["This theorem states that for any natural number `n` that is not zero, there exists another natural number `k` such that `n` is the successor of `k`. In other words, if you have a nonzero natural number, it must be one greater than another natural number.",{"type":"∀ {n : ℕ}, n ≠ 0 → ∃ k, n = k.succ","name":"Nat.exists_eq_succ_of_ne_zero","isProp":true,"docString":"This theorem states that for any natural number `n` that is not zero, there exists another natural number `k` such that `n` is the successor of `k`. In other words, if you have a nonzero natural number, it must be one greater than another natural number.","distance":0.2102555412685860602994836199286510236561298370361328125}],[" For every positive natural number `n` different from `1`, there exists a natural number `k` such that `n = Suc(k)`. (Here, `Suc` denotes the successor function.)",{"value":null,"type":"∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1","statement":"theorem PNat.exists_eq_succ_of_ne_one : ∀ {n : ℕ+}, n ≠ 1 → ∃ k, n = k + 1 := by sorry","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. ","description":"This theorem states that for any positive natural number `n` that is not equal to `1`, there exists another positive natural number `k` such that `n` is the successor of `k`. In other words, if a positive natural number is not `1`, then it can be expressed as `k + 1` for some positive natural number `k`.","concise-description":" For every positive natural number `n` different from `1`, there exists a natural number `k` such that `n = Suc(k)`. (Here, `Suc` denotes the successor function.)"}],["A subset of `ℕ` containing `k : ℕ` and closed under `Nat.succ` contains every `n ≥ k`. ",{"type":"∀ {n k : ℕ} {S : Set ℕ}, k ∈ S → (∀ k ∈ S, k + 1 ∈ S) → k ≤ n → n ∈ S","name":"Nat.set_induction_bounded","isProp":true,"docString":"A subset of `ℕ` containing `k : ℕ` and closed under `Nat.succ` contains every `n ≥ k`. ","distance":0.247105439393334236353183541723410598933696746826171875}],[" For any natural number `n`, `n + 1` is the same as the successor of `n`. (Alternatively: The successor of a natural number `n` is `n + 1`.)",{"type":"∀ (n : Num), n + 1 = n.succ","name":"Num.add_one","isProp":true,"docString":" For any natural number `n`, `n + 1` is the same as the successor of `n`. (Alternatively: The successor of a natural number `n` is `n + 1`.)","distance":0.251840040187543523497737396610318683087825775146484375}],["This theorem states that for any subset `S` of natural numbers `ℕ`, any arbitrary natural numbers `n` and `k`, if `k` is an element of `S` and `S` is closed under successor operation (meaning if `k` is in `S`, then `k + 1` is also in `S`), then every natural number `n` that is greater than or equal to `k` is also an element of `S`.",{"type":"∀ {n k : ℕ} {S : Set ℕ}, k ∈ S → (∀ k ∈ S, k + 1 ∈ S) → k ≤ n → n ∈ S","name":"Nat.set_induction_bounded","isProp":true,"docString":"This theorem states that for any subset `S` of natural numbers `ℕ`, any arbitrary natural numbers `n` and `k`, if `k` is an element of `S` and `S` is closed under successor operation (meaning if `k` is in `S`, then `k + 1` is also in `S`), then every natural number `n` that is greater than or equal to `k` is also an element of `S`.","distance":0.2225843174991131989681747427312075160443782806396484375}],["`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ",{"type":"{n : ℕ} → Fin2 n → (k : ℕ) → Fin2 (n + k)","name":"Fin2.add","isProp":false,"docString":"`i + k : Fin2 (n + k)` when `i : Fin2 n` and `k : ℕ` ","distance":0.252357196950570739080177418145467527210712432861328125}],[" For all natural numbers n, Nat.succ n equals 1 + n.",{"type":"∀ (n : ℕ), n.succ = 1 + n","name":"Nat.succ_eq_one_add","isProp":true,"docString":" For all natural numbers n, Nat.succ n equals 1 + n.","distance":0.256990162715402925552865553981973789632320404052734375}],["This theorem states that for any two natural numbers `k` and `n`, if `k` is greater than zero then `n` is less than `n + k`. In other words, adding a positive natural number `k` to another natural number `n` always results in a number that is larger than `n`.",{"type":"∀ {k n : ℕ}, 0 < k → n < n + k","name":"Nat.lt_add_of_pos_right","isProp":true,"docString":"This theorem states that for any two natural numbers `k` and `n`, if `k` is greater than zero then `n` is less than `n + k`. In other words, adding a positive natural number `k` to another natural number `n` always results in a number that is larger than `n`.","distance":0.2277694007427607247873169171725749038159847259521484375}],["The sequence of natural numbers some 0, some 1, ... ",{"type":"Stream'.Seq ℕ","name":"Stream'.Seq.nats","isProp":false,"docString":"The sequence of natural numbers some 0, some 1, ... ","distance":0.282327145224728959238547076893155463039875030517578125}],["For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. ",{"type":"∀ {R : Type u_4} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n","name":"isLittleO_pow_const_const_pow_of_one_lt","isProp":true,"docString":"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. ","distance":0.285554930616964741663110771696665324270725250244140625}],["Another `mk` using ℕ and ℕ+ ",{"type":"ℕ+ → ℕ → ℕ → ℕ+ → ℕ+ → ℕ+ → PNat.XgcdType","name":"PNat.XgcdType.mk'","isProp":false,"docString":"Another `mk` using ℕ and ℕ+ ","distance":0.286308241523139328510438872399390675127506256103515625}],["The constant function with value `n : ℤ`. ",{"type":"{α : Type u_1} → ℤ → Poly α","name":"Poly.const","isProp":false,"docString":"The constant function with value `n : ℤ`. ","distance":0.28708713141774044874665605675545521080493927001953125}]]