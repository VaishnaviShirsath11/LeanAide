[["Append a stream to a list. ",{"type":"{α : Type u} → List α → Stream' α → Stream' α","name":"Stream'.appendStream'","isProp":false,"docString":"Append a stream to a list. ","distance":1.77978311779824682758999188081361353397369384765625}],[" In a pseudometric space, a sequence is Cauchy if and only if for any ε > 0, there exists an index such that the pseudoedistance between the sequence's terms at that index and any later index is less than ε.",{"type":"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ (m : β), N ≤ m → ∀ (n : β), N ≤ n → edist (u m) (u n) < ε","name":"EMetric.cauchySeq_iff","isProp":true,"docString":" In a pseudometric space, a sequence is Cauchy if and only if for any ε > 0, there exists an index such that the pseudoedistance between the sequence's terms at that index and any later index is less than ε.","distance":1.8579841148497544534023973028524778783321380615234375}],["The `Stream'.Seq.cons_append` theorem states that for any type `α`, any element `a` of type `α`, and any two sequences `s` and `t` of type `α`, appending sequence `t` to the sequence obtained by prepending `a` to sequence `s` (`Stream'.Seq.append (Stream'.Seq.cons a s) t`) is equivalent to prepending `a` to the sequence obtained by appending `s` and `t` (`Stream'.Seq.cons a (Stream'.Seq.append s t)`). This is a property of sequence concatenation and prepending in potentially infinite lists, which mirrors the traditional property of list concatenation and cons operation in finite lists.",{"type":"∀ {α : Type u} (a : α) (s t : Stream'.Seq α), (Stream'.Seq.cons a s).append t = Stream'.Seq.cons a (s.append t)","name":"Stream'.Seq.cons_append","isProp":true,"docString":"The `Stream'.Seq.cons_append` theorem states that for any type `α`, any element `a` of type `α`, and any two sequences `s` and `t` of type `α`, appending sequence `t` to the sequence obtained by prepending `a` to sequence `s` (`Stream'.Seq.append (Stream'.Seq.cons a s) t`) is equivalent to prepending `a` to the sequence obtained by appending `s` and `t` (`Stream'.Seq.cons a (Stream'.Seq.append s t)`). This is a property of sequence concatenation and prepending in potentially infinite lists, which mirrors the traditional property of list concatenation and cons operation in finite lists.","distance":1.847313307227434808766020069015212357044219970703125}],["Appends the extension `ext` to a path `p`.\n\n`ext` should not contain a leading `.`, as this function adds one.\nIf `ext` is the empty string, no `.` is added.\n\nUnlike `System.FilePath.withExtension`, this does not remove any existing extension. ",{"type":"System.FilePath → String → System.FilePath","name":"System.FilePath.addExtension","isProp":false,"docString":"Appends the extension `ext` to a path `p`.\n\n`ext` should not contain a leading `.`, as this function adds one.\nIf `ext` is the empty string, no `.` is added.\n\nUnlike `System.FilePath.withExtension`, this does not remove any existing extension. ","distance":1.81204760720432744847130379639565944671630859375}],[" In a pseudo-metric space, if the sequence of extended distances between consecutive elements is bounded by a summable series, then the sequence is a Cauchy sequence.",{"type":"∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {f : ℕ → α} (d : ℕ → NNReal),\n  (∀ (n : ℕ), edist (f n) (f n.succ) ≤ ↑(d n)) → Summable d → CauchySeq f","name":"cauchySeq_of_edist_le_of_summable","isProp":true,"docString":" In a pseudo-metric space, if the sequence of extended distances between consecutive elements is bounded by a summable series, then the sequence is a Cauchy sequence.","distance":1.8675708933087566965269843421992845833301544189453125}],["This theorem states that for a given sequence of elements in a pseudo-emetric space, if the extended distance between consecutive elements of this sequence is bounded by a summable series of nonnegative real numbers, then the original sequence is a Cauchy sequence. Here, a pseudo-emetric space is a set endowed with a metric-like function (the extended distance); a Cauchy sequence is a sequence where the distance between any two subsequent elements can be made arbitrarily small by going sufficiently far into the sequence; and a series is summable if the infinite series of its terms converges to a finite limit.",{"type":"∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {f : ℕ → α} (d : ℕ → NNReal),\n  (∀ (n : ℕ), edist (f n) (f n.succ) ≤ ↑(d n)) → Summable d → CauchySeq f","name":"cauchySeq_of_edist_le_of_summable","isProp":true,"docString":"This theorem states that for a given sequence of elements in a pseudo-emetric space, if the extended distance between consecutive elements of this sequence is bounded by a summable series of nonnegative real numbers, then the original sequence is a Cauchy sequence. Here, a pseudo-emetric space is a set endowed with a metric-like function (the extended distance); a Cauchy sequence is a sequence where the distance between any two subsequent elements can be made arbitrarily small by going sufficiently far into the sequence; and a series is summable if the infinite series of its terms converges to a finite limit.","distance":1.879528775205223656286079858546145260334014892578125}],["Replace the current extension in a path `p` with `ext`.\n\n`ext` should not contain a `.`, as this function adds one.\nIf `ext` is the empty string, no `.` is added. ",{"type":"System.FilePath → String → System.FilePath","name":"System.FilePath.withExtension","isProp":false,"docString":"Replace the current extension in a path `p` with `ext`.\n\n`ext` should not contain a `.`, as this function adds one.\nIf `ext` is the empty string, no `.` is added. ","distance":1.8317513326944057094891604720032773911952972412109375}],["Replace `range` with `newText`.\nIf `newSelection?` is absent, place the cursor at the end of the new text.\nIf `newSelection?` is present, make the specified selection instead.\nSee also `MakeEditLinkProps.ofReplaceRange`.\n",{"type":"Lean.Server.DocumentMeta →\n  Lean.Lsp.Range → String → optParam (Option Lean.Lsp.Range) none → ProofWidgets.MakeEditLinkProps","name":"ProofWidgets.MakeEditLinkProps.ofReplaceRange'","isProp":false,"docString":"Replace `range` with `newText`.\nIf `newSelection?` is absent, place the cursor at the end of the new text.\nIf `newSelection?` is present, make the specified selection instead.\nSee also `MakeEditLinkProps.ofReplaceRange`.\n","distance":1.8357365896255790627122905789292417466640472412109375}],["Core logic of a text based linter: given a collection of lines,\nreturn an array of all style errors with line numbers. If possible,\nalso return the collection of all lines, changed as needed to fix the linter errors.\n(Such automatic fixes are only possible for some kinds of `StyleError`s.)\n",{"type":"Type","name":"Mathlib.Linter.TextBased.TextbasedLinter","isProp":false,"docString":"Core logic of a text based linter: given a collection of lines,\nreturn an array of all style errors with line numbers. If possible,\nalso return the collection of all lines, changed as needed to fix the linter errors.\n(Such automatic fixes are only possible for some kinds of `StyleError`s.)\n","distance":1.8394446170730651690661261454806663095951080322265625}],["Replace `range` with `newText`.\nIf `newSelection?` is absent, place the cursor at the end of the new text.\nIf `newSelection?` is present, select the range it specifies within `newText`.\nSee also `MakeEditLinkProps.ofReplaceRange'`. ",{"type":"Lean.Server.DocumentMeta →\n  Lean.Lsp.Range → String → optParam (Option (String.Pos × String.Pos)) none → ProofWidgets.MakeEditLinkProps","name":"ProofWidgets.MakeEditLinkProps.ofReplaceRange","isProp":false,"docString":"Replace `range` with `newText`.\nIf `newSelection?` is absent, place the cursor at the end of the new text.\nIf `newSelection?` is present, select the range it specifies within `newText`.\nSee also `MakeEditLinkProps.ofReplaceRange'`. ","distance":1.84919549137158067964037400088272988796234130859375}],["The Penrose substance program.\nNote that `embeds` are added lazily at the end. ",{"type":"ProofWidgets.Penrose.DiagramState → String","name":"ProofWidgets.Penrose.DiagramState.sub","isProp":false,"docString":"The Penrose substance program.\nNote that `embeds` are added lazily at the end. ","distance":1.8514346429394679116597899337648414075374603271484375}],["Pushforward a `Ring` instance along a surjective function. ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    (f : α → β) →\n      Function.Surjective f →\n        [inst : Add β] →\n          [inst_1 : Mul β] →\n            [inst_2 : Zero β] →\n              [inst_3 : One β] →\n                [inst_4 : Neg β] →\n                  [inst_5 : Sub β] →\n                    [inst_6 : SMul ℕ β] →\n                      [inst_7 : SMul ℤ β] →\n                        [inst_8 : Pow β ℕ] →\n                          [inst_9 : NatCast β] →\n                            [inst_10 : IntCast β] →\n                              [inst_11 : Ring α] →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : α), f (x + y) = f x + f y) →\n                                      (∀ (x y : α), f (x * y) = f x * f y) →\n                                        (∀ (x : α), f (-x) = -f x) →\n                                          (∀ (x y : α), f (x - y) = f x - f y) →\n                                            (∀ (n : ℕ) (x : α), f (n • x) = n • f x) →\n                                              (∀ (n : ℤ) (x : α), f (n • x) = n • f x) →\n                                                (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → Ring β","name":"Function.Surjective.ring","isProp":false,"docString":"Pushforward a `Ring` instance along a surjective function. ","distance":1.8585529220047387610748046427033841609954833984375}],["Pull back a pseudometric space structure by an inducing map. This is a version of\n`PseudoMetricSpace.induced` useful in case if the domain already has a `TopologicalSpace`\nstructure. ",{"type":"{α : Type u_3} →\n  {β : Type u_4} →\n    [inst : TopologicalSpace α] → [m : PseudoMetricSpace β] → {f : α → β} → Topology.IsInducing f → PseudoMetricSpace α","name":"Topology.IsInducing.comapPseudoMetricSpace","isProp":false,"docString":"Pull back a pseudometric space structure by an inducing map. This is a version of\n`PseudoMetricSpace.induced` useful in case if the domain already has a `TopologicalSpace`\nstructure. ","distance":1.85864496628507058773038806975819170475006103515625}],["A distance on an open subset `s` of a metric space, designed to make it complete.  It is given\nby `dist' x y = dist x y + |1 / dist x sᶜ - 1 / dist y sᶜ|`, where the second term blows up close to\nthe boundary to ensure that Cauchy sequences for `dist'` remain well inside `s`. ",{"type":"{α : Type u_1} → [inst : MetricSpace α] → {s : TopologicalSpace.Opens α} → Dist s.CompleteCopy","name":"TopologicalSpace.Opens.CompleteCopy.instDist","isProp":false,"docString":"A distance on an open subset `s` of a metric space, designed to make it complete.  It is given\nby `dist' x y = dist x y + |1 / dist x sᶜ - 1 / dist y sᶜ|`, where the second term blows up close to\nthe boundary to ensure that Cauchy sequences for `dist'` remain well inside `s`. ","distance":1.858981644218704598614522183197550475597381591796875}],["(Implementation detail) the constructed `GlueData.t'` from a `GlueData'`. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v, u₁} C] →\n    (D : CategoryTheory.GlueData' C) →\n      (i j k : D.J) →\n        CategoryTheory.Limits.pullback (D.f' i j) (D.f' i k) ⟶ CategoryTheory.Limits.pullback (D.f' j k) (D.f' j i)","name":"CategoryTheory.GlueData'.t''","isProp":false,"docString":"(Implementation detail) the constructed `GlueData.t'` from a `GlueData'`. ","distance":1.86358908962311620172158654895611107349395751953125}],["The optimal coupling constructed above realizes exactly the Gromov-Hausdorff distance,\nessentially by design. ",{"type":"∀ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] [inst_2 : Nonempty X] {Y : Type v}\n  [inst_3 : MetricSpace Y] [inst_4 : CompactSpace Y] [inst_5 : Nonempty Y],\n  Metric.hausdorffDist (Set.range (GromovHausdorff.optimalGHInjl X Y)) (Set.range (GromovHausdorff.optimalGHInjr X Y)) =\n    GromovHausdorff.ghDist X Y","name":"GromovHausdorff.hausdorffDist_optimal","isProp":true,"docString":"The optimal coupling constructed above realizes exactly the Gromov-Hausdorff distance,\nessentially by design. ","distance":1.8639825678203167935720330206095241010189056396484375}],["Construct a pseudo-metric space structure whose underlying topological space structure\n(definitionally) agrees which a pre-existing topology which is compatible with a given distance\nfunction. ",{"type":"{α : Type u} →\n  [inst : TopologicalSpace α] →\n    (dist : α → α → ℝ) →\n      (∀ (x : α), dist x x = 0) →\n        (∀ (x y : α), dist x y = dist y x) →\n          (∀ (x y z : α), dist x z ≤ dist x y + dist y z) →\n            (∀ (s : Set α), IsOpen s ↔ ∀ x ∈ s, ∃ ε > 0, ∀ (y : α), dist x y < ε → y ∈ s) → PseudoMetricSpace α","name":"PseudoMetricSpace.ofDistTopology","isProp":false,"docString":"Construct a pseudo-metric space structure whose underlying topological space structure\n(definitionally) agrees which a pre-existing topology which is compatible with a given distance\nfunction. ","distance":1.8646668261387262521822094640810973942279815673828125}],["Given a list of tasks, create the task returning the list of results,\nby waiting for each.\n",{"type":"{α : Type u_1} → List (Task α) → Task (List α)","name":"List.waitAll","isProp":false,"docString":"Given a list of tasks, create the task returning the list of results,\nby waiting for each.\n","distance":1.86814158702441535098159874905832111835479736328125}],["An isometry preserves the diameter in pseudometric spaces. ",{"type":"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  Isometry f → ∀ (s : Set α), Metric.diam (f '' s) = Metric.diam s","name":"Isometry.diam_image","isProp":true,"docString":"An isometry preserves the diameter in pseudometric spaces. ","distance":1.86840973884766103907395518035627901554107666015625}],["Auxiliary definition for `List.toArray`.\n`List.toArrayAux as r = r ++ as.toArray`\n",{"type":"{α : Type u_1} → List α → Array α → Array α","name":"List.toArrayAux","isProp":false,"docString":"Auxiliary definition for `List.toArray`.\n`List.toArrayAux as r = r ++ as.toArray`\n","distance":1.870661705706009758642949236673302948474884033203125}],["Pull back a right rigid structure along an equivalence. ",{"type":"{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.MonoidalCategory C] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : CategoryTheory.Functor C D} →\n              [inst_4 : F.Monoidal] →\n                {G : CategoryTheory.Functor D C} →\n                  (F ⊣ G) →\n                    [inst_5 : F.IsEquivalence] →\n                      [inst_6 : CategoryTheory.RightRigidCategory D] → CategoryTheory.RightRigidCategory C","name":"CategoryTheory.rightRigidCategoryOfEquivalence","isProp":false,"docString":"Pull back a right rigid structure along an equivalence. ","distance":1.871026052482279933286690720706246793270111083984375}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields. ",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields. ","distance":1.87352738403007723633209025138057768344879150390625}],["Pushforward a `CommRing` instance along a surjective function. ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    (f : α → β) →\n      Function.Surjective f →\n        [inst : Add β] →\n          [inst_1 : Mul β] →\n            [inst_2 : Zero β] →\n              [inst_3 : One β] →\n                [inst_4 : Neg β] →\n                  [inst_5 : Sub β] →\n                    [inst_6 : SMul ℕ β] →\n                      [inst_7 : SMul ℤ β] →\n                        [inst_8 : Pow β ℕ] →\n                          [inst_9 : NatCast β] →\n                            [inst_10 : IntCast β] →\n                              [inst_11 : CommRing α] →\n                                f 0 = 0 →\n                                  f 1 = 1 →\n                                    (∀ (x y : α), f (x + y) = f x + f y) →\n                                      (∀ (x y : α), f (x * y) = f x * f y) →\n                                        (∀ (x : α), f (-x) = -f x) →\n                                          (∀ (x y : α), f (x - y) = f x - f y) →\n                                            (∀ (n : ℕ) (x : α), f (n • x) = n • f x) →\n                                              (∀ (n : ℤ) (x : α), f (n • x) = n • f x) →\n                                                (∀ (x : α) (n : ℕ), f (x ^ n) = f x ^ n) →\n                                                  (∀ (n : ℕ), f ↑n = ↑n) → (∀ (n : ℤ), f ↑n = ↑n) → CommRing β","name":"Function.Surjective.commRing","isProp":false,"docString":"Pushforward a `CommRing` instance along a surjective function. ","distance":1.8739114720420706472481242599315010011196136474609375}],["Express `nndist` in terms of `dist`",{"type":"∀ {α : Type u} [inst : PseudoMetricSpace α] (x y : α), nndist x y = (dist x y).toNNReal","name":"nndist_dist","isProp":true,"docString":"Express `nndist` in terms of `dist`","distance":1.8746770304639970294857675980892963707447052001953125}]]