[{"name": "«term_→⋆ₙₐ_»",
  "doc":
  "A *non-unital ⋆-algebra homomorphism* is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. "},
 {"name": "Functor.«term_$>_»",
  "doc":
  "If `f` is a functor, if `fb : f β` and `a : α`, then `mapConstRev fb a` is the result of\napplying `f.map` to the constant function `β → α` sending everything to `a`, and then\nevaluating at `fb`. In other words it's `const a <$> fb`. "},
 {"name": "MeasureTheory.«term∫⁻_,_∂_»",
  "doc":
  "The **lower Lebesgue integral** of a function `f` with respect to a measure `μ`. "},
 {"name": "OreLocalization.«term_-ₒ_»",
  "doc":
  "The subtraction in the Ore localization,\nas a difference of an element of `X` and `S`."},
 {"name": "Submodule.«term_⟂_»",
  "doc":
  "The proposition that two submodules are orthogonal. Has notation `U ⟂ V`. "},
 {"name": "Sym.«term_::ₛ_»",
  "doc":
  "Inserts an element into the term of `Sym α n`, increasing the length by one.\n"},
 {"name": "Hyperreal.«termℝ*»",
  "doc": "Hyperreal numbers on the ultrafilter extending the cofinite filter "},
 {"name": "«term_→ₐc[_]_»",
  "doc":
  "Given `R`-algebras `A, B` with comultiplication maps `Δ_A, Δ_B` and counit maps\n`ε_A, ε_B`, an `R`-bialgebra homomorphism `A →ₐc[R] B` is an `R`-algebra map `f` such that\n`ε_B ∘ f = ε_A` and `(f ⊗ f) ∘ Δ_A = Δ_B ∘ f`. "},
 {"name": "«term_%_»",
  "doc":
  "`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int` it satisfies `a % b + b * (a / b) = a`,\n  and `a % 0` is defined to be `a`. "},
 {"name": "termDepIfThenElse",
  "doc":
  "\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n"},
 {"name": "Class.«term⋃₀_»",
  "doc":
  "The union of a class is the class of all members of ZFC sets in the class "},
 {"name": "«term_⊕_»",
  "doc":
  "`Sum α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.\nAn element of `α ⊕ β` is either of the form `.inl a` where `a : α`,\nor `.inr b` where `b : β`.\n"},
 {"name": "termWithout_expected_type_",
  "doc":
  "`without_expected_type t` instructs Lean to elaborate `t` without an expected type.\nRecall that terms such as `match ... with ...` and `⟨...⟩` will postpone elaboration until\nexpected type is known. So, `without_expected_type` is not effective in this case.\n"},
 {"name": "MeasureTheory.«term⨍⁻_,_»",
  "doc":
  "Average value of an `ℝ≥0∞`-valued function `f` w.r.t. to the standard measure.\n\nIt is equal to `(volume univ)⁻¹ * ∫⁻ x, f x`, so it takes value zero if the space has infinite\nmeasure. In a probability space, the average of any function is equal to its integral.\n\nFor the average on a set, use `⨍⁻ x in s, f x`, defined as `⨍⁻ x, f x ∂(volume.restrict s)`. "},
 {"name": "CategoryTheory.«term_⊣_»",
  "doc":
  "The notation `F ⊣ G` stands for `Adjunction F G` representing that `F` is left adjoint to `G` "},
 {"name": "Polynomial.«term_/ₘ_»",
  "doc": "`divByMonic` gives the quotient of `p` by a monic polynomial `q`. "},
 {"name": "LeanSearchClient.moogle_search_term",
  "doc":
  "Search [Moogle](https://www.moogle.ai/api/search) from within Lean.\nQueries should be a string that ends with a `.` or `?`. This works as a command, as a term\nand as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.\n\n```lean\n#moogle \"If a natural number n is less than m, then the successor of n is less than the successor of m.\"\n\nexample := #moogle \"If a natural number n is less than m, then the successor of n is less than the successor of m.\"\n\nexample : 3 ≤ 5 := by\n  #moogle \"If a natural number n is less than m, then the successor of n is less than the successor of m.\"\n  sorry\n```\n "},
 {"name": "ProofWidgets.«termMk_rpc_widget%_»",
  "doc":
  "The elaborator `mk_rpc_widget%` allows writing certain widgets in Lean instead of JavaScript.\nSpecifically, it translates an RPC method of type `MyProps → RequestM (RequestTask Html)`\ninto a widget component of type `Component MyProps`.\n\nEven more specifically, we can write:\n```lean\nopen Lean Server\n\nstructure MyProps where\n  ...\n  deriving RpcEncodable\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  ...\n\n@[widget_module]\ndef MyComponent : Component MyProps :=\n  mk_rpc_widget% MyComponent.rpc\n```\n\nThis is convenient because we can program the logic that computes an output HTML tree\ngiven input props in Lean directly.\n\n⚠️ However, note that there are several limitations on what such component can do\ncompared to ones written natively in TypeScript or JavaScript:\n- It must be pure, i.e. cannot directly store any React state.\n  Child components may store state as usual.\n- It cannot pass closures as props to the child components that it returns.\n  For example, it is not currently possible to write click event handlers in Lean\n  and pass them to a `<button onClick={..}>` child.\n- Every time the input props change, the infoview has to send a message to the Lean server\n  in order to invoke the RPC method.\n  Thus there can be a noticeable visual delay between the input props changing\n  and the display updating.\n  Consequently, components whose props change at a high frequency\n  (e.g. depending on the mouse position)\n  should not be implemented using this method.\n\n💡 Note that an inverse transformation is already possible.\nGiven `MyComponent : Component MyProps`, we can write:\n```lean\nopen Lean Server\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    return Html.ofComponent MyComponent ps #[]\n```\n"},
 {"name": "CategoryTheory.Limits.«term⨁_»",
  "doc":
  "`biproduct f` computes the biproduct of a family of elements `f`. (It is defined as an\nabbreviation for `limit (Discrete.functor f)`, so for most facts about `biproduct f`, you will\njust use general facts about limits and colimits.) "},
 {"name": "Lean.Parser.Term.tuple",
  "doc":
  "Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},
 {"name": "Filter.«term∃ᶠ_In_,_»",
  "doc":
  "`f.Frequently p` or `∃ᶠ x in f, p x` mean that `{x | ¬p x} ∉ f`. E.g., `∃ᶠ x in atTop, p x`\nmeans that there exist arbitrarily large `x` for which `p` holds true. "},
 {"name": "LinearMap.compNotation",
  "doc":
  "`∘ₗ` is notation for composition of two linear (not semilinear!) maps into a linear map.\nThis is useful when Lean is struggling to infer the `RingHomCompTriple` instance. "},
 {"name": "«term_→ₙ+_»",
  "doc":
  "`M →ₙ+ N` denotes the type of addition-preserving maps from `M` to `N`. "},
 {"name": "«term¬_»",
  "doc":
  "`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},
 {"name": "MeasureTheory.«term∫⁻_In_,_»",
  "doc":
  "The **lower Lebesgue integral** of a function `f` with respect to a measure `μ`. "},
 {"name": "CategoryTheory.Limits.«term∐_»",
  "doc": "notation for categorical coproducts "},
 {"name": "Vector.«term#v[_,]»", "doc": "Syntax for `Vector α n` "},
 {"name": "MeasureTheory.«term∫_In_,_»", "doc": "The Bochner integral "},
 {"name": "Relator.«term_⇒_»",
  "doc": "`(R ⇒ S) f g` means `LiftFun R S f g`. "},
 {"name": "«term_→ₛₙₐ[_]_»",
  "doc":
  "A morphism respecting addition, multiplication, and scalar multiplication. When these arise from\nalgebra structures, this is the same as a not-necessarily-unital morphism of algebras. "},
 {"name": "«term_≃ᵐ_»",
  "doc":
  "Equivalences between measurable spaces. Main application is the simplification of measurability\nstatements along measurable equivalences. "},
 {"name": "Int.«term⌈_⌉»",
  "doc":
  "`Int.ceil a` is the smallest integer `z` such that `a ≤ z`. It is denoted with `⌈a⌉`. "},
 {"name": "«term_⊇_»", "doc": "Superset relation: `a ⊇ b`  "},
 {"name": "«term‖_‖₊»", "doc": "the `ℝ≥0`-valued norm function. "},
 {"name": "«term‖_‖»", "doc": "the `ℝ`-valued norm function. "},
 {"name": "Bundle.«term_×ᵇ_»",
  "doc": "Notation for the direct sum of two bundles over the same base. "},
 {"name": "MeasureTheory.«term∫_,_∂_»", "doc": "The Bochner integral "},
 {"name": "MeasureTheory.«term⨍⁻_In_,_»",
  "doc":
  "Average value of an `ℝ≥0∞`-valued function `f` w.r.t. to the standard measure on a set `s`.\n\nIt is equal to `(volume s)⁻¹ * ∫⁻ x, f x`, so it takes value zero if `s` has infinite measure. If\n`s` has measure `1`, then the average of any function is equal to its integral. "},
 {"name": "Nat.«term⌈_⌉₊»",
  "doc": "`⌈a⌉₊` is the least natural `n` such that `a ≤ n` "},
 {"name": "«term_≃ᵃL[_]_»",
  "doc":
  "A continuous affine equivalence, denoted `P₁ ≃ᵃL[k] P₂`, between two affine topological spaces\nis an affine equivalence such that forward and inverse maps are continuous. "},
 {"name": "«termC(_,_)»",
  "doc": "The type of continuous maps from `X` to `Y`. "},
 {"name": "«term_→ₙ+*_»",
  "doc":
  "`α →ₙ+* β` denotes the type of non-unital ring homomorphisms from `α` to `β`. "},
 {"name": "«term_⊔_»", "doc": "The maximum operation: `max x y`. "},
 {"name": "MeasureTheory.«term∫⁻_,_»",
  "doc":
  "The **lower Lebesgue integral** of a function `f` with respect to a measure `μ`. "},
 {"name": "Set.«term⋃₀_»",
  "doc": "Notation for `Set.sUnion`. Union of a set of sets. "},
 {"name": "«term_!=_»",
  "doc":
  "`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x ≠ y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n"},
 {"name": "«term_[×_]→L[_]_»",
  "doc":
  "Continuous multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. "},
 {"name": "«term_→ₐc_»",
  "doc":
  "Given `R`-algebras `A, B` with comultiplication maps `Δ_A, Δ_B` and counit maps\n`ε_A, ε_B`, an `R`-bialgebra homomorphism `A →ₐc[R] B` is an `R`-algebra map `f` such that\n`ε_B ∘ f = ε_A` and `(f ⊗ f) ∘ Δ_A = Δ_B ∘ f`. "},
 {"name": "Lean.Elab.Command.«termDelta%_»",
  "doc": "`delta% t` elaborates to a head-delta reduced version of `t`. "},
 {"name": "«term∑'_,_»",
  "doc":
  "`∑' i, f i` is the sum of `f` if it exists and is unconditionally convergent,\nor 0 otherwise."},
 {"name": "«term_→ᵃ[_]_»",
  "doc":
  "An `AffineMap k P1 P2` (notation: `P1 →ᵃ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. "},
 {"name": "«term_≃+*o_»",
  "doc":
  "`OrderRingHom α β` is the type of order-preserving semiring isomorphisms between `α` and `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingIso α β)`,\nyou should parametrize over `(F : Type*) [OrderRingIsoClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingIsoClass`. "},
 {"name": "«termType*»",
  "doc":
  "The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`> 0` for each variable in the sequence. "},
 {"name": "QuadraticMap.Isometry.«term_→qᵢ_»",
  "doc":
  "An isometry between two quadratic spaces `M₁, Q₁` and `M₂, Q₂` over a ring `R`,\nis a linear map between `M₁` and `M₂` that commutes with the quadratic forms. "},
 {"name": "«termℚ≥0»", "doc": "Nonnegative rational numbers. "},
 {"name": "MeasureTheory.«term⨍_In_,_»",
  "doc":
  "Average value of a function `f` w.r.t. to the standard measure on a set `s`.\n\nIt is equal to `(volume s).toReal⁻¹ * ∫ x, f x`, so it takes value zero `f` is not integrable on `s`\nor if `s` has infinite measure. If `s` has measure `1`, then the average of any function is equal to\nits integral. "},
 {"name": "«term_\\/_»",
  "doc":
  "`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},
 {"name": "CategoryTheory.«term_ᘁ»",
  "doc": "The right dual of the object `X`. "},
 {"name": "«term_-_»",
  "doc":
  "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. "},
 {"name": "Lean.Parser.Tactic.showTermElab",
  "doc": "`show_term e` elaborates `e`, then prints the generated term.\n"},
 {"name": "AddCommGroup.«term_≡_[PMOD_]»",
  "doc":
  "`a ≡ b [PMOD p]` means that `b` is congruent to `a` modulo `p`.\n\nEquivalently (as shown in `Algebra.Order.ToIntervalMod`), `b` does not lie in the open interval\n`(a, a + p)` modulo `p`, or `toIcoMod hp a` disagrees with `toIocMod hp a` at `b`, or\n`toIcoDiv hp a` disagrees with `toIocDiv hp a` at `b`. "},
 {"name": "TensorProduct.«term_⊗ₜ[_]_»",
  "doc": "The canonical function `M → N → M ⊗ N`. "},
 {"name": "«term_≃ᵃ[_]_»",
  "doc":
  "An affine equivalence, denoted `P₁ ≃ᵃ[k] P₂`, is an equivalence between affine spaces\nsuch that both forward and inverse maps are affine.\n\nWe define it using an `Equiv` for the map and a `LinearEquiv` for the linear part in order\nto allow affine equivalences with good definitional equalities. "},
 {"name": "Lean.Parser.Term.paren",
  "doc":
  "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n"},
 {"name": "«term_↔_»",
  "doc":
  "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},
 {"name": "Mathlib.Tactic.TermCongr.termCongr",
  "doc":
  "`congr(expr)` generates an congruence from an expression containing\ncongruence holes of the form `$h` or `$(h)`.\nIn these congruence holes, `h : a = b` indicates that, in the generated congruence,\non the left-hand side `a` is substituted for `$h`\nand on the right-hand side `b` is substituted for `$h`.\n\nFor example, if `h : a = b` then `congr(1 + $h) : 1 + a = 1 + b`.\n\nThis is able to make use of the expected type, for example `(congr(_ + $h) : 1 + _ = _)`\nwith `h : x = y` gives `1 + x = 1 + y`.\nThe expected type can be an `Iff`, `Eq`, or `HEq`.\nIf there is no expected type, then it generates an equality.\n\nNote: the process of generating a congruence lemma involves elaborating the pattern\nusing terms with attached metadata and a reducible wrapper.\nWe try to avoid doing so, but these terms can leak into the local context through unification.\nThis can potentially break tactics that are sensitive to metadata or reducible functions.\nPlease report anything that goes wrong with `congr(...)` lemmas on Zulip.\n\nFor debugging, you can set `set_option trace.Elab.congr true`.\n"},
 {"name": "Lean.«term∀__,_»",
  "doc":
  "The notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n"},
 {"name": "CategoryTheory.MonoidalOpposite.«term_ᴹᵒᵖ»",
  "doc":
  "The type of objects of the opposite (or \"reverse\") monoidal category.\nUse the notation `Cᴹᵒᵖ`. "},
 {"name": "TypeVec.«term_:::_»",
  "doc": "Support for extending a `TypeVec` by one element. "},
 {"name": "Lean.termThrowErrorAt____",
  "doc":
  "Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe first argument must be a `Syntax` that provides position information for\nthe error message.\n`throwErrorAt ref msg` is equivalent to `withRef ref <| throwError msg`\n"},
 {"name": "Lean.Parser.Term.nomatch",
  "doc":
  "Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},
 {"name": "SimpleGraph.«term_→g_»",
  "doc":
  "A graph homomorphism is a map on vertex sets that respects adjacency relations.\n\nThe notation `G →g G'` represents the type of graph homomorphisms. "},
 {"name": "termSudoSet_option___In_",
  "doc":
  "The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n"},
 {"name": "Lean.Parser.Term.byTactic",
  "doc":
  "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},
 {"name": "Lean.Parser.Term.let",
  "doc":
  "`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},
 {"name": "«term_^+_»",
  "doc":
  "The notation for `FixedPoints.addSubgroup`, chosen to resemble `αᴹ`. "},
 {"name": "Function.«term↿_»",
  "doc":
  "Uncurrying operator. The most generic use is to recursively uncurry. For instance\n`f : α → β → γ → δ` will be turned into `↿f : α × β × γ → δ`. One can also add instances\nfor bundled maps. "},
 {"name": "«term_⤳_»",
  "doc":
  "`x` specializes to `y` (notation: `x ⤳ y`) if either of the following equivalent properties\nhold:\n\n* `𝓝 x ≤ 𝓝 y`; this property is used as the definition;\n* `pure x ≤ 𝓝 y`; in other words, any neighbourhood of `y` contains `x`;\n* `y ∈ closure {x}`;\n* `closure {y} ⊆ closure {x}`;\n* for any closed set `s` we have `x ∈ s → y ∈ s`;\n* for any open set `s` we have `y ∈ s → x ∈ s`;\n* `y` is a cluster point of the filter `pure x = 𝓟 {x}`.\n\nThis relation defines a `Preorder` on `X`. If `X` is a T₀ space, then this preorder is a partial\norder. If `X` is a T₁ space, then this partial order is trivial : `x ⤳ y ↔ x = y`. "},
 {"name": "Lean.Parser.Term.dbgTrace",
  "doc":
  "`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},
 {"name": "Mathlib.Notation.«term∃!__,_»",
  "doc":
  "`∃! x ∈ s, p x` means `∃! x, x ∈ s ∧ p x`, which is to say that there exists a unique `x ∈ s`\nsuch that `p x`.\nSimilarly, notations such as `∃! x ≤ n, p n` are supported,\nusing any relation defined using the `binder_predicate` command.\n"},
 {"name": "«term%[_|_]»",
  "doc":
  "Auxiliary syntax for implementing `[$elem,*]` list literal syntax.\nThe syntax `%[a,b,c|tail]` constructs a value equivalent to `a::b::c::tail`.\nIt uses binary partitioning to construct a tree of intermediate let bindings as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\n"},
 {"name": "Mathlib.Tactic.cleanStx",
  "doc":
  "`clean% t` fully elaborates `t` and then eliminates all identity functions from it.\n\nIdentity functions are normally generated with terms like `show t from p`,\nwhich translate to some variant on `@id t p` in order to retain the type.\nThese are also generated by tactics such as `dsimp` to insert type hints.\n\nExample:\n```lean\ndef x : Id Nat := by dsimp [Id]; exact 1\n#print x\n-- def x : Id Nat := id 1\n\ndef x' : Id Nat := clean% by dsimp [Id]; exact 1\n#print x'\n-- def x' : Id Nat := 1\n```\n"},
 {"name": "«termℚ_[_]»", "doc": "notation for p-padic rationals "},
 {"name": "«term_≤i_»",
  "doc": "An `InitialSeg` between the `<` relations of two types. "},
 {"name": "RCLike.«term⟪_,_⟫_[_]»",
  "doc": "Discrete inner product giving rise to the discrete L2 norm. "},
 {"name": "«MulSemiringActionHomLocal≺»",
  "doc": "Equivariant ring homomorphisms. "},
 {"name": "«term_→ₗc_»",
  "doc":
  "Given `R`-modules `A, B` with comultiplication maps `Δ_A, Δ_B` and counit maps\n`ε_A, ε_B`, an `R`-coalgebra homomorphism `A →ₗc[R] B` is an `R`-linear map `f` such that\n`ε_B ∘ f = ε_A` and `(f ⊗ f) ∘ Δ_A = Δ_B ∘ f`. "},
 {"name": "SimpleGraph.«term_⊕g_»", "doc": "Disjoint sum of `G` and `H`. "},
 {"name": "Submodule.«term_ᗮ»",
  "doc": "The subspace of vectors orthogonal to a given subspace. "},
 {"name": "LinearEquiv.transNotation",
  "doc":
  "The notation `e₁ ≪≫ₗ e₂` denotes the composition of the linear equivalences `e₁` and `e₂`. "},
 {"name": "termIfLet",
  "doc":
  "`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat => t\n| _ => e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n"},
 {"name": "Set.«term⋃_,_»",
  "doc": "Notation for `Set.iUnion`. Indexed union of a family of sets "},
 {"name": "List.Vector.«term_::ᵥ_»",
  "doc":
  "If `a : α` and `l : Vector α n`, then `cons a l`, is the vector of length `n + 1`\nwhose first element is a and with l as the rest of the list. "},
 {"name": "Lean.Parser.Term.unreachable",
  "doc": "A shorthand for `panic! \"unreachable code has been reached\"`. "},
 {"name": "Lean.Parser.Term.binrel_no_prop",
  "doc":
  "`binrel_no_prop% r a b` is similar to `binrel% r a b`, but it coerces `Prop` arguments into `Bool`. "},
 {"name": "Mathlib.ProxyType.proxy_equiv",
  "doc":
  "The term elaborator `proxy_equiv% α` for a type `α` elaborates to an equivalence `β ≃ α`\nfor a \"proxy type\" `β` composed out of basic type constructors `Unit`, `PLift`, `Sigma`,\n`Empty`, and `Sum`.\n\nThis only works for inductive types `α` that are neither recursive nor have indices.\nIf `α` is an inductive type with name `I`, then as a side effect this elaborator defines\n`I.proxyType` and `I.proxyTypeEquiv`.\n\nThe elaborator makes use of the expected type, so `(proxy_equiv% _ : _ ≃ α)` works.\n\nFor example, given this inductive type\n```\ninductive foo (n : Nat) (α : Type)\n  | a\n  | b : Bool → foo n α\n  | c (x : Fin n) : Fin x → foo n α\n  | d : Bool → α → foo n α\n```\nthe proxy type it generates is `Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α` and\nin particular we have that\n```\nproxy_equiv% (foo n α) : Unit ⊕ Bool ⊕ (x : Fin n) × Fin x ⊕ (_ : Bool) × α ≃ foo n α\n```\n"},
 {"name": "Bundle.«term_*ᵖ_»",
  "doc":
  "The pullback of a bundle `E` over a base `B` under a map `f : B' → B`, denoted by\n`Bundle.Pullback f E` or `f *ᵖ E`, is the bundle over `B'` whose fiber over `b'` is `E (f b')`. "},
 {"name": "Lean.Parser.Term.syntheticHole",
  "doc":
  "A *synthetic hole* (or *synthetic placeholder*), which stands for an unknown term that should be synthesized using tactics.\n- `?_` creates a fresh metavariable with an auto-generated name.\n- `?m` either refers to a pre-existing metavariable named `m` or creates a fresh metavariable with that name.\n\nIn particular, the synthetic hole syntax creates \"synthetic opaque metavariables\",\nthe same kind of metavariable used to represent goals in the tactic state.\n\nSynthetic holes are similar to holes in that `_` also creates metavariables,\nbut synthetic opaque metavariables have some different properties:\n- In tactics such as `refine`, only synthetic holes yield new goals.\n- During elaboration, unification will not solve for synthetic opaque metavariables, they are \"opaque\".\n  This is to prevent counterintuitive behavior such as disappearing goals.\n- When synthetic holes appear under binders, they capture local variables using a more complicated mechanism known as delayed assignment.\n\n## Delayed assigned metavariables\n\nThis section gives an overview of some technical details of synthetic holes, which you should feel free to skip.\nUnderstanding delayed assignments is mainly useful for those who are working on tactics and other metaprogramming.\nIt is included here until there is a suitable place for it in the reference manual.\n\nWhen a synthetic hole appears under a binding construct, such as for example `fun (x : α) (y : β) => ?s`,\nthe system creates a *delayed assignment*. This consists of\n1. A metavariable `?m` of type `(x : α) → (y : β) → γ x y` whose local context is the local context outside the `fun`,\n  where `γ x y` is the type of `?s`. Recall that `x` and `y` appear in the local context of `?s`.\n2. A delayed assigment record associating `?m` to `?s` and the variables `#[x, y]` in the local context of `?s`\n\nThen, this function elaborates as `fun (x : α) (y : β) => ?m x y`, where one should understand `x` and `y` here\nas being De Bruijn indexes, since Lean uses the locally nameless encoding of lambda calculus.\n\nOnce `?s` is fully solved for, in the sense that after metavariable instantiation it is a metavariable-free term `e`,\nthen we can make the assignment `?m := fun (x' : α) (y' : β) => e[x := x', y := y']`.\n(Implementation note: Lean only instantiates full applications `?m x' y'` of delayed assigned metavariables, to skip forming this function.)\nThis delayed assignment mechanism is essential to the operation of basic tactics like `intro`,\nand a good mental model is that it is a way to \"apply\" the metavariable `?s` by substituting values in for some of its local variables.\nWhile it would be easier to immediately assign `?s := ?m x y`,\ndelayed assigment preserves `?s` as an unsolved-for metavariable with a local context that still contains `x` and `y`,\nwhich is exactly what tactics like `intro` need.\n\nBy default, delayed assigned metavariables pretty print with what they are delayed assigned to.\nThe delayed assigned metavariables themselves can be pretty printed using `set_option pp.mvars.delayed true`.\n\nFor more information, see the \"Gruesome details\" module docstrings in `Lean.MetavarContext`.\n"},
 {"name": "«term_++_»",
  "doc":
  "`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. "},
 {"name": "«term_≥_»", "doc": "`a ≥ b` is an abbreviation for `b ≤ a`. "},
 {"name": "«term_<i_»",
  "doc": "A `PrincipalSeg` between the `<` relations of two types. "},
 {"name": "«term_≼i_»",
  "doc":
  "If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose range is an initial segment. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. "},
 {"name": "Nat.«termOrdProj[_]_»",
  "doc":
  "We introduce the notations `ordProj[p] n` for the largest power of the prime `p` that\ndivides `n` and `ordCompl[p] n` for the complementary part. The `ord` naming comes from\nthe $p$-adic order/valuation of a number, and `proj` and `compl` are for the projection and\ncomplementary projection. The term `n.factorization p` is the $p$-adic order itself.\nFor example, `ordProj[2] n` is the even part of `n` and `ordCompl[2] n` is the odd part. "},
 {"name": "Complex.«term_×ℂ_»",
  "doc":
  "The product of a set on the real axis and a set on the imaginary axis of the complex plane,\ndenoted by `s ×ℂ t`. "},
 {"name": "MeasureTheory.«term_=ᵐ[_]_»",
  "doc":
  "`f =ᵐ[μ] g` means `f` and `g` are eventually equal along the a.e. filter,\ni.e. `f=g` away from a null set.\n\nThis is notation for `Filter.EventuallyEq (MeasureTheory.ae μ) f g`. "},
 {"name": "«termℕ∞»", "doc": "Extended natural numbers `ℕ∞ = WithTop ℕ`. "},
 {"name": "«term_→ₛₗᵢ[_]_»",
  "doc":
  "A `σ₁₂`-semilinear isometric embedding of a normed `R`-module into an `R₂`-module. "},
 {"name": "«term_≈_»",
  "doc":
  "`x ≈ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. "},
 {"name": "CategoryTheory.exp.«term_^^_»",
  "doc": "Morphisms from an exponentiable object. "},
 {"name": "Function.«term_↪_»",
  "doc": "An embedding, a.k.a. a bundled injective function. "},
 {"name": "FirstOrder.Language.«term_⊨__1»",
  "doc":
  "A model of a theory is a structure in which every sentence is realized as true. "},
 {"name": "«term_==_»", "doc": "Boolean equality, notated as `a == b`. "},
 {"name": "Lean.Elab.Term.CoeImpl.«term(↥)»",
  "doc":
  "Partially applied type coercion.  Equivalent to the η-reduction of `(↥ ·)` "},
 {"name": "CategoryTheory.Limits.«term_⨿_»",
  "doc": "Notation for the coproduct "},
 {"name": "«term_+ᵥ_»",
  "doc":
  "`a +ᵥ b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "«term_≃+o_»", "doc": "Infix notation for `OrderAddMonoidIso`. "},
 {"name": "«term_→*_»",
  "doc": "`M →* N` denotes the type of monoid homomorphisms from `M` to `N`. "},
 {"name": "«termLine[_,_,_]»",
  "doc": "The line between two points, as an affine subspace. "},
 {"name": "«term∅»",
  "doc":
  "`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},
 {"name": "CategoryTheory.ihom.«term_⟶[_]_»",
  "doc": "`A ⟶[C] B` denotes the internal hom from `A` to `B` "},
 {"name": "Lean.«term∃__,_»",
  "doc":
  "The notation `∃ x < 2, p x` is shorthand for `∃ x, x < 2 ∧ p x`,\nand similarly for other binary operators.\n"},
 {"name": "Lean.Parser.Term.quotedName", "doc": "A literal of type `Name`. "},
 {"name": "«term_+_»",
  "doc":
  "`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Cardinal.«term_^<_»",
  "doc":
  "The function `a ^< b`, defined as the supremum of `a ^ c` for `c < b`. "},
 {"name": "«term_→ₙₐ_»",
  "doc":
  "A morphism respecting addition, multiplication, and scalar multiplication. When these arise from\nalgebra structures, this is the same as a not-necessarily-unital morphism of algebras. "},
 {"name": "BigOperators.bigsum",
  "doc":
  "- `∑ x, f x` is notation for `Finset.sum Finset.univ f`. It is the sum of `f x`,\n  where `x` ranges over the finite domain of `f`.\n- `∑ x ∈ s, f x` is notation for `Finset.sum s f`. It is the sum of `f x`,\n  where `x` ranges over the finite set `s` (either a `Finset` or a `Set` with a `Fintype` instance).\n- `∑ x ∈ s with p x, f x` is notation for `Finset.sum (Finset.filter p s) f`.\n- `∑ (x ∈ s) (y ∈ t), f x y` is notation for `Finset.sum (s ×ˢ t) (fun ⟨x, y⟩ ↦ f x y)`.\n\nThese support destructuring, for example `∑ ⟨x, y⟩ ∈ s ×ˢ t, f x y`.\n\nNotation: `\"∑\" bigOpBinders* (\"with\" term)? \",\" term` "},
 {"name": "CategoryTheory.«term_⥤ₗ_»",
  "doc": "`C ⥤ₗ D` denotes left exact functors `C ⥤ D` "},
 {"name": "Mathlib.Notation3.«termExpand_binders%(_=>_)_,_»",
  "doc":
  "Expands binders into nested combinators.\nFor example, the familiar exists is given by:\n`expand_binders% (p => Exists p) x y : Nat, x < y`\nwhich expands to the same expression as\n`∃ x y : Nat, x < y`\n"},
 {"name": "BigOperators.bigprodin",
  "doc":
  "(Deprecated, use `∏ x ∈ s, f x`)\n`∏ x in s, f x` is notation for `Finset.prod s f`. It is the product of `f x`,\nwhere `x` ranges over the finite set `s`. "},
 {"name": "«term_≤₁_»",
  "doc":
  "`p` is one-one reducible to `q` if there is an injective computable function translating questions\nabout `p` to questions about `q`.\n"},
 {"name": "PSigma.«termΣₗ'_,_»",
  "doc":
  "The notation `Σₗ' i, α i` refers to a sigma type which is locally equipped with the\nlexicographic order. "},
 {"name": "«term_<|_»",
  "doc":
  "Haskell-like pipe operator `<|`. `f <| x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f <| g <| x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},
 {"name": "«term_≠_»",
  "doc":
  "`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n"},
 {"name": "«term_→ₗ⁅_⁆_»",
  "doc":
  "A morphism of Lie algebras is a linear map respecting the bracket operations. "},
 {"name": "ExteriorAlgebra.«term⋀[_]^_»",
  "doc":
  "Definition of the `n`th exterior power of a `R`-module `N`. We introduce the notation\n`⋀[R]^n M` for `exteriorPower R n M`. "},
 {"name": "coeSortNotation", "doc": "`↥ t` coerces `t` to a type. "},
 {"name": "Matrix.vecNotation",
  "doc":
  "`![...]` notation is used to construct a vector `Fin n → α` using `Matrix.vecEmpty` and\n`Matrix.vecCons`.\n\nFor instance, `![a, b, c] : Fin 3` is syntax for `vecCons a (vecCons b (vecCons c vecEmpty))`.\n\nNote that this should not be used as syntax for `Matrix` as it generates a term with the wrong type.\nThe `!![a, b; c, d]` syntax (provided by `Matrix.matrixNotation`) should be used instead.\n"},
 {"name": "Lean.Parser.Term.anonymousCtor",
  "doc":
  "The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},
 {"name": "List.«term_<:+_»",
  "doc":
  "`IsSuffix l₁ l₂`, or `l₁ <:+ l₂`, means that `l₁` is a suffix of `l₂`,\nthat is, `l₂` has the form `t ++ l₁` for some `t`.\n"},
 {"name": "«term_⁻¹'o_»",
  "doc":
  "Given a relation `R` on `β` and a function `f : α → β`, the preimage relation on `α` is defined\nby `x ≤ y ↔ f x ≤ f y`. It is the unique relation on `α` making `f` a `RelEmbedding` (assuming `f`\nis injective). "},
 {"name": "«term_≃ₗ⁅_⁆_»",
  "doc":
  "An equivalence of Lie algebras is a morphism which is also a linear equivalence. We could\ninstead define an equivalence to be a morphism which is also a (plain) equivalence. However it is\nmore convenient to define via linear equivalence to get `.toLinearEquiv` for free. "},
 {"name": "CategoryTheory.Limits.«term⊥__»",
  "doc": "Notation for the initial object in `C` "},
 {"name": "«term⁅_,_⁆»",
  "doc":
  "`⁅x, y⁆` is the result of a bracket operation on elements `x` and `y`.\nIt is supported by the `Bracket` typeclass. "},
 {"name": "«termCompile_time_search_path%»",
  "doc":
  "Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then imported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n"},
 {"name": "CategoryTheory.ReflPrefunctor.«term_⥤rq_»",
  "doc": "Notation for a prefunctor between reflexive quivers. "},
 {"name": "«termSort*»",
  "doc":
  "The syntax `variable (X Y ... Z : Sort*)` creates a new distinct implicit universe variable\nfor each variable in the sequence. "},
 {"name": "Lean.Parser.Tactic.by?",
  "doc":
  "The command `by?` will print a suggestion for replacing the proof block with a proof term\nusing `show_term`.\n"},
 {"name": "«term_<|>_»",
  "doc":
  "`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},
 {"name": "termℂ",
  "doc":
  "Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. "},
 {"name": "Lean.Parser.Term.cdot",
  "doc":
  "A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},
 {"name": "MeasureTheory.«term_→ₘ[_]_»",
  "doc":
  "The space of equivalence classes of almost everywhere strongly measurable functions, where two\nstrongly measurable functions are equivalent if they agree almost everywhere, i.e.,\nthey differ on a set of measure `0`. "},
 {"name": "Nat.«termOrdCompl[_]_»",
  "doc":
  "We introduce the notations `ordProj[p] n` for the largest power of the prime `p` that\ndivides `n` and `ordCompl[p] n` for the complementary part. The `ord` naming comes from\nthe $p$-adic order/valuation of a number, and `proj` and `compl` are for the projection and\ncomplementary projection. The term `n.factorization p` is the $p$-adic order itself.\nFor example, `ordProj[2] n` is the even part of `n` and `ordCompl[2] n` is the odd part. "},
 {"name": "«term_⋖_»", "doc": "Notation for `CovBy a b`. "},
 {"name": "Lean.Parser.Term.typeAscription",
  "doc":
  "Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},
 {"name": "Sum.Lex.«term_⊕ₗ_»", "doc": "The linear sum of two orders "},
 {"name": "«term_↪r_»",
  "doc":
  "A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`. "},
 {"name": "FirstOrder.Language.«term_→ᴸ_»",
  "doc":
  "A language homomorphism maps the symbols of one language to symbols of another. "},
 {"name": "Mathlib.Deriving.Fintype.«termDerive_fintype%_»",
  "doc":
  "The term elaborator `derive_fintype% α` tries to synthesize a `Fintype α` instance\nusing all the assumptions in the local context; this can be useful, for example, if one\nneeds an extra `DecidableEq` instance. It works only if `α` is an inductive\ntype that `proxy_equiv% α` can handle. The elaborator makes use of the\nexpected type, so `(derive_fintype% _ : Fintype α)` works.\n\nThis uses `proxy_equiv% α`, so as a side effect it defines `proxyType` and `proxyTypeEquiv` in\nthe namespace associated to the inductive type `α`.\n"},
 {"name": "CategoryTheory.«termᘁ_»",
  "doc": "The left dual of the object `X`. "},
 {"name": "«term_→⋆ₙₐ[_]_»",
  "doc":
  "A *non-unital ⋆-algebra homomorphism* is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. "},
 {"name": "Mathlib.Tactic.Sat.termFrom_lrat___",
  "doc":
  "A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `from_lrat` term syntax is two string expressions with\nthe statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\ndef foo := from_lrat\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : ∀ (a a_1 : Prop), (¬a ∧ ¬a_1 ∨ a ∧ ¬a_1) ∨ ¬a ∧ a_1 ∨ a ∧ a_1\n```\n\n* You can use this term after `have :=` or in `def foo :=` to produce the term\n  without constraining the type.\n* You can use it when a specific type is expected, but it currently does not\n  pay any attention to the shape of the goal and always produces the same theorem,\n  so you can only use this to do alpha renaming.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n"},
 {"name": "«term_→+o_»", "doc": "Infix notation for `OrderAddMonoidHom`. "},
 {"name": "Mathlib.Meta.setBuilder",
  "doc":
  "Set builder syntax. This can be elaborated to either a `Set` or a `Finset` depending on context.\n\nThe elaborators for this syntax are located in:\n* `Data.Set.Defs` for the `Set` builder notation elaborator for syntax of the form `{x | p x}`,\n  `{x : α | p x}`, `{binder x | p x}`.\n* `Data.Finset.Basic` for the `Finset` builder notation elaborator for syntax of the form\n  `{x ∈ s | p x}`.\n* `Data.Fintype.Basic` for the `Finset` builder notation elaborator for syntax of the form\n  `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.\n* `Order.LocallyFinite.Basic` for the `Finset` builder notation elaborator for syntax of the form\n  `{x ≤ a | p x}`, `{x ≥ a | p x}`, `{x < a | p x}`, `{x > a | p x}`.\n"},
 {"name": "CategoryTheory.«term_⟦_⟧»",
  "doc": "shifting an object `X` by `n` is obtained by the notation `X⟦n⟧` "},
 {"name": "CategoryTheory.«termReassoc_of%_»",
  "doc":
  "`reassoc_of% t`, where `t` is\nan equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\n"},
 {"name": "termℚ",
  "doc":
  "Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n"},
 {"name": "AlgebraicGeometry.«termProj|_»",
  "doc": "`Proj` restrict to some open set "},
 {"name": "«term[_]»",
  "doc":
  "The syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n"},
 {"name": "PiTensorProduct.«term⨂ₜ[_]_,_»",
  "doc":
  "The canonical `MultilinearMap R s (⨂[R] i, s i)`.\n\n`tprod R fun i => f i` has notation `⨂ₜ[R] i, f i`. "},
 {"name": "«term_→ₗc[_]_»",
  "doc":
  "Given `R`-modules `A, B` with comultiplication maps `Δ_A, Δ_B` and counit maps\n`ε_A, ε_B`, an `R`-coalgebra homomorphism `A →ₗc[R] B` is an `R`-linear map `f` such that\n`ε_B ∘ f = ε_A` and `(f ⊗ f) ∘ Δ_A = Δ_B ∘ f`. "},
 {"name": "termℕ",
  "doc":
  "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n"},
 {"name": "«term_≃ₗc[_]_»",
  "doc":
  "An equivalence of coalgebras is an invertible coalgebra homomorphism. "},
 {"name": "Lean.Parser.Term.omission",
  "doc":
  "The `⋯` term denotes a term that was omitted by the pretty printer.\nThe presence of `⋯` in pretty printer output is controlled by the `pp.deepTerms` and `pp.proofs` options,\nand these options can be further adjusted using `pp.deepTerms.threshold` and `pp.proofs.threshold`.\n\nIt is only meant to be used for pretty printing.\nHowever, in case it is copied and pasted from the Infoview, `⋯` logs a warning and elaborates like `_`.\n"},
 {"name": "MeasureTheory.«term⨍⁻_,_∂_»",
  "doc":
  "Average value of an `ℝ≥0∞`-valued function `f` w.r.t. a measure `μ`.\n\nIt is equal to `(μ univ)⁻¹ * ∫⁻ x, f x ∂μ`, so it takes value zero if `μ` is an infinite measure. If\n`μ` is a probability measure, then the average of any function is equal to its integral.\n\nFor the average on a set, use `⨍⁻ x in s, f x ∂μ`, defined as `⨍⁻ x, f x ∂(μ.restrict s)`. For the\naverage w.r.t. the volume, one can omit `∂volume`. "},
 {"name": "«MulActionHomIdLocal≺»",
  "doc":
  "`M`-equivariant functions `X → Y` with respect to the action of `M`.\nThis is the same as `X →ₑ[@id M] Y`. "},
 {"name": "«term_≃ₗᵢ⋆[_]_»",
  "doc":
  "An antilinear isometric equivalence between two normed vector spaces. "},
 {"name": "ZFSet.«term⋃₀_»",
  "doc":
  "The union operator, the collection of elements of elements of a ZFC set "},
 {"name": "«term_→*₀o_»",
  "doc": "Infix notation for `OrderMonoidWithZeroHom`. "},
 {"name": "OmegaCompletePartialOrder.«term_→𝒄_»",
  "doc":
  "A monotone function on `ω`-continuous partial orders is said to be continuous\nif for every chain `c : chain α`, `f (⊔ i, c i) = ⊔ i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. "},
 {"name": "ContinuousLinearMap.«term_∘L_»",
  "doc": "Composition of bounded linear maps. "},
 {"name": "«term_→₀_»",
  "doc":
  "`Finsupp α M`, denoted `α →₀ M`, is the type of functions `f : α → M` such that\n`f x = 0` for all but finitely many `x`. "},
 {"name": "«term_≃L[_]_»",
  "doc":
  "Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `M₂` will be topological modules over the\ntopological semiring `R`. "},
 {"name": "«term_ᵒᵈ»",
  "doc":
  "Type synonym to equip a type with the dual order: `≤` means `≥` and `<` means `>`. `αᵒᵈ` is\nnotation for `OrderDual α`. "},
 {"name": "«term_<*>_»",
  "doc":
  "If `mf : F (α → β)` and `mx : F α`, then `mf <*> mx : F β`.\nIn a monad this is the same as `do let f ← mf; x ← mx; pure (f x)`:\nit evaluates first the function, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n`Unit → f α` function. "},
 {"name": "Lean.withAnnotateTerm",
  "doc":
  "`with_annotate_term stx e` annotates the lexical range of `stx : Syntax` with term info for `e`. "},
 {"name": "«term‹_›»",
  "doc":
  "`‹t›` resolves to an (arbitrary) hypothesis of type `t`.\nIt is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type;\nin particular, `‹_›` is a shortcut for `by assumption`.\n"},
 {"name": "«term_→ₗᵢ⋆[_]_»",
  "doc":
  "An antilinear isometric embedding of a normed `R`-module into another one. "},
 {"name": "«term_>_»", "doc": "`a > b` is an abbreviation for `b < a`. "},
 {"name": "Filter.«term∀ᶠ_In_,_»",
  "doc":
  "`f.Eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in atTop, p x`\nmeans that `p` holds true for sufficiently large `x`. "},
 {"name": "«term__[_]'_»",
  "doc":
  "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n"},
 {"name": "«term_≃⋆ₐ_»",
  "doc":
  "A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. "},
 {"name": "Lean.Parser.Term.let_fun",
  "doc":
  "`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},
 {"name": "BigOperators.bigprod",
  "doc":
  "- `∏ x, f x` is notation for `Finset.prod Finset.univ f`. It is the product of `f x`,\n  where `x` ranges over the finite domain of `f`.\n- `∏ x ∈ s, f x` is notation for `Finset.prod s f`. It is the product of `f x`,\n  where `x` ranges over the finite set `s` (either a `Finset` or a `Set` with a `Fintype` instance).\n- `∏ x ∈ s with p x, f x` is notation for `Finset.prod (Finset.filter p s) f`.\n- `∏ (x ∈ s) (y ∈ t), f x y` is notation for `Finset.prod (s ×ˢ t) (fun ⟨x, y⟩ ↦ f x y)`.\n\nThese support destructuring, for example `∏ ⟨x, y⟩ ∈ s ×ˢ t, f x y`.\n\nNotation: `\"∏\" bigOpBinders* (\"with\" term)? \",\" term` "},
 {"name": "«term_∧_»",
  "doc":
  "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n"},
 {"name": "«term_|>_»",
  "doc":
  "Haskell-like pipe operator `|>`. `x |> f` means the same as the same as `f x`,\nand it chains such that `x |> f |> g` is interpreted as `g (f x)`.\n"},
 {"name": "MeasureTheory.«term∀ᵐ_∂_,_»",
  "doc":
  "`∀ᵐ a ∂μ, p a` means that `p a` for a.e. `a`, i.e. `p` holds true away from a null set.\n\nThis is notation for `Filter.Eventually p (MeasureTheory.ae μ)`. "},
 {"name": "BigOperators.bigsumin",
  "doc":
  "(Deprecated, use `∑ x ∈ s, f x`)\n`∑ x in s, f x` is notation for `Finset.sum s f`. It is the sum of `f x`,\nwhere `x` ranges over the finite set `s`. "},
 {"name": "Lean.Parser.Term.haveI",
  "doc":
  "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. "},
 {"name": "«term_≃ᵤ_»", "doc": "Uniform isomorphism between `α` and `β` "},
 {"name": "MeasureTheory.«term_→₁ₛ[_]_»",
  "doc":
  "`Lp.simpleFunc` is a subspace of Lp consisting of equivalence classes of an integrable simple\nfunction. "},
 {"name": "«DistribMulActionHomIdLocal≺»",
  "doc": "Equivariant additive monoid homomorphisms. "},
 {"name": "term₂F₁",
  "doc":
  "`ordinaryHypergeometric (a b c : 𝕂) : 𝔸 → 𝔸` is the ordinary hypergeometric map, defined as the\nsum of the `FormalMultilinearSeries` `ordinaryHypergeometricSeries 𝔸 a b c`.\n\nNote that this takes the junk value `0` outside the radius of convergence.\n"},
 {"name": "Set.term_''_",
  "doc":
  "`f '' s` denotes the image of `s : Set α` under the function `f : α → β`. "},
 {"name": "«term_ᵈᵐᵃ»",
  "doc":
  "If `M` multiplicatively acts on `α`, then `DomMulAct M` acts on `α → β` as well as some\nbundled maps from `α`. This is a type synonym for `MulOpposite M`, so this corresponds to a right\naction of `M`. "},
 {"name": "«term_≃⋆ₐ[_]_»",
  "doc":
  "A *⋆-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. "},
 {"name": "«term_::_»",
  "doc":
  "If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the\nlist whose first element is `a` and with `l` as the rest of the list. "},
 {"name": "CategoryTheory.«term_≅_»",
  "doc": "Notation for an isomorphism in a category. "},
 {"name": "«term_→ₗ⋆[_]_»",
  "doc":
  "`M →ₗ⋆[R] N` is the type of `R`-conjugate-linear maps from `M` to `N`. "},
 {"name": "FirstOrder.Language.«term_⊨_»",
  "doc": "A sentence can be evaluated as true or false in a structure. "},
 {"name": "«term_⋊[_]_»",
  "doc":
  "The semidirect product of groups `N` and `G`, given a map `φ` from `G` to the automorphism\ngroup of `N`. It the product of sets with the group operation\n`⟨n₁, g₁⟩ * ⟨n₂, g₂⟩ = ⟨n₁ * φ g₁ n₂, g₁ * g₂⟩` "},
 {"name": "RCLike.«term⟪_,_⟫_[_,_]»",
  "doc": "Weighted inner product giving rise to the L2 norm. "},
 {"name": "«term__[_]_!»",
  "doc":
  "The syntax `arr[i]!` gets the `i`'th element of the collection `arr` and\npanics `i` is out of bounds.\n"},
 {"name": "finsetStx",
  "doc":
  "`finset% t` elaborates `t` as a `Finset`.\nIf `t` is a `Set`, then inserts `Set.toFinset`.\nDoes not make use of the expected type; useful for big operators over finsets.\n```\n#check finset% Finset.range 2 -- Finset Nat\n#check finset% (Set.univ : Set Bool) -- Finset Bool\n```\n"},
 {"name": "MeasureTheory.«term∃ᵐ_∂_,_»",
  "doc":
  "`∃ᵐ a ∂μ, p a` means that `p` holds `∂μ`-frequently,\ni.e. `p` holds on a set of positive measure.\n\nThis is notation for `Filter.Frequently p (MeasureTheory.ae μ)`. "},
 {"name": "«AddActionHomIdLocal≺»",
  "doc":
  "`M`-equivariant functions `X → Y` with respect to the additive action of `M`.\nThis is the same as `X →ₑ[@id M] Y`.\n\nWe use the same notation as for multiplicative actions, as conflicts are unlikely. "},
 {"name": "«term_↪o_»", "doc": "Notation for an `OrderEmbedding`. "},
 {"name": "«term_⊼_»", "doc": "The point-wise infimum `a ⊓ b` of `a, b : α`. "},
 {"name": "«term_<=<_»",
  "doc": "Right-to-left composition of Kleisli arrows. "},
 {"name": "«term_→SL[_]_»",
  "doc":
  "Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `M₂` will be topological modules over the topological\nring `R`. "},
 {"name": "Lean.Parser.Term.inaccessible",
  "doc":
  "`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},
 {"name": "Lean.Parser.Term.rightact",
  "doc":
  "`rightact% f a b` elaborates `f a b` as a right action using the type propagation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `b`, where only the left argument `a` participates in the operator coercion elaborator. "},
 {"name": "PSet.«term⋃₀_»", "doc": "The pre-set union operator "},
 {"name": "«term_$__»",
  "doc":
  "Alternative syntax for `<|`. `f $ x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f $ g $ x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},
 {"name": "CategoryTheory.Iso.«term_≪≫_»",
  "doc": "Notation for composition of isomorphisms. "},
 {"name": "«term_-ᵥ_»",
  "doc":
  "`a -ᵥ b` computes the difference of `a` and `b`. The meaning of this notation is\ntype-dependent, but it is intended to be used for additive torsors. "},
 {"name": "Lean.Parser.Term.let_tmp",
  "doc":
  "`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},
 {"name": "«term_/_»",
  "doc":
  "`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b < natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.div` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. "},
 {"name": "«term_>>_»",
  "doc":
  "`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},
 {"name": "Lean.Parser.Term.structInst",
  "doc":
  "Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},
 {"name": "FirstOrder.Language.Theory.«term_⊨ᵇ_»",
  "doc":
  "A theory models a (bounded) formula when any of its nonempty models realizes that formula on all\ninputs. "},
 {"name": "«term_→ₛₗ[_]_»",
  "doc": "`M →ₛₗ[σ] N` is the type of `σ`-semilinear maps from `M` to `N`. "},
 {"name": "Nat.«term_≡_[MOD_]»",
  "doc":
  "Modular equality. `n.ModEq a b`, or `a ≡ b [MOD n]`, means that `a - b` is a multiple of `n`. "},
 {"name": "«termΠ₀_,_»",
  "doc":
  "`Π₀ i, β i` denotes the type of dependent functions with finite support `DFinsupp β`. "},
 {"name": "«term_→o_»", "doc": "Notation for an `OrderHom`. "},
 {"name": "Class.«term⋂₀_»",
  "doc":
  "The intersection of a class is the class of all members of ZFC sets in the class "},
 {"name": "«term_≃SL[_]_»",
  "doc":
  "Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `M₂` will be topological modules over the\ntopological semiring `R`. "},
 {"name": "«term_∩_»", "doc": "`a ∩ b` is the intersection of`a` and `b`. "},
 {"name": "«term_≃o_»", "doc": "Notation for an `OrderIso`. "},
 {"name": "«term_⊃_»", "doc": "Strict superset relation: `a ⊃ b`  "},
 {"name": "adaptationNoteTermStx",
  "doc":
  "Adaptation notes are comments that are used to indicate that a piece of code\nhas been changed to accommodate a change in Lean core.\nThey typically require further action/maintenance to be taken in the future. "},
 {"name": "MeasureTheory.«term⨍_In_,_∂_»",
  "doc":
  "Average value of a function `f` w.r.t. a measure `μ` on a set `s`.\n\nIt is equal to `(μ s).toReal⁻¹ * ∫ x, f x ∂μ`, so it takes value zero if `f` is not integrable on\n`s` or if `s` has infinite measure. If `s` has measure `1`, then the average of any function is\nequal to its integral.\n\nFor the average w.r.t. the volume, one can omit `∂volume`. "},
 {"name": "term!_",
  "doc":
  "`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop → Prop`, which is the propositional connective).\n"},
 {"name": "«term_∉_»",
  "doc": "`a ∉ b` is negated elementhood. It is notation for `¬ (a ∈ b)`. "},
 {"name": "«term_≃ₗ⁅_,_⁆_»",
  "doc":
  "An equivalence of Lie algebra modules is a linear equivalence which is also a morphism of\nLie algebra modules. "},
 {"name": "Lean.Parser.Term.quot", "doc": "Syntax quotation for terms. "},
 {"name": "Lean.Parser.Term.declName",
  "doc":
  "A macro which evaluates to the name of the currently elaborating declaration. "},
 {"name": "«term⅟_»", "doc": "The inverse of an `Invertible` element "},
 {"name": "«term_\\_»",
  "doc":
  "`a \\ b` is the set difference of `a` and `b`,\nconsisting of all elements in `a` that are not in `b`.\n"},
 {"name": "PiNotation.«termΠ__,_»",
  "doc":
  "Dependent function type (a \"pi type\"). The notation `Π x ∈ s, β x` is\nshort for `Π x, x ∈ s → β x`. "},
 {"name": "CategoryTheory.ReflPrefunctor.«term𝟭rq»",
  "doc": "Notation for the identity prefunctor on a reflexive quiver. "},
 {"name": "«term_→ᴬ[_]_»", "doc": "A continuous map of affine spaces. "},
 {"name": "CategoryTheory.«term_⥤+_»",
  "doc": "the category of additive functors is denoted `C ⥤+ D` "},
 {"name": "Lean.Parser.Term.binrel",
  "doc":
  "`binrel% r a b` elaborates `r a b` as a binary relation using the type propagation protocol in `Lean.Elab.Extra`. "},
 {"name": "«term⨅_,_»", "doc": "Indexed infimum. "},
 {"name": "«term_→*o_»", "doc": "Infix notation for `OrderMonoidHom`. "},
 {"name": "Lean.modCast",
  "doc":
  "Normalize casts in an expression using the same method as the `norm_cast` tactic. "},
 {"name": "«term⨆_,_»", "doc": "Indexed supremum. "},
 {"name": "«term_⊆_»", "doc": "Subset relation: `a ⊆ b`  "},
 {"name": "Lean.Parser.Term.borrowed",
  "doc":
  "Indicates that an argument to a function marked `@[extern]` is borrowed.\n\nBeing borrowed only affects the ABI and runtime behavior of the function when compiled or interpreted. From the perspective of Lean's type system, this annotation has no effect. It similarly has no effect on functions not marked `@[extern]`.\n\nWhen a function argument is borrowed, the function does not consume the value. This means that the function will not decrement the value's reference count or deallocate it, and the caller is responsible for doing so.\n\nPlease see https://lean-lang.org/lean4/doc/dev/ffi.html#borrowing for a complete description.\n"},
 {"name": "Lean.Parser.Term.termUnless",
  "doc": "`unless e do s` is a nicer way to write `if !e do s`. "},
 {"name": "«term∏'_,_»",
  "doc":
  "`∏' i, f i` is the product of `f` if it exists and is unconditionally convergent,\nor 1 otherwise. "},
 {"name": "«term_∈_»",
  "doc": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. "},
 {"name": "«term_≃ₗ⋆[_]_»",
  "doc":
  "The notation `M ≃ₗ⋆[R] M₂` denotes the type of star-linear equivalences between `M` and `M₂`\nover the `⋆` endomorphism of the underlying starred ring `R`. "},
 {"name": "Asymptotics.«term_=o[_]_»",
  "doc":
  "The Landau notation `f =o[l] g` where `f` and `g` are two functions on a type `α` and `l` is\na filter on `α`, means that eventually for `l`, `‖f‖` is bounded by an arbitrarily small constant\nmultiple of `‖g‖`. In other words, `‖f‖ / ‖g‖` tends to `0` along `l`, modulo division by zero\nissues that are avoided by this definition. "},
 {"name": "CategoryTheory.Limits.«term_⊞_»",
  "doc": "An arbitrary choice of biproduct of a pair of objects. "},
 {"name": "Batteries.Tactic.lambdaDot",
  "doc": "The syntax `λ.` has been deprecated in favor of `nofun`. "},
 {"name": "«term|___|ₘ»", "doc": "`mabs a` is the absolute value of `a`. "},
 {"name": "Mathlib.Meta.«term{_|_}»",
  "doc":
  "`{ f x y | (x : X) (y : Y) }` is notation for the set of elements `f x y` constructed from the\nbinders `x` and `y`, equivalent to `{z : Z | ∃ x y, f x y = z}`.\n\nIf `f x y` is a single identifier, it must be parenthesized to avoid ambiguity with `{x | p x}`;\nfor instance, `{(x) | (x : Nat) (y : Nat) (_hxy : x = y^2)}`.\n"},
 {"name": "MeasureTheory.«term⨍⁻_In_,_∂_»",
  "doc":
  "Average value of an `ℝ≥0∞`-valued function `f` w.r.t. a measure `μ` on a set `s`.\n\nIt is equal to `(μ s)⁻¹ * ∫⁻ x, f x ∂μ`, so it takes value zero if `s` has infinite measure. If `s`\nhas measure `1`, then the average of any function is equal to its integral.\n\nFor the average w.r.t. the volume, one can omit `∂volume`. "},
 {"name": "«term_→+_»",
  "doc":
  "`M →+ N` denotes the type of additive monoid homomorphisms from `M` to `N`. "},
 {"name": "Lean.byElab",
  "doc":
  "* The `by_elab doSeq` expression runs the `doSeq` as a `TermElabM Expr` to\n  synthesize the expression.\n* `by_elab fun expectedType? => do doSeq` receives the expected type (an `Option Expr`)\n  as well.\n"},
 {"name": "«term_^^^_»",
  "doc":
  "`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Lean.Expr.«termProd_assoc%»",
  "doc":
  "`prod_assoc%` elaborates to the \"obvious\" equivalence between iterated products of types,\nregardless of how the products are parenthesized.\nThe `prod_assoc%` term uses the expected type when elaborating.\nFor example, `(prod_assoc% : (α × β) × (γ × δ) ≃ α × (β × γ) × δ)`.\n\nThe elaborator can handle holes in the expected type,\nso long as they eventually get filled by unification.\n```lean\nexample : (α × β) × (γ × δ) ≃ α × (β × γ) × δ :=\n  (prod_assoc% : _ ≃ α × β × γ × δ).trans prod_assoc%\n```\n"},
 {"name": "«term_[⋀^_]→L[_]_»",
  "doc":
  "A continuous alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→L[R] N`,\nis a continuous map that is\n\n- multilinear : `f (update m i (c • x)) = c • f (update m i x)` and\n  `f (update m i (x + y)) = f (update m i x) + f (update m i y)`;\n- alternating : `f v = 0` whenever `v` has two equal coordinates.\n"},
 {"name": "Prefunctor.«term𝟭q»",
  "doc": "Notation for the identity prefunctor on a quiver. "},
 {"name": "List.«term_~r_»",
  "doc":
  "`IsRotated l₁ l₂` or `l₁ ~r l₂` asserts that `l₁` and `l₂` are cyclic permutations\nof each other. This is defined by claiming that `∃ n, l.rotate n = l'`. "},
 {"name": "Lean.Elab.Term.CoeImpl.«term(↑)»",
  "doc":
  "Partially applied coercion.  Equivalent to the η-reduction of `(↑ ·)` "},
 {"name": "Lean.Parser.Command.quot",
  "doc":
  "Syntax quotation for (sequences of) commands.\nThe identical syntax for term quotations takes priority,\nso ambiguous quotations like `` `($x $y) `` will be parsed as an application,\nnot two commands. Use `` `($x:command $y:command) `` instead.\nMultiple commands will be put in a `` `null `` node,\nbut a single command will not (so that you can directly\nmatch against a quotation in a command kind's elaborator). "},
 {"name": "Matrix.termGL",
  "doc":
  "`GL n R` is the group of `n` by `n` `R`-matrices with unit determinant.\nDefined as a subtype of matrices "},
 {"name": "«term_⁺»", "doc": "The *positive part* of an element `a`. "},
 {"name": "Nat.«term⌊_⌋₊»",
  "doc":
  "`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. "},
 {"name": "«term_→⋆ₐ[_]_»",
  "doc":
  "A *⋆-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. "},
 {"name": "«term_≤_»", "doc": "The less-equal relation: `x ≤ y` "},
 {"name": "Mathlib.Notation.«term∃!_,_»",
  "doc":
  "`∃! x : α, p x` means that there exists a unique `x` in `α` such that `p x`.\nThis is notation for `ExistsUnique (fun (x : α) ↦ p x)`.\n\nThis notation does not allow multiple binders like `∃! (x : α) (y : β), p x y`\nas a shorthand for `∃! (x : α), ∃! (y : β), p x y` since it is liable to be misunderstood.\nOften, the intended meaning is instead `∃! q : α × β, p q.1 q.2`.\n"},
 {"name": "Algebra.Norm.Transitivity.termMulAuxMatBlock",
  "doc": "The upper-left block of `M * aux M k`. "},
 {"name": "termMax_prec",
  "doc":
  "`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n"},
 {"name": "«term_→ₗᵢ[_]_»",
  "doc":
  "A linear isometric embedding of a normed `R`-module into another one. "},
 {"name": "«term_<*_»",
  "doc":
  "If `x : F α` and `y : F β`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. "},
 {"name": "Lean.Parser.Term.binop",
  "doc":
  "`binop% f a b` elaborates `f a b` as a binary operation using the type propagation protocol in `Lean.Elab.Extra`. "},
 {"name": "«termS(_,_)»",
  "doc":
  "`s(x, y)` is an unordered pair,\nwhich is to say a pair modulo the action of the symmetric group.\n\nIt is equal to `Sym2.mk (x, y)`. "},
 {"name": "Int.«term_≡_[ZMOD_]»",
  "doc": "`a ≡ b [ZMOD n]` when `a % n = b % n`. "},
 {"name": "«term_/ₚ_»",
  "doc":
  "Partial division. It is defined when the\nsecond argument is invertible, and unlike the division operator\nin `DivisionRing` it is not totalized at zero. "},
 {"name": "«term_>>=_»",
  "doc":
  "If `x : m α` and `f : α → m β`, then `x >>= f : m β` represents the\nresult of executing `x` to get a value of type `α` and then passing it to `f`. "},
 {"name": "«term_⌊/⌋_»",
  "doc":
  "Flooring division. If `a > 0`, then `b ⌊/⌋ a` is the greatest `c` such that `a • c ≤ b`. "},
 {"name": "«term_≃ₛₗᵢ[_]_»",
  "doc":
  "A semilinear isometric equivalence between two normed vector spaces. "},
 {"name": "termℝ",
  "doc":
  "The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. "},
 {"name": "Tactic.Elementwise.«termElementwise_of%_»",
  "doc":
  "`elementwise_of% h`, where `h` is a proof of an equation `f = g` between\nmorphisms `X ⟶ Y` in a concrete category (possibly after a `∀` binder),\nproduces a proof of equation `∀ (x : X), f x = g x`, but with compositions fully\nright associated and identities removed.\n\nA typical example is using `elementwise_of%` to dynamically generate rewrite lemmas:\n```lean\nexample (M N K : MonCat) (f : M ⟶ N) (g : N ⟶ K) (h : M ⟶ K) (w : f ≫ g = h) (m : M) :\n    g (f m) = h m := by rw [elementwise_of% w]\n```\nIn this case, `elementwise_of% w` generates the lemma `∀ (x : M), f (g x) = h x`.\n\nLike the `@[elementwise]` attribute, `elementwise_of%` inserts a `ConcreteCategory`\ninstance argument if it can't synthesize a relevant `ConcreteCategory` instance.\n(Technical note: The forgetful functor's universe variable is instantiated with a\nfresh level metavariable in this case.)\n\nOne difference between `elementwise_of%` and `@[elementwise]` is that `@[elementwise]` by\ndefault applies `simp` to both sides of the generated lemma to get something that is in simp\nnormal form. `elementwise_of%` does not do this.\n"},
 {"name": "Mathlib.Meta.«term{_|_}_1»",
  "doc":
  "* `{ pat : X | p }` is notation for pattern matching in set-builder notation,\n  where `pat` is a pattern that is matched by all objects of type `X`\n  and `p` is a proposition that can refer to variables in the pattern.\n  It is the set of all objects of type `X` which, when matched with the pattern `pat`,\n  make `p` come out true.\n* `{ pat | p }` is the same, but in the case when the type `X` can be inferred.\n\nFor example, `{ (m, n) : ℕ × ℕ | m * n = 12 }` denotes the set of all ordered pairs of\nnatural numbers whose product is 12.\n\nNote that if the type ascription is left out and `p` can be interpreted as an extended binder,\nthen the extended binder interpretation will be used.  For example, `{ n + 1 | n < 3 }` will\nbe interpreted as `{ x : Nat | ∃ n < 3, n + 1 = x }` rather than using pattern matching.\n"},
 {"name": "CategoryTheory.Limits.«term⊤__»",
  "doc": "Notation for the terminal object in `C` "},
 {"name": "Set.«term_⁻¹'_»",
  "doc":
  "`f ⁻¹' t` denotes the preimage of `t : Set β` under the function `f : α → β`. "},
 {"name": "BitVec.«term__#__»",
  "doc":
  "Notation for bit vector literals. `i#n` is a shorthand for `BitVec.ofNat n i`. "},
 {"name": "Lean.Parser.Term.explicitUniv",
  "doc":
  "`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},
 {"name": "«term_<->_»",
  "doc":
  "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},
 {"name": "«term_≤₀_»",
  "doc":
  "`p` is many-one reducible to `q` if there is a computable function translating questions about `p`\nto questions about `q`.\n"},
 {"name": "Real.«term√_»",
  "doc":
  "The square root of a real number. This returns 0 for negative inputs.\n\nThis has notation `√x`. Note that `√x⁻¹` is parsed as `√(x⁻¹)`. "},
 {"name": "Prefunctor.«term_⥤q_»",
  "doc": "Notation for a prefunctor between quivers. "},
 {"name": "«term_⁻ᵐ»", "doc": "The *negative part* of an element `a`. "},
 {"name": "«term_ᵃᵒᵖ»", "doc": "Additive opposite of a type. "},
 {"name": "MeasureTheory.«term∫⁻_In_,_∂_»",
  "doc":
  "The **lower Lebesgue integral** of a function `f` with respect to a measure `μ`. "},
 {"name": "«term-_»",
  "doc":
  "`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Function.term_On_",
  "doc":
  "Given functions `f : β → β → φ` and `g : α → β`, produce a function `α → α → φ` that evaluates\n`g` on each argument, then applies `f` to the results. Can be used, e.g., to transfer a relation\nfrom `β` to `α`. "},
 {"name": "Matrix.matrixNotation",
  "doc":
  "Notation for m×n matrices, aka `Matrix (Fin m) (Fin n) α`.\n\nFor instance:\n* `!![a, b, c; d, e, f]` is the matrix with two rows and three columns, of type\n  `Matrix (Fin 2) (Fin 3) α`\n* `!![a, b, c]` is a row vector of type `Matrix (Fin 1) (Fin 3) α` (see also `Matrix.row`).\n* `!![a; b; c]` is a column vector of type `Matrix (Fin 3) (Fin 1) α` (see also `Matrix.col`).\n\nThis notation implements some special cases:\n\n* `![,,]`, with `n` `,`s, is a term of type `Matrix (Fin 0) (Fin n) α`\n* `![;;]`, with `m` `;`s, is a term of type `Matrix (Fin m) (Fin 0) α`\n* `![]` is the 0×0 matrix\n\nNote that vector notation is provided elsewhere (by `Matrix.vecNotation`) as `![a, b, c]`.\nUnder the hood, `!![a, b, c; d, e, f]` is syntax for `Matrix.of ![![a, b, c], ![d, e, f]]`.\n"},
 {"name": "CategoryTheory.«term_⥤ₑ_»",
  "doc": "`C ⥤ₑ D` denotes exact functors `C ⥤ D` "},
 {"name": "CategoryTheory.Limits.«term_⨯_»",
  "doc": "Notation for the product "},
 {"name": "Lean.Parser.Term.open",
  "doc":
  "`open Foo in e` is like `open Foo` but scoped to a single term.\nIt makes the given namespaces available in the term `e`.\n"},
 {"name": "Asymptotics.«term_=O[_]_»",
  "doc":
  "The Landau notation `f =O[l] g` where `f` and `g` are two functions on a type `α` and `l` is\na filter on `α`, means that eventually for `l`, `‖f‖` is bounded by a constant multiple of `‖g‖`.\nIn other words, `‖f‖ / ‖g‖` is eventually bounded, modulo division by zero issues that are avoided\nby this definition. "},
 {"name": "«term_≃ₗ[_]_»",
  "doc":
  "The notation `M ≃ₗ [R] M₂` denotes the type of linear equivalences between `M` and `M₂` over\na plain linear map `M →ₗ M₂`. "},
 {"name": "«term_≃ₗᵢ[_]_»",
  "doc": "A linear isometric equivalence between two normed vector spaces. "},
 {"name": "Lean.Parser.Term.explicit",
  "doc":
  "`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},
 {"name": "«term~~~_»", "doc": "The implementation of `~~~a : α`. "},
 {"name": "«term_×_»",
  "doc":
  "Product type (aka pair). You can use `α × β` as notation for `Prod α β`.\nGiven `a : α` and `b : β`, `Prod.mk a b : Prod α β`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod α β`, `p.1 : α` and `p.2 : β`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n"},
 {"name": "«term_→ₗ⁅_,_⁆_»",
  "doc":
  "A morphism of Lie algebra modules is a linear map which commutes with the action of the Lie\nalgebra. "},
 {"name": "LeanSearchClient.leansearch_search_term",
  "doc":
  "Search [LeanSearch](https://leansearch.net/) from within Lean.\nQueries should be a string that ends with a `.` or `?`. This works as a command, as a term\nand as a tactic as in the following examples. In tactic mode, only valid tactics are displayed.\n\n```lean\n#leansearch \"If a natural number n is less than m, then the successor of n is less than the successor of m.\"\n\nexample := #leansearch \"If a natural number n is less than m, then the successor of n is less than the successor of m.\"\n\nexample : 3 ≤ 5 := by\n  #leansearch \"If a natural number n is less than m, then the successor of n is less than the successor of m.\"\n  sorry\n```\n "},
 {"name": "«term_⊕'_»",
  "doc":
  "`PSum α β`, or `α ⊕' β`, is the disjoint union of types `α` and `β`.\nIt differs from `α ⊕ β` in that it allows `α` and `β` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `True ⊕' Nat`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSum` is usually only used in automation that constructs sums of arbitrary types.\n"},
 {"name": "CategoryTheory.ReflPrefunctor.«term_⋙rq_»",
  "doc": "Notation for composition of reflexive prefunctors. "},
 {"name": "letImplDetailStx",
  "doc":
  "Mathlib extension to preserve old behavior of structure instances.\nWe need to be able to `let` some implementation details that are still local instances.\nNormally implementation detail fvars are not local instances,\nbut we need them to be implementation details so that `simp` will see them as \"reducible\" fvars.\n"},
 {"name": "Mathlib.Util.TermBeta.betaStx",
  "doc":
  "`beta% t` elaborates `t` and then if the result is in the form\n`f x1 ... xn` where `f` is a (nested) lambda expression,\nit will substitute all of its arguments by beta reduction.\nThis does not recursively do beta reduction, nor will it do\nbeta reduction of subexpressions.\n\nIn particular, `t` is elaborated, its metavariables are instantiated,\nand then `Lean.Expr.headBeta` is applied. "},
 {"name": "«term_>=>_»",
  "doc": "Left-to-right composition of Kleisli arrows. "},
 {"name": "«term_∨_»",
  "doc":
  "`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},
 {"name": "«term_⁺ᵐ»", "doc": "The *positive part* of an element `a`. "},
 {"name": "Lean.Parser.Syntax.exact?",
  "doc":
  "Searches environment for definitions or theorems that can be substituted in\nfor `exact?%` to solve the goal.\n "},
 {"name": "List.«term_<+:_»",
  "doc":
  "`IsPrefix l₁ l₂`, or `l₁ <+: l₂`, means that `l₁` is a prefix of `l₂`,\nthat is, `l₂` has the form `l₁ ++ t` for some `t`.\n"},
 {"name": "«term_≃⋆+*_»",
  "doc":
  "A *⋆-ring* equivalence is an equivalence preserving addition, multiplication, and the star\noperation, which allows for considering both unital and non-unital equivalences with a single\nstructure. "},
 {"name": "Pi.«termΠₗ_,_»",
  "doc":
  "The notation `Πₗ i, α i` refers to a pi type equipped with the lexicographic order. "},
 {"name": "Matroid.«term_✶»",
  "doc":
  "The `✶` symbol, which denotes matroid duality.\n(This is distinct from the usual `*` symbol for multiplication, due to precedence issues. )"},
 {"name": "«term⊥»", "doc": "The bot (`⊥`, `\\bot`) element "},
 {"name": "«term{}»",
  "doc":
  "`∅` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},
 {"name": "Lean.Parser.Term.letI",
  "doc":
  "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. "},
 {"name": "rawNatLit",
  "doc":
  "The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n"},
 {"name": "«term{_:_//_}»",
  "doc":
  "`Subtype p`, usually written as `{x : α // p x}`, is a type which\nrepresents all the elements `x : α` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : α` and `h : p x` then\n`⟨x, h⟩ : {x // p x}`. An element `s : {x // p x}` will coerce to `α` but\nyou can also make it explicit using `s.1` or `s.val`.\n"},
 {"name": "CategoryTheory.ExactPairing.termη_",
  "doc": "Coevaluation of an exact pairing. "},
 {"name": "«term_>=_»", "doc": "`a ≥ b` is an abbreviation for `b ≤ a`. "},
 {"name": "«term_≃_»",
  "doc":
  "`α ≃ β` is the type of functions from `α → β` with a two-sided inverse. "},
 {"name": "«term_→+*_»",
  "doc": "`α →+* β` denotes the type of ring homomorphisms from `α` to `β`. "},
 {"name": "Bool.«term_^^_»", "doc": "Boolean exclusive or "},
 {"name": "«term_∘_»",
  "doc":
  "Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f ∘ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse ∘ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse ∘ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n"},
 {"name": "Lean.Parser.Term.withDeclName",
  "doc":
  "* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},
 {"name": "Lean.Parser.Term.leftact",
  "doc":
  "`leftact% f a b` elaborates `f a b` as a left action using the type propagation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `a`, where only the right argument `b` participates in the operator coercion elaborator. "},
 {"name": "Lean.Expr.prodAssocStx",
  "doc":
  "IMPLEMENTATION: Syntax used in the implementation of `prod_assoc%`.\nThis elaborator postpones if there are metavariables in the expected type,\nand to propagate the fact that this elaborator produces an `Equiv`,\nthe `prod_assoc%` macro sets things up with a type ascription.\nThis enables using `prod_assoc%` with, for example `Equiv.trans` dot notation. "},
 {"name": "Lean.Parser.Term.sort",
  "doc": "A specific universe in Lean's infinite hierarchy of universes. "},
 {"name": "Lean.calc",
  "doc":
  "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n"},
 {"name": "«term_→*₀_»",
  "doc":
  "`α →*₀ β` denotes the type of zero-preserving monoid homomorphisms from `α` to `β`. "},
 {"name": "«term_|||_»",
  "doc":
  "`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Prod.Lex.«term_×ₗ_»",
  "doc": "A type synonym to equip a type with its lexicographic order. "},
 {"name": "«termℕ+»",
  "doc":
  "`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. "},
 {"name": "FBinopElab.prodSyntax",
  "doc":
  "`fbinop% f x y` elaborates `f x y` for `x : S α` and `y : S' β`, taking into account\nany coercions that the \"functors\" `S` and `S'` possess. "},
 {"name": "«term_≃ₐ[_]_»",
  "doc":
  "An equivalence of algebras is an equivalence of rings commuting with the actions of scalars. "},
 {"name": "«term_→r_»",
  "doc":
  "A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : α → β` such that `r a b → s (f a) (f b)`. "},
 {"name": "«term_||_»",
  "doc":
  "`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n"},
 {"name": "MeasureTheory.«term⨍_,_»",
  "doc":
  "Average value of a function `f` w.r.t. to the standard measure.\n\nIt is equal to `(volume univ).toReal⁻¹ * ∫ x, f x`, so it takes value zero if `f` is not integrable\nor if the space has infinite measure. In a probability space, the average of any function is equal\nto its integral.\n\nFor the average on a set, use `⨍ x in s, f x`, defined as `⨍ x, f x ∂(volume.restrict s)`. "},
 {"name": "«term_ˣ»",
  "doc":
  "Units of a `Monoid`, bundled version. Notation: `αˣ`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. "},
 {"name": "«term_⌈/⌉_»",
  "doc":
  "Ceiling division. If `a > 0`, then `b ⌈/⌉ a` is the least `c` such that `b ≤ a • c`. "},
 {"name": "Action.FintypeCat.«term_⧸ₐ_»",
  "doc":
  "Shorthand notation for the quotient of `G` by `H` as a finite `G`-set. "},
 {"name": "boolIfThenElse",
  "doc":
  "`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n"},
 {"name": "Mathlib.Tactic.Module.NF.«term_::ᵣ_»",
  "doc":
  "Augment a `Module.NF R M` object `l`, i.e. a list of pairs in `R × M`, by prepending another\npair `p : R × M`. "},
 {"name": "Batteries.Tactic.matchWithDot",
  "doc":
  "The syntax `match ⋯ with.` has been deprecated in favor of `nomatch ⋯`.\n\nBoth now support multiple discriminants.\n"},
 {"name": "«term_→WOT[_]_»",
  "doc":
  "The type copy of `E →L[𝕜] F` endowed with the weak operator topology, denoted as\n`E →WOT[𝕜] F`. "},
 {"name": "«term_≃+_»", "doc": "Notation for an `AddEquiv`. "},
 {"name": "CategoryTheory.«term_≌_»",
  "doc": "We infix the usual notation for an equivalence "},
 {"name": "Lean.Parser.Term.sorry",
  "doc": "A temporary placeholder for a missing proof or value. "},
 {"name": "«term_⁻¹»", "doc": "Invert an element of α. "},
 {"name": "«term_>>>_»",
  "doc":
  "`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. "},
 {"name": "Int.«term⌊_⌋»",
  "doc":
  "`Int.floor a` is the greatest integer `z` such that `z ≤ a`. It is denoted with `⌊a⌋`. "},
 {"name": "«term_∪_»", "doc": "`a ∪ b` is the union of`a` and `b`. "},
 {"name": "GradedTensorProduct.«term_ᵍ⊗ₜ[_]_»",
  "doc": "The graded tensor product of two elements of graded rings. "},
 {"name": "Matrix.matrixNotation0xC",
  "doc":
  "Notation for m×n matrices, aka `Matrix (Fin m) (Fin n) α`.\n\nFor instance:\n* `!![a, b, c; d, e, f]` is the matrix with two rows and three columns, of type\n  `Matrix (Fin 2) (Fin 3) α`\n* `!![a, b, c]` is a row vector of type `Matrix (Fin 1) (Fin 3) α` (see also `Matrix.row`).\n* `!![a; b; c]` is a column vector of type `Matrix (Fin 3) (Fin 1) α` (see also `Matrix.col`).\n\nThis notation implements some special cases:\n\n* `![,,]`, with `n` `,`s, is a term of type `Matrix (Fin 0) (Fin n) α`\n* `![;;]`, with `m` `;`s, is a term of type `Matrix (Fin m) (Fin 0) α`\n* `![]` is the 0×0 matrix\n\nNote that vector notation is provided elsewhere (by `Matrix.vecNotation`) as `![a, b, c]`.\nUnder the hood, `!![a, b, c; d, e, f]` is syntax for `Matrix.of ![![a, b, c], ![d, e, f]]`.\n"},
 {"name": "«term_[⋀^_]→ₗ[_]_»",
  "doc":
  "An alternating map from `ι → M` to `N`, denoted `M [⋀^ι]→ₗ[R] N`,\nis a multilinear map that vanishes when two of its arguments are equal. "},
 {"name": "termℤ",
  "doc":
  "The type of integers. It is defined as an inductive type based on the\nnatural number type `Nat` featuring two constructors: \"a natural\nnumber is an integer\", and \"the negation of a successor of a natural\nnumber is an integer\". The former represents integers between `0`\n(inclusive) and `∞`, and the latter integers between `-∞` and `-1`\n(inclusive).\n\nThis type is special-cased by the compiler. The runtime has a special\nrepresentation for `Int` which stores \"small\" signed numbers directly,\nand larger numbers use an arbitrary precision \"bignum\" library\n(usually [GMP](https://gmplib.org/)). A \"small number\" is an integer\nthat can be encoded with 63 bits (31 bits on 32-bits architectures).\n"},
 {"name": "«term_⊓_»", "doc": "The minimum operation: `min x y`. "},
 {"name": "«term__[_]_?»",
  "doc":
  "The syntax `arr[i]?` gets the `i`'th element of the collection `arr` or\nreturns `none` if `i` is out of bounds.\n"},
 {"name": "MeasureTheory.«term∫_In_,_∂_»", "doc": "The Bochner integral "},
 {"name": "«term_→ₗ.[_]_»",
  "doc":
  "A `LinearPMap R E F` or `E →ₗ.[R] F` is a linear map from a submodule of `E` to `F`. "},
 {"name": "«AddActionHomLocal≺»",
  "doc":
  "`φ`-equivariant functions `X → Y`,\nwhere `φ : M → N`, where `M` and `N` act additively on `X` and `Y` respectively\n\nWe use the same notation as for multiplicative actions, as conflicts are unlikely. "},
 {"name": "Lean.Parser.Term.set_option",
  "doc":
  "`set_option opt val in e` is like `set_option opt val` but scoped to a single term.\nIt sets the option `opt` to the value `val` in the term `e`.\n"},
 {"name": "Batteries.Tactic.funDot",
  "doc": "The syntax `fun.` has been deprecated in favor of `nofun`. "},
 {"name": "Lean.Parser.Term.subst",
  "doc":
  "`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\n\nThe macro tries both orientations of `h`. If the context provides an\nexpected type, it rewrites the expected type, else it rewrites the type of e`.\n\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},
 {"name": "«term_×ˢ_»",
  "doc":
  "The cartesian product `s ×ˢ t` is the set of `(a, b)` such that `a ∈ s` and `b ∈ t`. "},
 {"name": "«term_ᵐᵒᵖ»", "doc": "Multiplicative opposite of a type. "},
 {"name": "OreLocalization.«term_/ₒ_»",
  "doc":
  "The division in the Ore localization `X[S⁻¹]`, as a fraction of an element of `X` and `S`. "},
 {"name": "Lean.Parser.Term.match",
  "doc":
  "Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... => f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},
 {"name": "Set.«term⋂_,_»",
  "doc":
  "Notation for `Set.iInter`. Indexed intersection of a family of sets "},
 {"name": "«term∯_InT(_,_),_»",
  "doc":
  "The integral over a generalized torus with center `c ∈ ℂⁿ` and radius `R ∈ ℝⁿ`, defined\nas the `•`-product of the derivative of `torusMap` and `f (torusMap c R θ)`"},
 {"name": "Lean.Parser.Term.panic",
  "doc":
  "`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},
 {"name": "CategoryTheory.exp.«term_⟹_»",
  "doc": "Morphisms obtained using an exponentiable object. "},
 {"name": "«term∏ᶠ_,_»",
  "doc":
  "`∏ᶠ x, f x` is notation for `finprod f`. It is the product of `f x`, where `x` ranges over the\nmultiplicative support of `f`, if it's finite, one otherwise. Taking the product over multiple\narguments or conditions is possible, e.g. `∏ᶠ (x) (y), f x y` and `∏ᶠ (x) (h: x ∈ s), f x`"},
 {"name": "SimpleGraph.«term_□_»",
  "doc":
  "Box product of simple graphs. It relates `(a₁, b)` and `(a₂, b)` if `G` relates `a₁` and `a₂`,\nand `(a, b₁)` and `(a, b₂)` if `H` relates `b₁` and `b₂`. "},
 {"name": "«term_⇨_»", "doc": "Heyting implication "},
 {"name": "MeasureTheory.«term∫⋯∫⁻__,_»",
  "doc":
  "Integrate `f(x₁,…,xₙ)` over all variables `xᵢ` where `i ∈ s`. Return a function in the\nremaining variables (it will be constant in the `xᵢ` for `i ∈ s`).\nThis is the marginal distribution of all variables not in `s` when the considered measure\nis the product measure. "},
 {"name": "Lean.Parser.Term.pipeProj",
  "doc":
  "`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},
 {"name": "«term_ᵈᵃᵃ»",
  "doc":
  "If `M` additively acts on `α`, then `DomAddAct M` acts on `α → β` as\nwell as some bundled maps from `α`. This is a type synonym for `AddOpposite M`, so this corresponds\nto a right action of `M`."},
 {"name": "Lean.Parser.Term.prop",
  "doc": "The universe of propositions. `Prop ≡ Sort 0`. "},
 {"name": "«term_≃ₛₗ[_]_»",
  "doc":
  "The notation `M ≃ₛₗ[σ] M₂` denotes the type of linear equivalences between `M` and `M₂` over a\nring homomorphism `σ`. "},
 {"name": "«term_∣_»",
  "doc":
  "Divisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. "},
 {"name": "«termℓ²(_,_)»",
  "doc":
  "`ℓ²(ι, 𝕜)` is the Hilbert space of square-summable functions `ι → 𝕜`, herein implemented\nas `lp (fun i : ι => 𝕜) 2`. "},
 {"name": "CategoryTheory.«term_⟦_⟧'»",
  "doc": "shifting a morphism `f` by `n` is obtained by the notation `f⟦n⟧'` "},
 {"name": "«termℤ_[_]»", "doc": "The ring of `p`-adic integers. "},
 {"name": "«term_=<<_»",
  "doc": "Same as `Bind.bind` but with arguments swapped. "},
 {"name": "PiLp.vecNotation",
  "doc":
  "Notation for vectors in Lp space. `!₂[x, y, ...]` is a shorthand for\n`(WithLp.equiv 2 _ _).symm ![x, y, ...]`, of type `EuclideanSpace _ (Fin _)`.\n\nThis also works for other subscripts. "},
 {"name": "«term_⊂_»", "doc": "Strict subset relation: `a ⊂ b`  "},
 {"name": "«term_≃r_»",
  "doc":
  "A relation isomorphism is an equivalence that is also a relation embedding. "},
 {"name": "Class.«term_′_»", "doc": "Function value "},
 {"name": "CategoryTheory.termβ_", "doc": "The braiding natural isomorphism. "},
 {"name": "coeNotation",
  "doc":
  "`↑x` represents a coercion, which converts `x` of type `α` to type `β`, using\ntypeclasses to resolve a suitable conversion function. You can often leave the\n`↑` off entirely, since coercion is triggered implicitly whenever there is a\ntype error, but in ambiguous cases it can be useful to use `↑` to disambiguate\nbetween e.g. `↑x + ↑y` and `↑(x + y)`.\n"},
 {"name": "Set.term𝒫_", "doc": "`𝒫 s` is the set of all subsets of `s`. "},
 {"name": "MeasureTheory.«term∀ᵐ_,_»",
  "doc":
  "`∀ᵐ a, p a` means that `p a` for a.e. `a`, i.e. `p` holds true away from a null set.\n\nThis is notation for `Filter.Eventually P (MeasureTheory.ae MeasureSpace.volume)`. "},
 {"name": "«term_=_»",
  "doc":
  "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},
 {"name": "«term_⟶_»",
  "doc":
  "Notation for the type of edges/arrows/morphisms between a given source and target\nin a quiver or category.\n"},
 {"name": "Multiset.«term_::ₘ_»",
  "doc":
  "`cons a s` is the multiset which contains `s` plus one more instance of `a`. "},
 {"name": "«term_→L⋆[_]_»",
  "doc":
  "Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `M₂` will be topological modules over the topological\nring `R`. "},
 {"name": "Sigma.Lex.«termΣₗ_,_»",
  "doc":
  "The notation `Σₗ i, α i` refers to a sigma type equipped with the lexicographic order. "},
 {"name": "«term_→⋆ₙ+*_»",
  "doc":
  "`α →⋆ₙ+* β` denotes the type of non-unital ring homomorphisms from `α` to `β`. "},
 {"name": "«term_⩿_»", "doc": "Notation for `WCovBy a b`. "},
 {"name": "Mathlib.Tactic.TermCongr.cHoleExpand",
  "doc":
  "(Internal for `congr(...)`)\nElaborates to an expression satisfying `cHole?` that equals the LHS or RHS of `h`,\nif the LHS or RHS is available after elaborating `h`. Uses the expected type as a hint. "},
 {"name": "Lean.Parser.Term.hole",
  "doc":
  "A *hole* (or *placeholder term*), which stands for an unknown term that is expected to be inferred based on context.\nFor example, in `@id _ Nat.zero`, the `_` must be the type of `Nat.zero`, which is `Nat`.\n\nThe way this works is that holes create fresh metavariables.\nThe elaborator is allowed to assign terms to metavariables while it is checking definitional equalities.\nThis is often known as *unification*.\n\nNormally, all holes must be solved for. However, there are a few contexts where this is not necessary:\n* In `match` patterns, holes are catch-all patterns.\n* In some tactics, such as `refine'` and `apply`, unsolved-for placeholders become new goals.\n\nRelated concept: implicit parameters are automatically filled in with holes during the elaboration process.\n\nSee also `?m` syntax (synthetic holes).\n"},
 {"name": "«term_→ₙₐ[_]_»",
  "doc":
  "A morphism respecting addition, multiplication, and scalar multiplication. When these arise from\nalgebra structures, this is the same as a not-necessarily-unital morphism of algebras. "},
 {"name": "«term_^_»",
  "doc":
  "`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "«term_•_»",
  "doc":
  "`a • b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent, but it is intended to be used for left actions. "},
 {"name": "Polynomial.«term_%ₘ_»",
  "doc": "`modByMonic` gives the remainder of `p` by a monic polynomial `q`. "},
 {"name": "Set.termΙ",
  "doc":
  "`Ι a b` denotes the open-closed interval with unordered bounds. Here, `Ι` is a capital iota,\ndistinguished from a capital `i`. "},
 {"name": "Lean.Parser.Term.termReturn",
  "doc":
  "`return` used outside of `do` blocks creates an implicit block around it\nand thus is equivalent to `pure e`, but helps with avoiding parentheses.\n"},
 {"name": "«term_→ₐ[_]_»",
  "doc": "Defining the homomorphism in the category R-Alg. "},
 {"name": "Lean.Parser.Term.clear",
  "doc":
  "`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},
 {"name": "Lean.Parser.Term.proj",
  "doc":
  "The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},
 {"name": "«term_^[_]»", "doc": "Iterate a function. "},
 {"name": "RCLike.«term⟪_,_⟫ₙ_[_]»",
  "doc": "Compact inner product giving rise to the compact L2 norm. "},
 {"name": "Matrix.matrixNotationRx0",
  "doc":
  "Notation for m×n matrices, aka `Matrix (Fin m) (Fin n) α`.\n\nFor instance:\n* `!![a, b, c; d, e, f]` is the matrix with two rows and three columns, of type\n  `Matrix (Fin 2) (Fin 3) α`\n* `!![a, b, c]` is a row vector of type `Matrix (Fin 1) (Fin 3) α` (see also `Matrix.row`).\n* `!![a; b; c]` is a column vector of type `Matrix (Fin 3) (Fin 1) α` (see also `Matrix.col`).\n\nThis notation implements some special cases:\n\n* `![,,]`, with `n` `,`s, is a term of type `Matrix (Fin 0) (Fin n) α`\n* `![;;]`, with `m` `;`s, is a term of type `Matrix (Fin m) (Fin 0) α`\n* `![]` is the 0×0 matrix\n\nNote that vector notation is provided elsewhere (by `Matrix.vecNotation`) as `![a, b, c]`.\nUnder the hood, `!![a, b, c; d, e, f]` is syntax for `Matrix.of ![![a, b, c], ![d, e, f]]`.\n"},
 {"name": "«term__[_]»",
  "doc":
  "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n"},
 {"name": "Filter.«term_=ᶠ[_]_»",
  "doc":
  "Two functions `f` and `g` are *eventually equal* along a filter `l` if the set of `x` such that\n`f x = g x` belongs to `l`. "},
 {"name": "Lean.Json.«termJson%_»",
  "doc": "Allows to use Json syntax in a Lean file. "},
 {"name": "Quotient.«term⟦_⟧»",
  "doc": "The canonical quotient map into a `Quotient`. "},
 {"name": "«term_&&_»",
  "doc":
  "`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop → Prop → Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n"},
 {"name": "MeasureTheory.«term∫⋯∫⁻__,_∂_»",
  "doc":
  "Integrate `f(x₁,…,xₙ)` over all variables `xᵢ` where `i ∈ s`. Return a function in the\nremaining variables (it will be constant in the `xᵢ` for `i ∈ s`).\nThis is the marginal distribution of all variables not in `s` when the considered measure\nis the product measure. "},
 {"name": "«term_*_»",
  "doc":
  "`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "«term￢_»", "doc": "Heyting negation "},
 {"name": "Filter.«term_≤ᶠ[_]_»",
  "doc":
  "A function `f` is eventually less than or equal to a function `g` at a filter `l`. "},
 {"name": "CategoryTheory.NatTrans.«term_◫_»",
  "doc": "Notation for horizontal composition of natural transformations. "},
 {"name": "Lean.Parser.Term.unsafe",
  "doc":
  "`unsafe t : α` is an expression constructor which allows using unsafe declarations inside the\nbody of `t : α`, by creating an auxiliary definition containing `t` and using `implementedBy` to\nwrap it in a safe interface. It is required that `α` is nonempty for this to be sound,\nbut even beyond that, an `unsafe` block should be carefully inspected for memory safety because\nthe compiler is unable to guarantee the safety of the operation.\n\nFor example, the `evalExpr` function is unsafe, because the compiler cannot guarantee that when\nyou call ```evalExpr Foo ``Foo e``` that the type `Foo` corresponds to the name `Foo`, but in a\nparticular use case, we can ensure this, so `unsafe (evalExpr Foo ``Foo e)` is a correct usage.\n"},
 {"name": "«term_≃._»",
  "doc":
  "A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `α` and a subset of `β`. See also `PartialEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. "},
 {"name": "Lean.includeStr",
  "doc":
  "When `parent_dir` contains the current Lean file, `include_str \"path\" / \"to\" / \"file\"` becomes\na string literal with the contents of the file at `\"parent_dir\" / \"path\" / \"to\" / \"file\"`. If this\nfile cannot be read, elaboration fails.\n"},
 {"name": "List.«term_<:+:_»",
  "doc":
  "`IsInfix l₁ l₂`, or `l₁ <:+: l₂`, means that `l₁` is a contiguous\nsubstring of `l₂`, that is, `l₂` has the form `s ++ l₁ ++ t` for some `s, t`.\n"},
 {"name": "PiNotation.piNotation",
  "doc":
  "Dependent function type (a \"pi type\"). The notation `Π x : α, β x` can\nalso be written as `(x : α) → β x`. "},
 {"name": "«term_<<<_»",
  "doc":
  "`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. "},
 {"name": "«term⊤»", "doc": "The top (`⊤`, `\\top`) element "},
 {"name": "«term_→+*o_»",
  "doc":
  "`OrderRingHom α β` is the type of monotone semiring homomorphisms from `α` to `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingHom α β)`,\nyou should parametrize over `(F : Type*) [OrderRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingHomClass`. "},
 {"name": "TensorProduct.«term_⊗ₜ_»",
  "doc": "The canonical function `M → N → M ⊗ N`. "},
 {"name": "Asymptotics.«term_=Θ[_]_»",
  "doc":
  "We say that `f` is `Θ(g)` along a filter `l` (notation: `f =Θ[l] g`) if `f =O[l] g` and\n`g =O[l] f`. "},
 {"name": "«term_⊻_»",
  "doc": "The point-wise supremum `a ⊔ b` of `a, b : α`. "},
 {"name": "«term_→L[_]_»",
  "doc":
  "Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `M₂` will be topological modules over the topological\nring `R`. "},
 {"name": "«term_→ₗ[_]_»",
  "doc": "`M →ₗ[R] N` is the type of `R`-linear maps from `M` to `N`. "},
 {"name": "«term|___|»", "doc": "`abs a` is the absolute value of `a`"},
 {"name": "«term_≃ₜ_»",
  "doc":
  "Homeomorphism between `X` and `Y`, also called topological isomorphism "},
 {"name": "TypeVec.«term_:::__1»",
  "doc":
  "append an arrow and a function as well as their respective source and target types / typevecs "},
 {"name": "MeasureTheory.«term⨍_,_∂_»",
  "doc":
  "Average value of a function `f` w.r.t. a measure `μ`.\n\nIt is equal to `(μ univ).toReal⁻¹ • ∫ x, f x ∂μ`, so it takes value zero if `f` is not integrable or\nif `μ` is an infinite measure. If `μ` is a probability measure, then the average of any function is\nequal to its integral.\n\nFor the average on a set, use `⨍ x in s, f x ∂μ`, defined as `⨍ x, f x ∂(μ.restrict s)`. For the\naverage w.r.t. the volume, one can omit `∂volume`. "},
 {"name": "CategoryTheory.Limits.«term∏ᶜ_»",
  "doc":
  "notation for categorical products. We need `ᶜ` to avoid conflict with `Finset.prod`. "},
 {"name": "AlgebraicGeometry.«term_∣__»",
  "doc":
  "the notation for restricting a morphism of scheme to an open subset of the target scheme "},
 {"name": "LeanSearchClient.loogle_term",
  "doc":
  "Search [Loogle](https://loogle.lean-lang.org/json) from within Lean. This can be used as a command, term or tactic as in the following examples. In the case of a tactic, only valid tactics are displayed.\n\n\n```lean\n#loogle List ?a → ?a\n\nexample := #loogle List ?a → ?a\n\nexample : 3 ≤ 5 := by\n  #loogle Nat.succ_le_succ\n  sorry\n\n```\n\n## Loogle Usage\n\nLoogle finds definitions and lemmas in various ways:\n\nBy constant:\n🔍 Real.sin\nfinds all lemmas whose statement somehow mentions the sine function.\n\nBy lemma name substring:\n🔍 \\\"differ\\\"\nfinds all lemmas that have \\\"differ\\\" somewhere in their lemma name.\n\nBy subexpression:\n🔍 _ * (_ ^ _)\nfinds all lemmas whose statements somewhere include a product where the second argument is raised to some power.\n\nThe pattern can also be non-linear, as in\n🔍 Real.sqrt ?a * Real.sqrt ?a\n\nIf the pattern has parameters, they are matched in any order. Both of these will find List.map:\n🔍 (?a -> ?b) -> List ?a -> List ?b\n🔍 List ?a -> (?a -> ?b) -> List ?b\n\nBy main conclusion:\n🔍 |- tsum _ = _ * tsum _\nfinds all lemmas where the conclusion (the subexpression to the right of all → and ∀) has the given shape.\n\nAs before, if the pattern has parameters, they are matched against the hypotheses of the lemma in any order; for example,\n🔍 |- _ < _ → tsum _ < tsum _\nwill find tsum_lt_tsum even though the hypothesis f i < g i is not the last.\n\nIf you pass more than one such search filter, separated by commas Loogle will return lemmas which match all of them. The search\n🔍 Real.sin, \\\"two\\\", tsum, _ * _, _ ^ _, |- _ < _ → _\nwoould find all lemmas which mention the constants Real.sin and tsum, have \\\"two\\\" as a substring of the lemma name, include a product and a power somewhere in the type, and have a hypothesis of the form _ < _ (if there were any such lemmas). Metavariables (?a) are assigned independently in each filter.\n"},
 {"name": "BigOperators.bigexpect",
  "doc":
  "* `𝔼 i ∈ s, f i` is notation for `Finset.expect s f`. It is the expectation of `f i` where `i`\n  ranges over the finite set `s` (either a `Finset` or a `Set` with a `Fintype` instance).\n* `𝔼 i, f i` is notation for `Finset.expect Finset.univ f`. It is the expectation of `f i` where `i`\n  ranges over the finite domain of `f`.\n* `𝔼 i ∈ s with p i, f i` is notation for `Finset.expect (Finset.filter p s) f`.\n* `𝔼 (i ∈ s) (j ∈ t), f i j` is notation for `Finset.expect (s ×ˢ t) (fun ⟨i, j⟩ ↦ f i j)`.\n\nThese support destructuring, for example `𝔼 ⟨i, j⟩ ∈ s ×ˢ t, f i j`.\n\nNotation: `\"𝔼\" bigOpBinders* (\"with\" term)? \",\" term` "},
 {"name": "«term_→A[_]_»",
  "doc":
  "Continuous algebra homomorphisms between algebras. We only put the type classes that are\nnecessary for the definition, although in applications `M` and `B` will be topological algebras\nover the topological ring `R`. "},
 {"name": "CategoryTheory.«termTo_app_of%_»",
  "doc":
  "Given an equation `t` of the form `η = θ` between 2-morphisms `f ⟶ g` with `f g : C ⟶ D` in the\nbicategory `Cat` (possibly after a `∀` binder), `to_app_of% t` produces the equation\n`∀ (X : C), η.app X = θ.app X` (where `X` is an object in the domain of `f` and `g`), and simplifies\nit suitably using basic lemmas about `NatTrans.app`.\n"},
 {"name": "«term_<=_»", "doc": "The less-equal relation: `x ≤ y` "},
 {"name": "Lean.Parser.Term.unop",
  "doc":
  "`unop% f a` elaborates `f a` as a unary operation using the type propagation protocol in `Lean.Elab.Extra`. "},
 {"name": "«MulActionHomLocal≺»",
  "doc":
  "`φ`-equivariant functions `X → Y`,\nwhere `φ : M → N`, where `M` and `N` act on `X` and `Y` respectively."},
 {"name": "«term_≃ᵢ_»",
  "doc":
  "`α` and `β` are isometric if there is an isometric bijection between them. "},
 {"name": "CategoryTheory.«termᘁ__1»",
  "doc": "The left adjoint mate `ᘁf : ᘁY ⟶ ᘁX` of a morphism `f : X ⟶ Y`. "},
 {"name": "MeasureTheory.«term∫_,_»", "doc": "The Bochner integral "},
 {"name": "Finsupp.stxUpdate₀",
  "doc":
  "Implementation detail for `fun₀`, used by both `Finsupp` and `DFinsupp` "},
 {"name": "«term_→ᵃⁱ[_]_»",
  "doc":
  "A `𝕜`-affine isometric embedding of one normed add-torsor over a normed `𝕜`-space into\nanother. "},
 {"name": "«term_→ₙ*_»",
  "doc":
  "`M →ₙ* N` denotes the type of multiplication-preserving maps from `M` to `N`. "},
 {"name": "«term∑ᶠ_,_»",
  "doc":
  "`∑ᶠ x, f x` is notation for `finsum f`. It is the sum of `f x`, where `x` ranges over the\nsupport of `f`, if it's finite, zero otherwise. Taking the sum over multiple arguments or\nconditions is possible, e.g. `∏ᶠ (x) (y), f x y` and `∏ᶠ (x) (h: x ∈ s), f x`"},
 {"name": "«term_⁻»", "doc": "The *negative part* of an element `a`. "},
 {"name": "CategoryTheory.«term_⥤ᵣ_»",
  "doc": "`C ⥤ᵣ D` denotes right exact functors `C ⥤ D` "},
 {"name": "Lean.Parser.Term.binop_lazy",
  "doc":
  "`binop_lazy%` is similar to `binop% f a b`, but it wraps `b` as a function from `Unit`. "},
 {"name": "SimpleGraph.«term_↪g_»",
  "doc":
  "A graph embedding is an embedding `f` such that for vertices `v w : V`,\n`G.Adj (f v) (f w) ↔ G.Adj v w`. Its image is an induced subgraph of G'.\n\nThe notation `G ↪g G'` represents the type of graph embeddings. "},
 {"name": "«term_≺i_»",
  "doc":
  "If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an order\nembedding whose range is an open interval `(-∞, top)` for some element `top` of `β`. Such order\nembeddings are called principal segments "},
 {"name": "ZFSet.«term⋂₀_»",
  "doc":
  "The intersection operator, the collection of elements in all of the elements of a ZFC set. We\ndefine `⋂₀ ∅ = ∅`. "},
 {"name": "CategoryTheory.«term_ᘁ_1»",
  "doc": "The right adjoint mate `fᘁ : Xᘁ ⟶ Yᘁ` of a morphism `f : X ⟶ Y`. "},
 {"name": "«MulSemiringActionHomIdLocal≺»",
  "doc": "Equivariant ring homomorphisms. "},
 {"name": "Lean.«termSatisfies_binder_pred%__»",
  "doc":
  "`satisfies_binder_pred% t pred` expands to a proposition expressing that `t` satisfies `pred`.\n"},
 {"name": "«term_≃L⋆[_]_»",
  "doc":
  "Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `M₂` will be topological modules over the\ntopological semiring `R`. "},
 {"name": "«term_≃*_»", "doc": "Notation for a `MulEquiv`. "},
 {"name": "«term_/\\_»",
  "doc":
  "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n"},
 {"name": "«term_≃ₐc[_]_»",
  "doc":
  "An equivalence of bialgebras is an invertible bialgebra homomorphism. "},
 {"name": "CategoryTheory.ExactPairing.termε_",
  "doc": "Evaluation of an exact pairing. "},
 {"name": "«termΩ[_⁄_]»",
  "doc":
  "The module of Kähler differentials (Kahler differentials, Kaehler differentials).\nThis is implemented as `I / I ^ 2` with `I` the kernel of the multiplication map `S ⊗[R] S →ₐ[R] S`.\nTo view elements as a linear combination of the form `s • D s'`, use\n`KaehlerDifferential.tensorProductTo_surjective` and `Derivation.tensorProductTo_tmul`.\n\nWe also provide the notation `Ω[S⁄R]` for `KaehlerDifferential R S`.\nNote that the slash is `\\textfractionsolidus`.\n"},
 {"name": "Lean.Elab.Term.CoeImpl.«term(⇑)»",
  "doc":
  "Partially applied function coercion.  Equivalent to the η-reduction of `(⇑ ·)` "},
 {"name": "Lean.Parser.Term.doubleQuotedName",
  "doc":
  "A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},
 {"name": "Finsupp.stxSingle₀",
  "doc":
  "Implementation detail for `fun₀`, used by both `Finsupp` and `DFinsupp` "},
 {"name": "Finsupp.fun₀",
  "doc":
  "`fun₀ | i => a` is notation for `Finsupp.single i a`, and with multiple match arms,\n`fun₀ ... | i => a` is notation for `Finsupp.update (fun₀ ...) i a`.\n\nAs a result, if multiple match arms coincide, the last one takes precedence. \n\nIf the expected type is `Π₀ i, α i` (`DFinsupp`)\n  and `Mathlib.Data.DFinsupp.Notation` is imported,\n  then this is notation for `DFinsupp.single` and  `Dfinsupp.update` instead."},
 {"name": "«term_≃*o_»", "doc": "Infix notation for `OrderMonoidIso`. "},
 {"name": "coeFunNotation", "doc": "`⇑ t` coerces `t` to a function. "},
 {"name": "«DistribMulActionHomLocal≺»",
  "doc": "Equivariant additive monoid homomorphisms. "},
 {"name": "«term_×'_»",
  "doc":
  "Similar to `Prod`, but `α` and `β` can be propositions.\nYou can use `α ×' β` as notation for `PProd α β`.\nWe use this type internally to automatically generate the `brecOn` recursor.\n"},
 {"name": "«term_⧸_»",
  "doc": "Quotient notation based on the `HasQuotient` typeclass "},
 {"name": "«term_&&&_»",
  "doc":
  "`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "«term_≃+*_»", "doc": "Notation for `RingEquiv`. "},
 {"name": "Lean.Parser.Term.let_delayed",
  "doc":
  "`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},
 {"name": "Mathlib.Meta.eval_expr",
  "doc":
  "`eval% x` evaluates the term `x : X` in the interpreter, and then injects the resulting expression.\n\nAs an example:\n```lean\nexample : 2^10 = eval% 2^10 := by\n  -- goal is `2^10 = 1024`\n  sorry\n```\nThis only works if a `Lean.ToExpr X` instance is available.\n\nTip: you can use `show_term eval% x` to see the value of `eval% x`.\n"},
 {"name": "Lean.Parser.Term.namedPattern",
  "doc":
  "`x@e` or `x@h:e` matches the pattern `e` and binds its value to the identifier `x`.\nIf present, the identifier `h` is bound to a proof of `x = e`. "},
 {"name": "Lean.Parser.Term.noErrorIfUnused",
  "doc":
  "Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},
 {"name": "CategoryTheory.«term_↘_»",
  "doc": "The structure morphism `X ↘ S : X ⟶ S` given `OverClass X S`. "},
 {"name": "Lean.termThrowError__",
  "doc":
  "Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe result of `getRef` is used as position information.\nRecall that `getRef` returns the current \"reference\" syntax.\n"},
 {"name": "termIfThenElse",
  "doc":
  "`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n"},
 {"name": "Mathlib.Meta.macroPattSetBuilder",
  "doc":
  "* `{ pat : X | p }` is notation for pattern matching in set-builder notation,\n  where `pat` is a pattern that is matched by all objects of type `X`\n  and `p` is a proposition that can refer to variables in the pattern.\n  It is the set of all objects of type `X` which, when matched with the pattern `pat`,\n  make `p` come out true.\n* `{ pat | p }` is the same, but in the case when the type `X` can be inferred.\n\nFor example, `{ (m, n) : ℕ × ℕ | m * n = 12 }` denotes the set of all ordered pairs of\nnatural numbers whose product is 12.\n\nNote that if the type ascription is left out and `p` can be interpreted as an extended binder,\nthen the extended binder interpretation will be used.  For example, `{ n + 1 | n < 3 }` will\nbe interpreted as `{ x : Nat | ∃ n < 3, n + 1 = x }` rather than using pattern matching.\n"},
 {"name": "«term_*>_»",
  "doc":
  "If `x : F α` and `y : F β`, then `x *> y` evaluates `x`, then `y`,\nand returns the result of `y`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit → f β` function. "},
 {"name": "Lean.Parser.Term.assert",
  "doc": "`assert! cond` panics if `cond` evaluates to `false`. "},
 {"name": "StrictWeakOrder.«term_≈[_]_»",
  "doc": "The equivalence relation induced by `lt` "},
 {"name": "«term_ᵒᵖ»",
  "doc":
  "The type of objects of the opposite of `α`; used to define the opposite category.\n\nNow that Lean 4 supports definitional eta equality for records,\nboth `unop (op X) = X` and `op (unop X) = X` are definitional equalities.\n\n"},
 {"name": "Batteries.ExtendedBinder.«term∃ᵉ_,_»",
  "doc":
  "The syntax `∃ᵉ (x < 2) (y < 3), p x y` is shorthand for `∃ x < 2, ∃ y < 3, p x y`. "},
 {"name": "Lean.Parser.Term.showTermElabImpl",
  "doc": "Implementation of the `show_term` term elaborator.\n"},
 {"name": "Batteries.ExtendedBinder.«term∀ᵉ_,_»",
  "doc":
  "The syntax `∀ᵉ (x < 2) (y < 3), p x y` is shorthand for `∀ x < 2, ∀ y < 3, p x y`. "},
 {"name": "MeasureTheory.«term∃ᵐ_,_»",
  "doc":
  "`∃ᵐ a, p a` means that `p` holds frequently, i.e. on a set of positive measure,\nw.r.t. the volume measure.\n\nThis is notation for `Filter.Frequently P (MeasureTheory.ae MeasureSpace.volume)`. "},
 {"name": "«term_→⋆ₐ_»",
  "doc":
  "A *⋆-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. "},
 {"name": "«term_ᶜ»", "doc": "Set / lattice complement "},
 {"name": "Prefunctor.«term_⋙q_»",
  "doc": "Notation for composition of prefunctors. "},
 {"name": "«term_→._»",
  "doc":
  "`α →. β` is notation for the type `PFun α β` of partial functions from `α` to `β`. "},
 {"name": "«term_→ₐ_»",
  "doc": "Defining the homomorphism in the category R-Alg. "},
 {"name": "Set.«term⋂₀_»",
  "doc": "Notation for `Set.sInter` Intersection of a set of sets. "},
 {"name": "«term_<_»", "doc": "The less-than relation: `x < y` "},
 {"name": "«term_<$>_»",
  "doc": "If `f : α → β` and `x : F α` then `f <$> x : F β`. "},
 {"name": "SimpleGraph.«term_≃g_»",
  "doc":
  "A graph isomorphism is a bijective map on vertex sets that respects adjacency relations.\n\nThe notation `G ≃g G'` represents the type of graph isomorphisms.\n"},
 {"name": "CategoryTheory.Pretriangulated.termDistTriang_",
  "doc": "distinguished triangles in a pretriangulated category "},
 {"name": "MeasureTheory.«term_≤ᵐ[_]_»",
  "doc":
  "`f ≤ᵐ[μ] g` means `f` is eventually less than `g` along the a.e. filter,\ni.e. `f ≤ g` away from a null set.\n\nThis is notation for `Filter.EventuallyLE (MeasureTheory.ae μ) f g`. "},
 {"name": "GradedTensorProduct.«term_ᵍ⊗ₜ_»",
  "doc": "The graded tensor product of two elements of graded rings. "},
 {"name": "Lean.Parser.Term.type",
  "doc": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "}]